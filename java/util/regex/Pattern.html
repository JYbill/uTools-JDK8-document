<!-- NewPage -->   
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<!-- Generated by javadoc (1.8.0) on Tue Mar 04 03:12:51 PST 2014 --> 
<title>Pattern (Java Platform SE 8 )</title> 
<meta name="date" content="2014-03-04"> 
<meta name="keywords" content="java.util.regex.Pattern class"> 
<meta name="keywords" content="UNIX_LINES"> 
<meta name="keywords" content="CASE_INSENSITIVE"> 
<meta name="keywords" content="COMMENTS"> 
<meta name="keywords" content="MULTILINE"> 
<meta name="keywords" content="LITERAL"> 
<meta name="keywords" content="DOTALL"> 
<meta name="keywords" content="UNICODE_CASE"> 
<meta name="keywords" content="CANON_EQ"> 
<meta name="keywords" content="UNICODE_CHARACTER_CLASS"> 
<meta name="keywords" content="compile()"> 
<meta name="keywords" content="pattern()"> 
<meta name="keywords" content="toString()"> 
<meta name="keywords" content="matcher()"> 
<meta name="keywords" content="flags()"> 
<meta name="keywords" content="matches()"> 
<meta name="keywords" content="split()"> 
<meta name="keywords" content="quote()"> 
<meta name="keywords" content="asPredicate()"> 
<meta name="keywords" content="splitAsStream()"> 
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style"> 
<script type="text/javascript" src="../../../script.js"></script> 
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="Pattern (Java Platform SE 8 )";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":10,"i1":9,"i2":9,"i3":10,"i4":10,"i5":9,"i6":10,"i7":9,"i8":10,"i9":10,"i10":10,"i11":10};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script> 
<noscript>
  &lt;div&gt; JavaScript is disabled on your browser. 
</noscript> 
<!-- ========= START OF TOP NAVBAR ======= -->   
<div class="topNav"> 
 <a name="navbar.top"> 
  <!--   --> </a> 
 <div class="skipNav"> 
  <a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a> 
 </div> 
 <a name="navbar.top.firstrow"> 
  <!--   --> </a> 
 <ul class="navList" title="Navigation"> 
  <li><a href="../../../overview-summary.html">概述</a></li> 
  <li><a href="package-summary.html">软件包</a></li> 
  <li class="navBarCell1Rev">类</li> 
  <li><a href="class-use/Pattern.html">使用</a></li> 
  <li><a href="package-tree.html">树</a></li> 
  <li><a href="../../../deprecated-list.html">已过时的</a></li> 
  <li><a href="../../../index-files/index-1.html">索引</a></li> 
  <li><a href="../../../help-doc.html">帮助</a></li> 
 </ul> 
 <div class="aboutLanguage"> 
  <strong>Java™&nbsp;Platform<br>Standard&nbsp;Ed.&nbsp;8</strong> 
 </div> 
</div> 
<div class="subNav"> 
 <ul class="navList"> 
  <li><a href="../../../java/util/regex/MatchResult.html" title="interface in java.util.regex"><span class="typeNameLink">上一个</span></a></li> 
  <li><a href="../../../java/util/regex/PatternSyntaxException.html" title="class in java.util.regex"><span class="typeNameLink">下一个</span></a></li> 
 </ul> 
 <ul class="navList"> 
  <li><a href="../../../index.html?java/util/regex/Pattern.html" target="_top">框架</a></li> 
  <li><a href="Pattern.html" target="_top">无框架</a></li> 
 </ul> 
 <ul class="navList" id="allclasses_navbar_top"> 
  <li><a href="../../../allclasses-noframe.html">所有类</a></li> 
 </ul> 
 <div> 
  <script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script> 
 </div> 
 <div> 
  <ul class="subNavList"> 
   <li>概要：</li> 
   <li>嵌套</li> 
   <li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li> 
   <li>构造方法</li> 
   <li><a href="#method.summary">方法</a></li> 
  </ul> 
  <ul class="subNavList"> 
   <li>详细信息：</li> 
   <li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li> 
   <li>构造方法</li> 
   <li><a href="#method.detail">方法</a></li> 
  </ul> 
 </div> 
 <a name="skip.navbar.top"> 
  <!--   --> </a> 
</div> 
<!-- ========= END OF TOP NAVBAR ========= --> 
<!-- ======== START OF CLASS DATA ======== --> 
<div class="header"> 
 <div class="subTitle">
   compact1, compact2, compact3 
 </div> 
 <div class="subTitle">
   java.util.regex 
 </div> 
 <h2 title="Class Pattern" class="title">Class Pattern</h2> 
</div> 
<div class="contentContainer"> 
 <ul class="inheritance"> 
  <li><a href="../../../java/lang/Object.html" title="class in java.lang">java.lang.Object</a></li> 
  <li> 
   <ul class="inheritance"> 
    <li>java.util.regex.Pattern</li> 
   </ul> </li> 
 </ul> 
 <div class="description"> 
  <ul class="blockList"> 
   <li class="blockList"> 
    <dl> 
     <dt>
       All Implemented Interfaces: 
     </dt> 
     <dd data-fanyi="1"> 
      <a href="../../../java/io/Serializable.html" title="interface in java.io">Serializable</a> 
     </dd> 
    </dl> 
    <hr> <br> <pre>public final class <span class="typeNameLabel">Pattern</span>
extends <a href="../../../java/lang/Object.html" title="class in java.lang">Object</a>
implements <a href="../../../java/io/Serializable.html" title="interface in java.io">Serializable</a></pre> 
    <div class="block" data-fanyi="1">
      正则表达式的编译表示。 
     <p data-fanyi="1">正则表达式，指定为一个字符串，必须首先被编译为这个类的一个实例。然后得到的模式可以用来创建一个<a href="../../../java/util/regex/Matcher.html" title="class in java.util.regex"><code>Matcher</code></a>对象可以匹配任意<a href="../../../java/lang/CharSequence.html" title="interface in java.lang">character sequences</a>与正则表达式。所有国家参与执行匹配驻留在匹配，所以许多匹配器可以共享相同的模式。</p> 
     <p data-fanyi="1">因此，一个典型的调用序列</p> 
     <blockquote> 
      <pre>
 Pattern p = Pattern.<a href="../../../java/util/regex/Pattern.html#compile-java.lang.String-"><code>compile</code></a>("a*b");
 Matcher m = p.<a href="../../../java/util/regex/Pattern.html#matcher-java.lang.CharSequence-"><code>matcher</code></a>("aaaaab");
 boolean b = m.<a href="../../../java/util/regex/Matcher.html#matches--"><code>matches</code></a>();</pre> 
     </blockquote> 
     <p data-fanyi="1">一个<a href="../../../java/util/regex/Pattern.html#matches-java.lang.String-java.lang.CharSequence-"><code>matches</code></a>方法是通过这个类定义为方便当正则表达式是只使用一次。此方法编译一个表达式，并将其与一个在一个调用中对其进行匹配的输入序列。声明</p> 
     <blockquote> 
      <pre>
 boolean b = Pattern.matches("a*b", "aaaaab");</pre> 
     </blockquote>相当于三以上，虽然重复匹配效率较低，因为它不允许编译的模式可以重复使用。 
     <p data-fanyi="1">此类的实例是不可变的，并且使用多个并发线程是安全的。该<a href="../../../java/util/regex/Matcher.html" title="class in java.util.regex"><code>Matcher</code></a>类的实例是不安全的使用。</p> 
     <h3 data-fanyi="1"><a name="sum">Summary of regular-expression constructs</a></h3> 
     <table border="0" cellpadding="1" cellspacing="0" summary="Regular expression constructs, and what they match"> 
      <tbody> 
       <tr align="left"> 
        <th align="left" id="construct">Construct</th> 
        <th align="left" id="matches">Matches</th> 
       </tr> 
       <tr> 
        <th>&nbsp;</th> 
       </tr> 
       <tr align="left"> 
        <th colspan="2" id="characters">Characters</th> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct characters"><i>x</i></td> 
        <td headers="matches">The character <i>x</i></td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct characters"><tt>\\</tt></td> 
        <td headers="matches">The backslash character</td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct characters"><tt>\0</tt><i>n</i></td> 
        <td headers="matches">The character with octal value <tt>0</tt><i>n</i> (0&nbsp;<tt>&lt;=</tt>&nbsp;<i>n</i>&nbsp;<tt>&lt;=</tt>&nbsp;7)</td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct characters"><tt>\0</tt><i>nn</i></td> 
        <td headers="matches">The character with octal value <tt>0</tt><i>nn</i> (0&nbsp;<tt>&lt;=</tt>&nbsp;<i>n</i>&nbsp;<tt>&lt;=</tt>&nbsp;7)</td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct characters"><tt>\0</tt><i>mnn</i></td> 
        <td headers="matches">The character with octal value <tt>0</tt><i>mnn</i> (0&nbsp;<tt>&lt;=</tt>&nbsp;<i>m</i>&nbsp;<tt>&lt;=</tt>&nbsp;3, 0&nbsp;<tt>&lt;=</tt>&nbsp;<i>n</i>&nbsp;<tt>&lt;=</tt>&nbsp;7)</td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct characters"><tt>\x</tt><i>hh</i></td> 
        <td headers="matches">The character with hexadecimal&nbsp;value&nbsp;<tt>0x</tt><i>hh</i></td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct characters"><tt>\u</tt><i>hhhh</i></td> 
        <td headers="matches">The character with hexadecimal&nbsp;value&nbsp;<tt>0x</tt><i>hhhh</i></td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct characters"><tt>\x</tt><i>{h...h}</i></td> 
        <td headers="matches">The character with hexadecimal&nbsp;value&nbsp;<tt>0x</tt><i>h...h</i> (<a href="../../../java/lang/Character.html#MIN_CODE_POINT"><code>Character.MIN_CODE_POINT</code></a> &nbsp;&lt;=&nbsp;<tt>0x</tt><i>h...h</i>&nbsp;&lt;=&nbsp; <a href="../../../java/lang/Character.html#MAX_CODE_POINT"><code>Character.MAX_CODE_POINT</code></a>)</td> 
       </tr> 
       <tr> 
        <td valign="top" headers="matches"><tt>\t</tt></td> 
        <td headers="matches">The tab character (<tt>'\u0009'</tt>)</td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct characters"><tt>\n</tt></td> 
        <td headers="matches">The newline (line feed) character (<tt>'\u000A'</tt>)</td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct characters"><tt>\r</tt></td> 
        <td headers="matches">The carriage-return character (<tt>'\u000D'</tt>)</td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct characters"><tt>\f</tt></td> 
        <td headers="matches">The form-feed character (<tt>'\u000C'</tt>)</td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct characters"><tt>\a</tt></td> 
        <td headers="matches">The alert (bell) character (<tt>'\u0007'</tt>)</td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct characters"><tt>\e</tt></td> 
        <td headers="matches">The escape character (<tt>'\u001B'</tt>)</td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct characters"><tt>\c</tt><i>x</i></td> 
        <td headers="matches">The control character corresponding to <i>x</i></td> 
       </tr> 
       <tr> 
        <th>&nbsp;</th> 
       </tr> 
       <tr align="left"> 
        <th colspan="2" id="classes">Character classes</th> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct classes"><code>[abc]</code></td> 
        <td headers="matches"><code>a</code>, <code>b</code>, or <code>c</code> (simple class)</td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct classes"><code>[^abc]</code></td> 
        <td headers="matches">Any character except <code>a</code>, <code>b</code>, or <code>c</code> (negation)</td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct classes"><code>[a-zA-Z]</code></td> 
        <td headers="matches"><code>a</code> through <code>z</code> or <code>A</code> through <code>Z</code>, inclusive (range)</td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct classes"><code>[a-d[m-p]]</code></td> 
        <td headers="matches"><code>a</code> through <code>d</code>, or <code>m</code> through <code>p</code>: <code>[a-dm-p]</code> (union)</td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct classes"><code>[a-z&amp;&amp;[def]]</code></td> 
        <td headers="matches"><code>d</code>, <code>e</code>, or <code>f</code> (intersection)</td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct classes"><code>[a-z&amp;&amp;[^bc]]</code></td> 
        <td headers="matches"><code>a</code> through <code>z</code>, except for <code>b</code> and <code>c</code>: <code>[ad-z]</code> (subtraction)</td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct classes"><code>[a-z&amp;&amp;[^m-p]]</code></td> 
        <td headers="matches"><code>a</code> through <code>z</code>, and not <code>m</code> through <code>p</code>: <code>[a-lq-z]</code>(subtraction)</td> 
       </tr> 
       <tr> 
        <th>&nbsp;</th> 
       </tr> 
       <tr align="left"> 
        <th colspan="2" id="predef">Predefined character classes</th> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct predef"><tt>.</tt></td> 
        <td headers="matches">Any character (may or may not match <a href="#lt">line terminators</a>)</td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct predef"><tt>\d</tt></td> 
        <td headers="matches">A digit: <tt>[0-9]</tt></td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct predef"><tt>\D</tt></td> 
        <td headers="matches">A non-digit: <tt>[^0-9]</tt></td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct predef"><tt>\h</tt></td> 
        <td headers="matches">A horizontal whitespace character: <tt>[ \t\xA0\u1680\u180e\u2000-\u200a\u202f\u205f\u3000]</tt></td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct predef"><tt>\H</tt></td> 
        <td headers="matches">A non-horizontal whitespace character: <tt>[^\h]</tt></td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct predef"><tt>\s</tt></td> 
        <td headers="matches">A whitespace character: <tt>[ \t\n\x0B\f\r]</tt></td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct predef"><tt>\S</tt></td> 
        <td headers="matches">A non-whitespace character: <tt>[^\s]</tt></td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct predef"><tt>\v</tt></td> 
        <td headers="matches">A vertical whitespace character: <tt>[\n\x0B\f\r\x85\u2028\u2029]</tt> </td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct predef"><tt>\V</tt></td> 
        <td headers="matches">A non-vertical whitespace character: <tt>[^\v]</tt></td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct predef"><tt>\w</tt></td> 
        <td headers="matches">A word character: <tt>[a-zA-Z_0-9]</tt></td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct predef"><tt>\W</tt></td> 
        <td headers="matches">A non-word character: <tt>[^\w]</tt></td> 
       </tr> 
       <tr> 
        <th>&nbsp;</th> 
       </tr> 
       <tr align="left"> 
        <th colspan="2" id="posix"><b>POSIX character classes (US-ASCII only)</b></th> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct posix"><code>\p{Lower}</code></td> 
        <td headers="matches">A lower-case alphabetic character: <code>[a-z]</code></td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct posix"><code>\p{Upper}</code></td> 
        <td headers="matches">An upper-case alphabetic character:<code>[A-Z]</code></td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct posix"><code>\p{ASCII}</code></td> 
        <td headers="matches">All ASCII:<code>[\x00-\x7F]</code></td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct posix"><code>\p{Alpha}</code></td> 
        <td headers="matches">An alphabetic character:<code>[\p{Lower}\p{Upper}]</code></td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct posix"><code>\p{Digit}</code></td> 
        <td headers="matches">A decimal digit: <code>[0-9]</code></td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct posix"><code>\p{Alnum}</code></td> 
        <td headers="matches">An alphanumeric character:<code>[\p{Alpha}\p{Digit}]</code></td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct posix"><code>\p{Punct}</code></td> 
        <td headers="matches">Punctuation: One of <code>!"#$%&amp;'()*+,-./:;&lt;=&gt;?@[\]^_`{|}~</code></td> 
       </tr> 
       <!-- <code>[\!"#\$%&amp;'\(\)\*\+,\-\./:;\&lt;=\&gt;\?@\[\\\]\^_`\{\|\}~]</code>
          <code>[\X21-\X2F\X31-\X40\X5B-\X60\X7B-\X7E]</code> --> 
       <tr> 
        <td valign="top" headers="construct posix"><code>\p{Graph}</code></td> 
        <td headers="matches">A visible character: <code>[\p{Alnum}\p{Punct}]</code></td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct posix"><code>\p{Print}</code></td> 
        <td headers="matches">A printable character: <code>[\p{Graph}\x20]</code></td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct posix"><code>\p{Blank}</code></td> 
        <td headers="matches">A space or a tab: <code>[ \t]</code></td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct posix"><code>\p{Cntrl}</code></td> 
        <td headers="matches">A control character: <code>[\x00-\x1F\x7F]</code></td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct posix"><code>\p{XDigit}</code></td> 
        <td headers="matches">A hexadecimal digit: <code>[0-9a-fA-F]</code></td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct posix"><code>\p{Space}</code></td> 
        <td headers="matches">A whitespace character: <code>[ \t\n\x0B\f\r]</code></td> 
       </tr> 
       <tr> 
        <th>&nbsp;</th> 
       </tr> 
       <tr align="left"> 
        <th colspan="2">java.lang.Character classes (simple <a href="#jcc">java character type</a>)</th> 
       </tr> 
       <tr> 
        <td valign="top"><tt>\p{javaLowerCase}</tt></td> 
        <td>Equivalent to java.lang.Character.isLowerCase()</td> 
       </tr> 
       <tr> 
        <td valign="top"><tt>\p{javaUpperCase}</tt></td> 
        <td>Equivalent to java.lang.Character.isUpperCase()</td> 
       </tr> 
       <tr> 
        <td valign="top"><tt>\p{javaWhitespace}</tt></td> 
        <td>Equivalent to java.lang.Character.isWhitespace()</td> 
       </tr> 
       <tr> 
        <td valign="top"><tt>\p{javaMirrored}</tt></td> 
        <td>Equivalent to java.lang.Character.isMirrored()</td> 
       </tr> 
       <tr> 
        <th>&nbsp;</th> 
       </tr> 
       <tr align="left"> 
        <th colspan="2" id="unicode">Classes for Unicode scripts, blocks, categories and binary properties</th> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct unicode"><code>\p{IsLatin}</code></td> 
        <td headers="matches">A Latin&nbsp;script character (<a href="#usc">script</a>)</td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct unicode"><code>\p{InGreek}</code></td> 
        <td headers="matches">A character in the Greek&nbsp;block (<a href="#ubc">block</a>)</td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct unicode"><code>\p{Lu}</code></td> 
        <td headers="matches">An uppercase letter (<a href="#ucc">category</a>)</td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct unicode"><code>\p{IsAlphabetic}</code></td> 
        <td headers="matches">An alphabetic character (<a href="#ubpc">binary property</a>)</td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct unicode"><code>\p{Sc}</code></td> 
        <td headers="matches">A currency symbol</td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct unicode"><code>\P{InGreek}</code></td> 
        <td headers="matches">Any character except one in the Greek block (negation)</td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct unicode"><code>[\p{L}&amp;&amp;[^\p{Lu}]]</code></td> 
        <td headers="matches">Any letter except an uppercase letter (subtraction)</td> 
       </tr> 
       <tr> 
        <th>&nbsp;</th> 
       </tr> 
       <tr align="left"> 
        <th colspan="2" id="bounds">Boundary matchers</th> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct bounds"><tt>^</tt></td> 
        <td headers="matches">The beginning of a line</td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct bounds"><tt>$</tt></td> 
        <td headers="matches">The end of a line</td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct bounds"><tt>\b</tt></td> 
        <td headers="matches">A word boundary</td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct bounds"><tt>\B</tt></td> 
        <td headers="matches">A non-word boundary</td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct bounds"><tt>\A</tt></td> 
        <td headers="matches">The beginning of the input</td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct bounds"><tt>\G</tt></td> 
        <td headers="matches">The end of the previous match</td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct bounds"><tt>\Z</tt></td> 
        <td headers="matches">The end of the input but for the final <a href="#lt">terminator</a>, if&nbsp;any</td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct bounds"><tt>\z</tt></td> 
        <td headers="matches">The end of the input</td> 
       </tr> 
       <tr> 
        <th>&nbsp;</th> 
       </tr> 
       <tr align="left"> 
        <th colspan="2" id="lineending">Linebreak matcher</th> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct lineending"><tt>\R</tt></td> 
        <td headers="matches">Any Unicode linebreak sequence, is equivalent to <tt>\u000D\u000A|[\u000A\u000B\u000C\u000D\u0085\u2028\u2029] </tt></td> 
       </tr> 
       <tr> 
        <th>&nbsp;</th> 
       </tr> 
       <tr align="left"> 
        <th colspan="2" id="greedy">Greedy quantifiers</th> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct greedy"><i>X</i><tt>?</tt></td> 
        <td headers="matches"><i>X</i>, once or not at all</td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct greedy"><i>X</i><tt>*</tt></td> 
        <td headers="matches"><i>X</i>, zero or more times</td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct greedy"><i>X</i><tt>+</tt></td> 
        <td headers="matches"><i>X</i>, one or more times</td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct greedy"><i>X</i><tt>{</tt><i>n</i><tt>}</tt></td> 
        <td headers="matches"><i>X</i>, exactly <i>n</i> times</td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct greedy"><i>X</i><tt>{</tt><i>n</i><tt>,}</tt></td> 
        <td headers="matches"><i>X</i>, at least <i>n</i> times</td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct greedy"><i>X</i><tt>{</tt><i>n</i><tt>,</tt><i>m</i><tt>}</tt></td> 
        <td headers="matches"><i>X</i>, at least <i>n</i> but not more than <i>m</i> times</td> 
       </tr> 
       <tr> 
        <th>&nbsp;</th> 
       </tr> 
       <tr align="left"> 
        <th colspan="2" id="reluc">Reluctant quantifiers</th> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct reluc"><i>X</i><tt>??</tt></td> 
        <td headers="matches"><i>X</i>, once or not at all</td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct reluc"><i>X</i><tt>*?</tt></td> 
        <td headers="matches"><i>X</i>, zero or more times</td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct reluc"><i>X</i><tt>+?</tt></td> 
        <td headers="matches"><i>X</i>, one or more times</td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct reluc"><i>X</i><tt>{</tt><i>n</i><tt>}?</tt></td> 
        <td headers="matches"><i>X</i>, exactly <i>n</i> times</td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct reluc"><i>X</i><tt>{</tt><i>n</i><tt>,}?</tt></td> 
        <td headers="matches"><i>X</i>, at least <i>n</i> times</td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct reluc"><i>X</i><tt>{</tt><i>n</i><tt>,</tt><i>m</i><tt>}?</tt></td> 
        <td headers="matches"><i>X</i>, at least <i>n</i> but not more than <i>m</i> times</td> 
       </tr> 
       <tr> 
        <th>&nbsp;</th> 
       </tr> 
       <tr align="left"> 
        <th colspan="2" id="poss">Possessive quantifiers</th> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct poss"><i>X</i><tt>?+</tt></td> 
        <td headers="matches"><i>X</i>, once or not at all</td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct poss"><i>X</i><tt>*+</tt></td> 
        <td headers="matches"><i>X</i>, zero or more times</td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct poss"><i>X</i><tt>++</tt></td> 
        <td headers="matches"><i>X</i>, one or more times</td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct poss"><i>X</i><tt>{</tt><i>n</i><tt>}+</tt></td> 
        <td headers="matches"><i>X</i>, exactly <i>n</i> times</td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct poss"><i>X</i><tt>{</tt><i>n</i><tt>,}+</tt></td> 
        <td headers="matches"><i>X</i>, at least <i>n</i> times</td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct poss"><i>X</i><tt>{</tt><i>n</i><tt>,</tt><i>m</i><tt>}+</tt></td> 
        <td headers="matches"><i>X</i>, at least <i>n</i> but not more than <i>m</i> times</td> 
       </tr> 
       <tr> 
        <th>&nbsp;</th> 
       </tr> 
       <tr align="left"> 
        <th colspan="2" id="logical">Logical operators</th> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct logical"><i>XY</i></td> 
        <td headers="matches"><i>X</i> followed by <i>Y</i></td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct logical"><i>X</i><tt>|</tt><i>Y</i></td> 
        <td headers="matches">Either <i>X</i> or <i>Y</i></td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct logical"><tt>(</tt><i>X</i><tt>)</tt></td> 
        <td headers="matches">X, as a <a href="#cg">capturing group</a></td> 
       </tr> 
       <tr> 
        <th>&nbsp;</th> 
       </tr> 
       <tr align="left"> 
        <th colspan="2" id="backref">Back references</th> 
       </tr> 
       <tr> 
        <td valign="bottom" headers="construct backref"><tt>\</tt><i>n</i></td> 
        <td valign="bottom" headers="matches">Whatever the <i>n</i><sup>th</sup> <a href="#cg">capturing group</a> matched</td> 
       </tr> 
       <tr> 
        <td valign="bottom" headers="construct backref"><tt>\</tt><i>k</i>&lt;<i>name</i>&gt;</td> 
        <td valign="bottom" headers="matches">Whatever the <a href="#groupname">named-capturing group</a> "name" matched</td> 
       </tr> 
       <tr> 
        <th>&nbsp;</th> 
       </tr> 
       <tr align="left"> 
        <th colspan="2" id="quot">Quotation</th> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct quot"><tt>\</tt></td> 
        <td headers="matches">Nothing, but quotes the following character</td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct quot"><tt>\Q</tt></td> 
        <td headers="matches">Nothing, but quotes all characters until <tt>\E</tt></td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct quot"><tt>\E</tt></td> 
        <td headers="matches">Nothing, but ends quoting started by <tt>\Q</tt></td> 
       </tr> 
       <!-- Metachars: !$()*+.<>?[\]^{|} --> 
       <tr> 
        <th>&nbsp;</th> 
       </tr> 
       <tr align="left"> 
        <th colspan="2" id="special">Special constructs (named-capturing and non-capturing)</th> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct special"><tt>(?&lt;<a href="#groupname">name</a>&gt;</tt><i>X</i><tt>)</tt></td> 
        <td headers="matches"><i>X</i>, as a named-capturing group</td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct special"><tt>(?:</tt><i>X</i><tt>)</tt></td> 
        <td headers="matches"><i>X</i>, as a non-capturing group</td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct special"><tt>(?idmsuxU-idmsuxU)&nbsp;</tt></td> 
        <td headers="matches">Nothing, but turns match flags <a href="#CASE_INSENSITIVE">i</a> <a href="#UNIX_LINES">d</a> <a href="#MULTILINE">m</a> <a href="#DOTALL">s</a> <a href="#UNICODE_CASE">u</a> <a href="#COMMENTS">x</a> <a href="#UNICODE_CHARACTER_CLASS">U</a> on - off</td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct special"><tt>(?idmsux-idmsux:</tt><i>X</i><tt>)</tt>&nbsp;&nbsp;</td> 
        <td headers="matches"><i>X</i>, as a <a href="#cg">non-capturing group</a> with the given flags <a href="#CASE_INSENSITIVE">i</a> <a href="#UNIX_LINES">d</a> <a href="#MULTILINE">m</a> <a href="#DOTALL">s</a> <a href="#UNICODE_CASE">u</a> <a href="#COMMENTS">x</a> on - off</td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct special"><tt>(?=</tt><i>X</i><tt>)</tt></td> 
        <td headers="matches"><i>X</i>, via zero-width positive lookahead</td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct special"><tt>(?!</tt><i>X</i><tt>)</tt></td> 
        <td headers="matches"><i>X</i>, via zero-width negative lookahead</td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct special"><tt>(?&lt;=</tt><i>X</i><tt>)</tt></td> 
        <td headers="matches"><i>X</i>, via zero-width positive lookbehind</td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct special"><tt>(?&lt;!</tt><i>X</i><tt>)</tt></td> 
        <td headers="matches"><i>X</i>, via zero-width negative lookbehind</td> 
       </tr> 
       <tr> 
        <td valign="top" headers="construct special"><tt>(?&gt;</tt><i>X</i><tt>)</tt></td> 
        <td headers="matches"><i>X</i>, as an independent, non-capturing group</td> 
       </tr> 
      </tbody> 
     </table> 
     <hr data-fanyi="1"> 
     <h3 data-fanyi="1"><a name="bs">Backslashes, escapes, and quoting</a></h3> 
     <p data-fanyi="1">反斜杠字符（<tt>'\'</tt>）用来介绍了构造，如上表中定义，以及引号字符，否则会被解释为转义构建。因此，表达<tt>\\</tt>匹配一个反斜杠和<tt>\{</tt>匹配左括号。</p> 
     <p data-fanyi="1">它是用一个反斜杠的任何字母，并不表示转义构建之前的错误；这些都是留给未来的扩展正则表达式语言。一个可用于非字母字符之前，无论该字符转义构建的一部分。</p> 
     <p data-fanyi="1">在java源代码中的字符串会被解释为要求的<cite>The Java™ Language Specification</cite>为Unicode转义（第3.3节）或其他字符转义（第3.10.6）因此有必要在字符串表示正则表达式的java字节码编译器保护他们免受解释双反斜杠。例如，字符串<tt>"\b"</tt>，匹配的单退格字符时解释为正则表达式，而<tt>"\\b"</tt>匹配一个单词边界。字符串字面值<tt>"\(hello\)"</tt>是非法的，导致一个编译时错误；为了匹配字符串<tt>(hello)</tt>字符串<tt>"\\(hello\\)"</tt>必须使用。</p> 
     <h3 data-fanyi="1"><a name="cc">Character Classes</a></h3> 
     <p data-fanyi="1">字符类可能出现在其他角色，并且可以由UNION运算符（隐式）和交叉算子（<tt>&amp;&amp;</tt>）。该工会操作符表示一个类，该类包含在其操作数类中的至少一个的每个字符。交集操作符表示一个类，它包含在它的两个操作数类中的每一个字符。</p> 
     <p data-fanyi="1">字符类操作符的优先级如下，从最高到最低：</p> 
     <blockquote> 
      <table border="0" cellpadding="1" cellspacing="0" summary="Precedence of character class operators."> 
       <tbody> 
        <tr> 
         <th>1&nbsp;&nbsp;&nbsp;&nbsp;</th> 
         <td>Literal escape&nbsp;&nbsp;&nbsp;&nbsp;</td> 
         <td><tt>\x</tt></td> 
        </tr> 
        <tr> 
         <th>2&nbsp;&nbsp;&nbsp;&nbsp;</th> 
         <td>Grouping</td> 
         <td><tt>[...]</tt></td> 
        </tr> 
        <tr> 
         <th>3&nbsp;&nbsp;&nbsp;&nbsp;</th> 
         <td>Range</td> 
         <td><tt>a-z</tt></td> 
        </tr> 
        <tr> 
         <th>4&nbsp;&nbsp;&nbsp;&nbsp;</th> 
         <td>Union</td> 
         <td><tt>[a-e][i-u]</tt></td> 
        </tr> 
        <tr> 
         <th>5&nbsp;&nbsp;&nbsp;&nbsp;</th> 
         <td>Intersection</td> 
         <td><code>[a-z&amp;&amp;[aeiou]]</code></td> 
        </tr> 
       </tbody> 
      </table> 
     </blockquote> 
     <p data-fanyi="1">值得注意的是，不同的元字符在字符类中的作用比一个字符类外。例如，正则表达式<tt>.</tt>失去其在字符类中的特殊含义，而表达<tt>-</tt>成为范围形成的元字符。</p> 
     <h3 data-fanyi="1"><a name="lt">Line terminators</a></h3> 
     <p data-fanyi="1">一个行结束符一一或两个字符序列，标志着一行输入字符序列结束。以下是公认的行终止符：</p> 
     <ul data-fanyi="1"> 
      <li data-fanyi="1">一个换行符（换行）字符&nbsp;（<tt>'\n'</tt>），</li> 
      <li data-fanyi="1">回车字符后面紧跟一个换行符&nbsp;（<tt>"\r\n"</tt>），</li> 
      <li data-fanyi="1">一个独立的回车符&nbsp;（<tt>'\r'</tt>），</li> 
      <li data-fanyi="1">下一行字符&nbsp;（<tt>'\u0085'</tt>），</li> 
      <li data-fanyi="1">行分隔符&nbsp;（<tt>'\u2028'</tt>），或</li> 
      <li data-fanyi="1">一个段落分隔符&nbsp;（<tt>'\u2029</tt>）。</li> 
     </ul> 
     <p data-fanyi="1">如果<a href="../../../java/util/regex/Pattern.html#UNIX_LINES"><code>UNIX_LINES</code></a>模式被激活，那么唯一的行终止符识别换行符。</p> 
     <p data-fanyi="1">正则表达式匹配任何字符<tt>.</tt>除了行结束符除非<a href="../../../java/util/regex/Pattern.html#DOTALL"><code>DOTALL</code></a>标志指定。</p> 
     <p data-fanyi="1">默认情况下，正则表达式<tt>^</tt>和<tt>$</tt>忽略线的终结者，只有比赛开始和结束时，分别对整个输入序列。如果<a href="../../../java/util/regex/Pattern.html#MULTILINE"><code>MULTILINE</code></a>模式被激活，然后在输入<tt>^</tt>比赛开始和任何线路终端除了在输入结束后。当<a href="../../../java/util/regex/Pattern.html#MULTILINE"><code>MULTILINE</code></a>模式<tt>$</tt>比赛之前的行结束符或输入序列的末端。</p> 
     <h3 data-fanyi="1"><a name="cg">Groups and capturing</a></h3> 
     <h4 data-fanyi="1"><a name="gnumber">Group number</a></h4> 
     <p data-fanyi="1">捕获组通过数从左到右的开口括号计数编号。在表达<tt>((A)(B(C)))</tt>，例如，有四个这样的团体：</p> 
     <blockquote> 
      <table cellpadding="1" cellspacing="0" summary="Capturing group numberings"> 
       <tbody> 
        <tr> 
         <th>1&nbsp;&nbsp;&nbsp;&nbsp;</th> 
         <td><tt>((A)(B(C)))</tt></td> 
        </tr> 
        <tr> 
         <th>2&nbsp;&nbsp;&nbsp;&nbsp;</th> 
         <td><tt>(A)</tt></td> 
        </tr> 
        <tr> 
         <th>3&nbsp;&nbsp;&nbsp;&nbsp;</th> 
         <td><tt>(B(C))</tt></td> 
        </tr> 
        <tr> 
         <th>4&nbsp;&nbsp;&nbsp;&nbsp;</th> 
         <td><tt>(C)</tt></td> 
        </tr> 
       </tbody> 
      </table> 
     </blockquote> 
     <p data-fanyi="1">零组总是代表整个表达。</p> 
     <p data-fanyi="1">捕获组的得名是因为，在一场比赛中，保存每个子序列匹配一组输入序列。捕获的序列可能在表达后，通过后面的参考，也可以从匹配一旦匹配操作完成检索。</p> 
     <h4 data-fanyi="1"><a name="groupname">Group name</a></h4> 
     <p data-fanyi="1">一个捕获组也可以被分配一个“名字”，一个<tt>named-capturing group</tt>，然后回来以后被引用的“名字”。组名是由以下字符组成的。第一个字符必须是一个<tt>letter</tt>。</p> 
     <ul data-fanyi="1"> 
      <li data-fanyi="1">大写字母<tt>'A'</tt>通过<tt>'Z'</tt>（<tt>'\u0041'</tt>&nbsp;通过&nbsp;<tt>'\u005a'</tt>），</li> 
      <li data-fanyi="1">小写字母<tt>'a'</tt>通过<tt>'z'</tt>（<tt>'\u0061'</tt>&nbsp;通过&nbsp;<tt>'\u007a'</tt>），</li> 
      <li data-fanyi="1">数字<tt>'0'</tt>通过<tt>'9'</tt>（<tt>'\u0030'</tt>&nbsp;通过&nbsp;<tt>'\u0039'</tt>），</li> 
     </ul> 
     <p data-fanyi="1">一个<tt>named-capturing group</tt>仍如<a href="#gnumber">Group number</a>编号。</p> 
     <p data-fanyi="1">捕获的输入与一组相关联的总序列，集团最近匹配。如果一个组被评估第二次，因为量化，那么它以前捕获的值，如果有的话，将被保留，如果第二次评估失败。例如匹配字符串<tt>"aba"</tt>对表达<tt>(a(b)?)+</tt>，叶组，两个<tt>"b"</tt>。在每一个匹配的开始，所有捕获的输入被丢弃。</p> 
     <p data-fanyi="1">组开始<tt>(?</tt>要么是纯洁的，非捕获组不捕获文本和不计入组总，或命名捕获组。</p> 
     <h3 data-fanyi="1">Unicode支持</h3> 
     <p data-fanyi="1">这个类是与<a href="http://www.unicode.org/reports/tr18/"><i>Unicode Technical Standard #18: Unicode Regular Expression</i></a> 1水平的一致性，加上rl2.1正则等价物。</p> 
     <p data-fanyi="1"><b data-fanyi="1">Unicode转义序列</b>如java源代码<tt>\u2014</tt>是在<cite>The Java™ Language Specification</cite> 3.3节中描述的处理。这样的转义序列也由正则表达式解析器直接实现，可以使用Unicode转义表达，在读取文件或从键盘。因此<tt>"\u2014"</tt>和<tt>"\\u2014"</tt>字符串，而不是平等的，编译成相同的图案，用十六进制值<tt>0x2014</tt>的字符匹配。</p> 
     <p data-fanyi="1">一个Unicode字符也可以使用正则表达式来表示<b data-fanyi="1">进制记数法</b>（十六进制代码值）直接描述构建<tt>\x{...}</tt>，例如补充字符u +分类可以被指定为<tt>\x{2011F}</tt>，而连续两Unicode转义序列的代理项对<tt>\uD840</tt><tt>\uDD1F</tt>。</p> 
     <p data-fanyi="1">Unicode脚本块，类别和二进制属性是用<tt>\p</tt>和<tt>\P</tt>作为Perl。<tt>\p{</tt>道具<tt>}</tt>比赛如果输入具有财产道具，而<tt>\P{</tt>道具<tt>}</tt>不匹配，如果输入特性。</p> 
     <p data-fanyi="1">脚本，块，类别和二进制属性可以在一个字符类的内部和外部使用。</p> 
     <p data-fanyi="1"><b data-fanyi="1"><a name="usc">Scripts</a></b>指定的前缀<code>Is</code>，在<code>IsHiragana</code>，或通过使用<code>script</code>关键词（或其缩写形式<code>sc</code>）在<code>script=Hiragana</code>或<code>sc=Hiragana</code>。</p> z-04e9b33c-0b41—4eac-b456-734d8d427889 
     <p data-fanyi="1"><b data-fanyi="1"><a name="ubc">Blocks</a></b>与<code>In</code>指定前缀，如<code>InMongolian</code>，或者使用关键字<code>block</code>（或其缩写形式<code>blk</code>）在<code>block=Mongolian</code>或<code>blk=Mongolian</code>。</p> 
     <p data-fanyi="1">支持<code>Pattern</code>块的名字是有效的块名接受和定义的<a href="../../../java/lang/Character.UnicodeBlock.html#forName-java.lang.String-"><code>UnicodeBlock.forName</code></a>。</p> 
     <p data-fanyi="1"><b data-fanyi="1"><a name="ucc">Categories</a></b>可以与可选的前缀<code>Is</code>指定：两<code>\p{L}</code>和<code>\p{IsL}</code>表示Unicode字符的范畴。相同的脚本块，类也可以使用关键字<code>general_category</code>指定（或其缩写形式<code>gc</code>）在<code>general_category=Lu</code>或<code>gc=Lu</code>。</p> 
     <p data-fanyi="1">支持的类别是由<a href="../../../java/lang/Character.html" title="class in java.lang"><code>Character</code></a>类指定的版本<a href="http://www.unicode.org/unicode/standard/standard.html"> <i>The Unicode Standard</i></a>那些。类别名称是标准中定义的，规范性和信息性的。</p> 
     <p data-fanyi="1"><b data-fanyi="1"><a name="ubpc">Binary properties</a></b>与<code>Is</code>指定前缀，如<code>IsAlphabetic</code>。支持二进制属性<code>Pattern</code>是</p> 
     <ul data-fanyi="1"> 
      <li data-fanyi="1">字母</li> 
      <li data-fanyi="1">表意</li> 
      <li data-fanyi="1">信</li> 
      <li data-fanyi="1">小写字母</li> 
      <li data-fanyi="1">大写字母</li> 
      <li data-fanyi="1">titlecase</li> 
      <li data-fanyi="1">标点符号</li> 
      <li data-fanyi="1">控制</li> 
      <li data-fanyi="1">white_space</li> 
      <li data-fanyi="1">数字</li> 
      <li data-fanyi="1">hex_digit</li> 
      <li data-fanyi="1">join_control</li> 
      <li data-fanyi="1">noncharacter_code_point</li> 
      <li data-fanyi="1">分配</li> 
     </ul> 
     <p data-fanyi="1">以下<b data-fanyi="1">预定义字符类</b>和<b data-fanyi="1">POSIX字符类</b>是与附件C推荐的一致性：兼容性属性<a href="http://www.unicode.org/reports/tr18/"><i>Unicode Regular Expression </i></a>，当<a href="../../../java/util/regex/Pattern.html#UNICODE_CHARACTER_CLASS"><code>UNICODE_CHARACTER_CLASS</code></a>标志指定。</p> 
     <table border="0" cellpadding="1" cellspacing="0" summary="predefined and posix character classes in Unicode mode"> 
      <tbody> 
       <tr align="left"> 
        <th align="left" id="predef_classes">Classes</th> 
        <th align="left" id="predef_matches">Matches</th> 
       </tr> 
       <tr> 
        <td><tt>\p{Lower}</tt></td> 
        <td>A lowercase character:<tt>\p{IsLowercase}</tt></td> 
       </tr> 
       <tr> 
        <td><tt>\p{Upper}</tt></td> 
        <td>An uppercase character:<tt>\p{IsUppercase}</tt></td> 
       </tr> 
       <tr> 
        <td><tt>\p{ASCII}</tt></td> 
        <td>All ASCII:<tt>[\x00-\x7F]</tt></td> 
       </tr> 
       <tr> 
        <td><tt>\p{Alpha}</tt></td> 
        <td>An alphabetic character:<tt>\p{IsAlphabetic}</tt></td> 
       </tr> 
       <tr> 
        <td><tt>\p{Digit}</tt></td> 
        <td>A decimal digit character:<tt>p{IsDigit}</tt></td> 
       </tr> 
       <tr> 
        <td><tt>\p{Alnum}</tt></td> 
        <td>An alphanumeric character:<tt>[\p{IsAlphabetic}\p{IsDigit}]</tt></td> 
       </tr> 
       <tr> 
        <td><tt>\p{Punct}</tt></td> 
        <td>A punctuation character:<tt>p{IsPunctuation}</tt></td> 
       </tr> 
       <tr> 
        <td><tt>\p{Graph}</tt></td> 
        <td>A visible character: <tt>[^\p{IsWhite_Space}\p{gc=Cc}\p{gc=Cs}\p{gc=Cn}]</tt></td> 
       </tr> 
       <tr> 
        <td><tt>\p{Print}</tt></td> 
        <td>A printable character: <code>[\p{Graph}\p{Blank}&amp;&amp;[^\p{Cntrl}]]</code></td> 
       </tr> 
       <tr> 
        <td><tt>\p{Blank}</tt></td> 
        <td>A space or a tab: <code>[\p{IsWhite_Space}&amp;&amp;[^\p{gc=Zl}\p{gc=Zp}\x0a\x0b\x0c\x0d\x85]]</code></td> 
       </tr> 
       <tr> 
        <td><tt>\p{Cntrl}</tt></td> 
        <td>A control character: <tt>\p{gc=Cc}</tt></td> 
       </tr> 
       <tr> 
        <td><tt>\p{XDigit}</tt></td> 
        <td>A hexadecimal digit: <tt>[\p{gc=Nd}\p{IsHex_Digit}]</tt></td> 
       </tr> 
       <tr> 
        <td><tt>\p{Space}</tt></td> 
        <td>A whitespace character:<tt>\p{IsWhite_Space}</tt></td> 
       </tr> 
       <tr> 
        <td><tt>\d</tt></td> 
        <td>A digit: <tt>\p{IsDigit}</tt></td> 
       </tr> 
       <tr> 
        <td><tt>\D</tt></td> 
        <td>A non-digit: <tt>[^\d]</tt></td> 
       </tr> 
       <tr> 
        <td><tt>\s</tt></td> 
        <td>A whitespace character: <tt>\p{IsWhite_Space}</tt></td> 
       </tr> 
       <tr> 
        <td><tt>\S</tt></td> 
        <td>A non-whitespace character: <tt>[^\s]</tt></td> 
       </tr> 
       <tr> 
        <td><tt>\w</tt></td> 
        <td>A word character: <tt>[\p{Alpha}\p{gc=Mn}\p{gc=Me}\p{gc=Mc}\p{Digit}\p{gc=Pc}\p{IsJoin_Control}]</tt></td> 
       </tr> 
       <tr> 
        <td><tt>\W</tt></td> 
        <td>A non-word character: <tt>[^\w]</tt></td> 
       </tr> 
      </tbody> 
     </table> 
     <p data-fanyi="1"><a name="jcc"> Categories that behave like the java.lang.Character boolean is<i>methodname</i> methods (except for the deprecated ones) are available through the same <tt>\p{</tt><i>prop</i><tt>}</tt> syntax where the specified property has the name <tt>java<i>methodname</i></tt></a>。</p> 
     <h3 data-fanyi="1">Perl 5的比较</h3> 
     <p data-fanyi="1">的<code>Pattern</code>引擎执行传统的基于NFA的有序交替发生在Perl 5匹配。</p> 
     <p data-fanyi="1">Perl构建这类不支持：</p> 
     <ul data-fanyi="1"> 
      <li data-fanyi="1"><p data-fanyi="1">预定义字符类（Unicode字符）</p><p data-fanyi="1"><tt>\X&nbsp;&nbsp;&nbsp;&nbsp;</tt>match Unicode <a href="http://www.unicode.org/reports/tr18/#Default_Grapheme_Clusters"> <i>extended grapheme cluster</i></a></p></li> 
      <li data-fanyi="1"><p data-fanyi="1">后向引用的结构，为<a href="#groupname">named-capturing group</a>为n<sup data-fanyi="1">TH</sup><a href="#cg">capturing group</a>和<tt>\g{</tt>名称<tt>}</tt> <tt>\g{</tt>n<tt>}</tt>。</p></li> 
      <li data-fanyi="1"><p data-fanyi="1">指定的字符构成，<tt>\N{</tt>名称<tt>}</tt> Unicode字符的名称。</p></li> 
      <li data-fanyi="1"><p data-fanyi="1">有条件的构建<tt>(?(</tt>条件<tt>)</tt>x<tt>)</tt>和<tt>(?(</tt>条件<tt>)</tt>x<tt>|</tt>y<tt>)</tt>，</p></li> 
      <li data-fanyi="1"><p data-fanyi="1">嵌入式代码构造<tt>(?{</tt>代码<tt>})</tt>和<tt>(??{</tt>代码<tt>})</tt>，</p></li> 
      <li data-fanyi="1"><p data-fanyi="1">嵌入的注释语法<tt>(?#comment)</tt>，和</p></li> 
      <li data-fanyi="1"><p data-fanyi="1">预处理操作<tt>\l</tt> <tt>\u</tt>，<tt>\L</tt>，和<tt>\U</tt>。</p></li> 
     </ul> 
     <p data-fanyi="1">构建了由这类支持而不是由Perl：</p> 
     <ul data-fanyi="1"> 
      <li data-fanyi="1"><p data-fanyi="1">字符类的交集和并集的描述<a href="#cc">above</a>。</p></li> 
     </ul> 
     <p data-fanyi="1">从Perl差异显著：</p> 
     <ul data-fanyi="1"> 
      <li data-fanyi="1"><p data-fanyi="1">在Perl，<tt>\1</tt>通过<tt>\9</tt>总是解释为后向引用；一个反斜杠转移数大于<tt>9</tt>是为后面的参考如果至少存在许多的子表达式处理，否则就解释，如果可能的话，作为一个八进制逃逸。在这类八进制转义必须以一零开头。这节课，<tt>\1</tt>通过<tt>\9</tt>总是解释为反向引用，且数量较大的是后面的参考如果至少存在许多的子表达式在正则表达式解析器接受，否则将下降数字直到数小于或等于群体的存在或是一个数字。</p></li> 
      <li data-fanyi="1"><p data-fanyi="1">Perl采用<tt>g</tt>旗要求匹配，简历在最后一场比赛中离开。这个功能是由<a href="../../../java/util/regex/Matcher.html" title="class in java.util.regex"><code>Matcher</code></a>类隐式调用的方法：重复<a href="../../../java/util/regex/Matcher.html#find--"><code>find</code></a>将在最后一场比赛留下简历，除非匹配器复位。</p></li> 
      <li data-fanyi="1"><p data-fanyi="1">在Perl，嵌入式的旗帜在表达式的最高水平影响整个表达。在这门课中，嵌入式的旗帜始终在发生作用，他们出现的点，无论他们是在顶层或在一组；在后一种情况下，国旗恢复最后的小组就像Perl。</p></li> 
     </ul> 
     <p data-fanyi="1">一个更精确的正则表达式的行为结构的描述，请参阅<a href="http://www.oreilly.com/catalog/regex3/"> <i>Mastering Regular Expressions, 3nd Edition</i>, Jeffrey E. F. Friedl, O'Reilly and Associates, 2006.</a></p> 
    </div> 
    <dl> 
     <dt> 
      <span class="simpleTagLabel">从以下版本开始：</span> 
     </dt> 
     <dd data-fanyi="1">
       一点四 
     </dd> 
     <dt> 
      <span class="seeLabel">另请参见：</span> 
     </dt> 
     <dd data-fanyi="1"> 
      <a href="../../../java/lang/String.html#split-java.lang.String-int-"><code>String.split(String, int)</code></a>， 
      <a href="../../../java/lang/String.html#split-java.lang.String-"><code>String.split(String)</code></a>， 
      <a href="../../../serialized-form.html#java.util.regex.Pattern">Serialized Form</a> 
     </dd> 
    </dl> </li> 
  </ul> 
 </div> 
 <div class="summary"> 
  <ul class="blockList"> 
   <li class="blockList"> 
    <!-- =========== FIELD SUMMARY =========== --> 
    <ul class="blockList"> 
     <li class="blockList"><a name="field.summary"> 
       <!--   --> </a> <h3>Field Summary</h3> 
      <table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Field Summary table, listing fields, and an explanation"> 
       <caption> 
        <span>Fields</span> 
        <span class="tabEnd">&nbsp;</span> 
       </caption> 
       <tbody> 
        <tr> 
         <th class="colFirst" scope="col">Modifier and Type</th> 
         <th class="colLast" scope="col">Field and Description</th> 
        </tr> 
        <tr class="altColor"> 
         <td class="colFirst"><code>static int</code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/regex/Pattern.html#CANON_EQ">CANON_EQ</a></span></code> 
          <div class="block" data-fanyi="1">
            使正则等价。 
          </div> </td> 
        </tr> 
        <tr class="rowColor"> 
         <td class="colFirst"><code>static int</code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/regex/Pattern.html#CASE_INSENSITIVE">CASE_INSENSITIVE</a></span></code> 
          <div class="block" data-fanyi="1">
            启用不区分大小写匹配。 
          </div> </td> 
        </tr> 
        <tr class="altColor"> 
         <td class="colFirst"><code>static int</code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/regex/Pattern.html#COMMENTS">COMMENTS</a></span></code> 
          <div class="block" data-fanyi="1">
            允许空格和注释模式。 
          </div> </td> 
        </tr> 
        <tr class="rowColor"> 
         <td class="colFirst"><code>static int</code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/regex/Pattern.html#DOTALL">DOTALL</a></span></code> 
          <div class="block" data-fanyi="1">
            使dotall模式。 
          </div> </td> 
        </tr> 
        <tr class="altColor"> 
         <td class="colFirst"><code>static int</code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/regex/Pattern.html#LITERAL">LITERAL</a></span></code> 
          <div class="block" data-fanyi="1">
            启用模式的文本解析。 
          </div> </td> 
        </tr> 
        <tr class="rowColor"> 
         <td class="colFirst"><code>static int</code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/regex/Pattern.html#MULTILINE">MULTILINE</a></span></code> 
          <div class="block" data-fanyi="1">
            使多行模式。 
          </div> </td> 
        </tr> 
        <tr class="altColor"> 
         <td class="colFirst"><code>static int</code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/regex/Pattern.html#UNICODE_CASE">UNICODE_CASE</a></span></code> 
          <div class="block" data-fanyi="1">
            使用Unicode的折盒。 
          </div> </td> 
        </tr> 
        <tr class="rowColor"> 
         <td class="colFirst"><code>static int</code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/regex/Pattern.html#UNICODE_CHARACTER_CLASS">UNICODE_CHARACTER_CLASS</a></span></code> 
          <div class="block" data-fanyi="1">
            使用Unicode版本的预定义字符类别和POSIX字符类。 
          </div> </td> 
        </tr> 
        <tr class="altColor"> 
         <td class="colFirst"><code>static int</code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/regex/Pattern.html#UNIX_LINES">UNIX_LINES</a></span></code> 
          <div class="block" data-fanyi="1">
            使UNIX线模式。 
          </div> </td> 
        </tr> 
       </tbody> 
      </table> </li> 
    </ul> 
    <!-- ========== METHOD SUMMARY =========== --> 
    <ul class="blockList"> 
     <li class="blockList"><a name="method.summary"> 
       <!--   --> </a> <h3>方法摘要</h3> 
      <table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation"> 
       <caption> 
        <span id="t0" class="activeTableTab"><span>所有方法</span><span class="tabEnd">&nbsp;</span></span> 
        <span id="t1" class="tableTab"><span><a href="javascript:show(1);">静态方法</a></span><span class="tabEnd">&nbsp;</span></span> 
        <span id="t2" class="tableTab"><span><a href="javascript:show(2);">接口方法</a></span><span class="tabEnd">&nbsp;</span></span> 
        <span id="t4" class="tableTab"><span><a href="javascript:show(8);">具体的方法</a></span><span class="tabEnd">&nbsp;</span></span> 
       </caption> 
       <tbody> 
        <tr> 
         <th class="colFirst" scope="col">Modifier and Type</th> 
         <th class="colLast" scope="col">Method and Description</th> 
        </tr> 
        <tr id="i0" class="altColor"> 
         <td class="colFirst"><code><a href="../../../java/util/function/Predicate.html" title="interface in java.util.function">Predicate</a>&lt;<a href="../../../java/lang/String.html" title="class in java.lang">String</a>&gt;</code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/regex/Pattern.html#asPredicate--">asPredicate</a></span>()</code> 
          <div class="block" data-fanyi="1">
            创建一个可以用于匹配字符串的谓词。 
          </div> </td> 
        </tr> 
        <tr id="i1" class="rowColor"> 
         <td class="colFirst"><code>static <a href="../../../java/util/regex/Pattern.html" title="class in java.util.regex">Pattern</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/regex/Pattern.html#compile-java.lang.String-">compile</a></span>(<a href="../../../java/lang/String.html" title="class in java.lang">String</a>&nbsp;regex)</code> 
          <div class="block" data-fanyi="1">
            将给定的正则表达式编译成模式。 
          </div> </td> 
        </tr> 
        <tr id="i2" class="altColor"> 
         <td class="colFirst"><code>static <a href="../../../java/util/regex/Pattern.html" title="class in java.util.regex">Pattern</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/regex/Pattern.html#compile-java.lang.String-int-">compile</a></span>(<a href="../../../java/lang/String.html" title="class in java.lang">String</a>&nbsp;regex, int&nbsp;flags)</code> 
          <div class="block" data-fanyi="1">
            用给定的标志将给定的正则表达式编译成一个模式。 
          </div> </td> 
        </tr> 
        <tr id="i3" class="rowColor"> 
         <td class="colFirst"><code>int</code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/regex/Pattern.html#flags--">flags</a></span>()</code> 
          <div class="block" data-fanyi="1">
            返回此模式的匹配标志。 
          </div> </td> 
        </tr> 
        <tr id="i4" class="altColor"> 
         <td class="colFirst"><code><a href="../../../java/util/regex/Matcher.html" title="class in java.util.regex">Matcher</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/regex/Pattern.html#matcher-java.lang.CharSequence-">matcher</a></span>(<a href="../../../java/lang/CharSequence.html" title="interface in java.lang">CharSequence</a>&nbsp;input)</code> 
          <div class="block" data-fanyi="1">
            创建一个匹配，将匹配给定的输入对该模式。 
          </div> </td> 
        </tr> 
        <tr id="i5" class="rowColor"> 
         <td class="colFirst"><code>static boolean</code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/regex/Pattern.html#matches-java.lang.String-java.lang.CharSequence-">matches</a></span>(<a href="../../../java/lang/String.html" title="class in java.lang">String</a>&nbsp;regex, <a href="../../../java/lang/CharSequence.html" title="interface in java.lang">CharSequence</a>&nbsp;input)</code> 
          <div class="block" data-fanyi="1">
            编译给定的正则表达式，并试图匹配给定的输入反对它。 
          </div> </td> 
        </tr> 
        <tr id="i6" class="altColor"> 
         <td class="colFirst"><code><a href="../../../java/lang/String.html" title="class in java.lang">String</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/regex/Pattern.html#pattern--">pattern</a></span>()</code> 
          <div class="block" data-fanyi="1">
            返回此模式被编译的正则表达式。 
          </div> </td> 
        </tr> 
        <tr id="i7" class="rowColor"> 
         <td class="colFirst"><code>static <a href="../../../java/lang/String.html" title="class in java.lang">String</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/regex/Pattern.html#quote-java.lang.String-">quote</a></span>(<a href="../../../java/lang/String.html" title="class in java.lang">String</a>&nbsp;s)</code> 
          <div class="block" data-fanyi="1">
            返回指定 
           <code>String</code>文字模式 
           <code>String</code>。 
          </div> </td> 
        </tr> 
        <tr id="i8" class="altColor"> 
         <td class="colFirst"><code><a href="../../../java/lang/String.html" title="class in java.lang">String</a>[]</code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/regex/Pattern.html#split-java.lang.CharSequence-">split</a></span>(<a href="../../../java/lang/CharSequence.html" title="interface in java.lang">CharSequence</a>&nbsp;input)</code> 
          <div class="block" data-fanyi="1">
            将给定的输入序列拆分为这个模式的匹配。 
          </div> </td> 
        </tr> 
        <tr id="i9" class="rowColor"> 
         <td class="colFirst"><code><a href="../../../java/lang/String.html" title="class in java.lang">String</a>[]</code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/regex/Pattern.html#split-java.lang.CharSequence-int-">split</a></span>(<a href="../../../java/lang/CharSequence.html" title="interface in java.lang">CharSequence</a>&nbsp;input, int&nbsp;limit)</code> 
          <div class="block" data-fanyi="1">
            将给定的输入序列拆分为这个模式的匹配。 
          </div> </td> 
        </tr> 
        <tr id="i10" class="altColor"> 
         <td class="colFirst"><code><a href="../../../java/util/stream/Stream.html" title="interface in java.util.stream">Stream</a>&lt;<a href="../../../java/lang/String.html" title="class in java.lang">String</a>&gt;</code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/regex/Pattern.html#splitAsStream-java.lang.CharSequence-">splitAsStream</a></span>(<a href="../../../java/lang/CharSequence.html" title="interface in java.lang">CharSequence</a>&nbsp;input)</code> 
          <div class="block" data-fanyi="1">
            从给定的输入序列创建一个流，围绕这个模式的匹配。 
          </div> </td> 
        </tr> 
        <tr id="i11" class="rowColor"> 
         <td class="colFirst"><code><a href="../../../java/lang/String.html" title="class in java.lang">String</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/regex/Pattern.html#toString--">toString</a></span>()</code> 
          <div class="block" data-fanyi="1">
            返回此模式的字符串表示形式。 
          </div> </td> 
        </tr> 
       </tbody> 
      </table> 
      <ul class="blockList"> 
       <li class="blockList"><a name="methods.inherited.from.class.java.lang.Object"> 
         <!--   --> </a> <h3>Methods inherited from class&nbsp;java.lang.<a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></h3> <code><a href="../../../java/lang/Object.html#clone--">clone</a>, <a href="../../../java/lang/Object.html#equals-java.lang.Object-">equals</a>, <a href="../../../java/lang/Object.html#finalize--">finalize</a>, <a href="../../../java/lang/Object.html#getClass--">getClass</a>, <a href="../../../java/lang/Object.html#hashCode--">hashCode</a>, <a href="../../../java/lang/Object.html#notify--">notify</a>, <a href="../../../java/lang/Object.html#notifyAll--">notifyAll</a>, <a href="../../../java/lang/Object.html#wait--">wait</a>, <a href="../../../java/lang/Object.html#wait-long-">wait</a>, <a href="../../../java/lang/Object.html#wait-long-int-">wait</a></code></li> 
      </ul> </li> 
    </ul> </li> 
  </ul> 
 </div> 
 <div class="details"> 
  <ul class="blockList"> 
   <li class="blockList"> 
    <!-- ============ FIELD DETAIL =========== --> 
    <ul class="blockList"> 
     <li class="blockList"><a name="field.detail"> 
       <!--   --> </a> <h3>Field Detail</h3> <a name="UNIX_LINES"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>UNIX_LINES</h4> <pre>public static final&nbsp;int UNIX_LINES</pre> 
        <div class="block" data-fanyi="1">
          使UNIX线模式。 
         <p data-fanyi="1">在这种模式下，只有<tt>'\n'</tt>线终止在<tt>.</tt>，<tt>^</tt>行为的认可，并<tt>$</tt>。</p> 
         <p data-fanyi="1">UNIX线模式也可以通过嵌入国旗表达&nbsp;<tt>(?d)</tt>启用。</p> 
        </div> 
        <dl> 
         <dt> 
          <span class="seeLabel">另请参见：</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <a href="../../../constant-values.html#java.util.regex.Pattern.UNIX_LINES">Constant Field Values</a> 
         </dd> 
        </dl> </li> 
      </ul> <a name="CASE_INSENSITIVE"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>CASE_INSENSITIVE</h4> <pre>public static final&nbsp;int CASE_INSENSITIVE</pre> 
        <div class="block" data-fanyi="1">
          启用不区分大小写匹配。 
         <p data-fanyi="1">默认情况下，不区分大小写匹配假设在US-ASCII字符集只有字符匹配。Unicode的不区分大小写匹配可以结合此标志指定<a href="../../../java/util/regex/Pattern.html#UNICODE_CASE"><code>UNICODE_CASE</code></a>标志启用。</p> 
         <p data-fanyi="1">不区分大小写匹配也可以通过嵌入国旗表达&nbsp;<tt>(?i)</tt>启用。</p> 
         <p data-fanyi="1">指定该标志可能会施加轻微的性能损失。</p> 
        </div> 
        <dl> 
         <dt> 
          <span class="seeLabel">另请参见：</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <a href="../../../constant-values.html#java.util.regex.Pattern.CASE_INSENSITIVE">Constant Field Values</a> 
         </dd> 
        </dl> </li> 
      </ul> <a name="COMMENTS"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>COMMENTS</h4> <pre>public static final&nbsp;int COMMENTS</pre> 
        <div class="block" data-fanyi="1">
          允许空格和注释模式。 
         <p data-fanyi="1">在这种模式下，空格被忽略，和嵌入的注释开始<tt>#</tt>被忽略直到一行的结束。</p> 
         <p data-fanyi="1">评论模式也可以通过嵌入国旗表达&nbsp;<tt>(?x)</tt>启用。</p> 
        </div> 
        <dl> 
         <dt> 
          <span class="seeLabel">另请参见：</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <a href="../../../constant-values.html#java.util.regex.Pattern.COMMENTS">Constant Field Values</a> 
         </dd> 
        </dl> </li> 
      </ul> <a name="MULTILINE"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>MULTILINE</h4> <pre>public static final&nbsp;int MULTILINE</pre> 
        <div class="block" data-fanyi="1">
          使多行模式。 
         <p data-fanyi="1">在MULTILINE模式表达<tt>^</tt>和<tt>$</tt>比赛之后或之前，分别行结束符或输入序列的末端。默认情况下，这些表达式仅在整个输入序列的开始和结束时进行匹配。</p> 
         <p data-fanyi="1">多行模式也可以通过嵌入国旗表达&nbsp;<tt>(?m)</tt>启用。</p> 
        </div> 
        <dl> 
         <dt> 
          <span class="seeLabel">另请参见：</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <a href="../../../constant-values.html#java.util.regex.Pattern.MULTILINE">Constant Field Values</a> 
         </dd> 
        </dl> </li> 
      </ul> <a name="LITERAL"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>LITERAL</h4> <pre>public static final&nbsp;int LITERAL</pre> 
        <div class="block" data-fanyi="1">
          启用模式的文本解析。 
         <p data-fanyi="1">当指定此标志时，指定该模式的输入字符串被视为一个文字字符的序列。输入序列中的元字符或转义序列将没有特殊意义。</p> 
         <p data-fanyi="1">国旗case_insensitive和unicode_case保留其在结合使用时，该标志匹配的影响。其他旗帜变得多余。</p> 
         <p data-fanyi="1">用于实现文本分析没有嵌入标志字符。</p> 
        </div> 
        <dl> 
         <dt> 
          <span class="simpleTagLabel">从以下版本开始：</span> 
         </dt> 
         <dd data-fanyi="1">
           一点五 
         </dd> 
         <dt> 
          <span class="seeLabel">另请参见：</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <a href="../../../constant-values.html#java.util.regex.Pattern.LITERAL">Constant Field Values</a> 
         </dd> 
        </dl> </li> 
      </ul> <a name="DOTALL"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>DOTALL</h4> <pre>public static final&nbsp;int DOTALL</pre> 
        <div class="block" data-fanyi="1">
          使dotall模式。 
         <p data-fanyi="1">在dotall模式，表达<tt>.</tt>匹配任何字符，包括换行符。默认情况下，这个表达式不匹配行终止符。</p> 
         <p data-fanyi="1">dotall模式也可以通过嵌入国旗表达&nbsp;<tt>(?s)</tt>启用。（是的<tt>s</tt>助记符“单行线”的模式，这是什么这就是Perl。）</p> 
        </div> 
        <dl> 
         <dt> 
          <span class="seeLabel">另请参见：</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <a href="../../../constant-values.html#java.util.regex.Pattern.DOTALL">Constant Field Values</a> 
         </dd> 
        </dl> </li> 
      </ul> <a name="UNICODE_CASE"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>UNICODE_CASE</h4> <pre>public static final&nbsp;int UNICODE_CASE</pre> 
        <div class="block" data-fanyi="1">
          使用Unicode的折盒。 
         <p data-fanyi="1">当指定了此标志，则不区分大小写匹配，当启用了<a href="../../../java/util/regex/Pattern.html#CASE_INSENSITIVE"><code>CASE_INSENSITIVE</code></a>旗帜，按照Unicode标准一致了。默认情况下，不区分大小写匹配假设在US-ASCII字符集只有字符匹配。</p> 
         <p data-fanyi="1">Unicode的情况下折叠也可以通过嵌入国旗表达&nbsp;<tt>(?u)</tt>启用。</p> 
         <p data-fanyi="1">指定该标志可能会强制实施性能损失。</p> 
        </div> 
        <dl> 
         <dt> 
          <span class="seeLabel">另请参见：</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <a href="../../../constant-values.html#java.util.regex.Pattern.UNICODE_CASE">Constant Field Values</a> 
         </dd> 
        </dl> </li> 
      </ul> <a name="CANON_EQ"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>CANON_EQ</h4> <pre>public static final&nbsp;int CANON_EQ</pre> 
        <div class="block" data-fanyi="1">
          使正则等价。 
         <p data-fanyi="1">当指定了此标志，然后两个字符将被视为比赛的话，只有当他们充分分解匹配。例如，表达<tt>"a\u030A"</tt>，将匹配字符串<tt>"\u00E5"</tt>时指定此标志。默认情况下，匹配不考虑规范等价。</p> 
         <p data-fanyi="1">有没有嵌入标志字符，使规范等价。</p> 
         <p data-fanyi="1">指定该标志可能会强制实施性能损失。</p> 
        </div> 
        <dl> 
         <dt> 
          <span class="seeLabel">另请参见：</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <a href="../../../constant-values.html#java.util.regex.Pattern.CANON_EQ">Constant Field Values</a> 
         </dd> 
        </dl> </li> 
      </ul> <a name="UNICODE_CHARACTER_CLASS"> 
       <!--   --> </a> 
      <ul class="blockListLast"> 
       <li class="blockList"> <h4>UNICODE_CHARACTER_CLASS</h4> <pre>public static final&nbsp;int UNICODE_CHARACTER_CLASS</pre> 
        <div class="block" data-fanyi="1">
          使用Unicode版本的预定义字符类别和POSIX字符类。 
         <p data-fanyi="1">当指定了此标志，则（US-ASCII只）预定义字符类别和POSIX字符类在<a href="http://www.unicode.org/reports/tr18/"><i>Unicode Technical Standard #18: Unicode Regular Expression</i></a>附件C一致性：兼容性属性。</p> 
         <p data-fanyi="1">的unicode_character_class模式也可以通过嵌入国旗表达&nbsp;<tt>(?U)</tt>启用。</p> 
         <p data-fanyi="1">国旗意味着unicode_case，即它使Unicode的折盒。</p> 
         <p data-fanyi="1">指定该标志可能会强制实施性能损失。</p> 
        </div> 
        <dl> 
         <dt> 
          <span class="simpleTagLabel">从以下版本开始：</span> 
         </dt> 
         <dd data-fanyi="1">
           一点七 
         </dd> 
         <dt> 
          <span class="seeLabel">另请参见：</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <a href="../../../constant-values.html#java.util.regex.Pattern.UNICODE_CHARACTER_CLASS">Constant Field Values</a> 
         </dd> 
        </dl> </li> 
      </ul> </li> 
    </ul> 
    <!-- ============ METHOD DETAIL ========== --> 
    <ul class="blockList"> 
     <li class="blockList"><a name="method.detail"> 
       <!--   --> </a> <h3>方法详细信息</h3> <a name="compile-java.lang.String-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>compile</h4> <pre>public static&nbsp;<a href="../../../java/util/regex/Pattern.html" title="class in java.util.regex">Pattern</a>&nbsp;compile(<a href="../../../java/lang/String.html" title="class in java.lang">String</a>&nbsp;regex)</pre> 
        <div class="block" data-fanyi="1">
          将给定的正则表达式编译成模式。 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>regex</code> -要编译的表达 
         </dd> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           给定的正则表达式编译成一个模式 
         </dd> 
         <dt> 
          <span class="throwsLabel">异常</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/util/regex/PatternSyntaxException.html" title="class in java.util.regex">PatternSyntaxException</a></code> -如果表达式的语法是无效的 
         </dd> 
        </dl> </li> 
      </ul> <a name="compile-java.lang.String-int-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>compile</h4> <pre>public static&nbsp;<a href="../../../java/util/regex/Pattern.html" title="class in java.util.regex">Pattern</a>&nbsp;compile(<a href="../../../java/lang/String.html" title="class in java.lang">String</a>&nbsp;regex,
                              int&nbsp;flags)</pre> 
        <div class="block" data-fanyi="1">
          用给定的标志将给定的正则表达式编译成一个模式。 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>regex</code> -要编译的表达 
         </dd> 
         <dd data-fanyi="1"> 
          <code>flags</code>匹配的旗帜，一位掩码，可能包括 
          <a href="../../../java/util/regex/Pattern.html#CASE_INSENSITIVE"><code>CASE_INSENSITIVE</code></a>， 
          <a href="../../../java/util/regex/Pattern.html#MULTILINE"><code>MULTILINE</code></a>， 
          <a href="../../../java/util/regex/Pattern.html#DOTALL"><code>DOTALL</code></a>， 
          <a href="../../../java/util/regex/Pattern.html#UNICODE_CASE"><code>UNICODE_CASE</code></a>， 
          <a href="../../../java/util/regex/Pattern.html#CANON_EQ"><code>CANON_EQ</code></a>， 
          <a href="../../../java/util/regex/Pattern.html#UNIX_LINES"><code>UNIX_LINES</code></a>， 
          <a href="../../../java/util/regex/Pattern.html#LITERAL"><code>LITERAL</code></a>， 
          <a href="../../../java/util/regex/Pattern.html#UNICODE_CHARACTER_CLASS"><code>UNICODE_CHARACTER_CLASS</code></a>和 
          <a href="../../../java/util/regex/Pattern.html#COMMENTS"><code>COMMENTS</code></a> 
         </dd> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           给定的正则表达式编译成一个模式与给定的标志 
         </dd> 
         <dt> 
          <span class="throwsLabel">异常</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code>如果比特值比相应的定义匹配标志被设置在 
          <tt>flags</tt> 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/util/regex/PatternSyntaxException.html" title="class in java.util.regex">PatternSyntaxException</a></code> -如果表达式的语法是无效的 
         </dd> 
        </dl> </li> 
      </ul> <a name="pattern--"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>pattern</h4> <pre>public&nbsp;<a href="../../../java/lang/String.html" title="class in java.lang">String</a>&nbsp;pattern()</pre> 
        <div class="block" data-fanyi="1">
          返回此模式被编译的正则表达式。 
        </div> 
        <dl> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           这种模式的来源 
         </dd> 
        </dl> </li> 
      </ul> <a name="toString--"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>toString</h4> <pre>public&nbsp;<a href="../../../java/lang/String.html" title="class in java.lang">String</a>&nbsp;toString()</pre> 
        <div class="block" data-fanyi="1"> 
         <p data-fanyi="1">返回此模式的字符串表示形式。这是这个模式被编译的正则表达式。</p> 
        </div> 
        <dl> 
         <dt> 
          <span class="overrideSpecifyLabel">重写：</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/Object.html#toString--">toString</a></code>&nbsp;方法重写，继承类&nbsp; 
          <code><a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></code> 
         </dd> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           该模式的字符串表示 
         </dd> 
         <dt> 
          <span class="simpleTagLabel">从以下版本开始：</span> 
         </dt> 
         <dd data-fanyi="1">
           一点五 
         </dd> 
        </dl> </li> 
      </ul> <a name="matcher-java.lang.CharSequence-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>matcher</h4> <pre>public&nbsp;<a href="../../../java/util/regex/Matcher.html" title="class in java.util.regex">Matcher</a>&nbsp;matcher(<a href="../../../java/lang/CharSequence.html" title="interface in java.lang">CharSequence</a>&nbsp;input)</pre> 
        <div class="block" data-fanyi="1">
          创建一个匹配，将匹配给定的输入对该模式。 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>input</code> -字符序列匹配 
         </dd> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           这种模式的一个新的匹配 
         </dd> 
        </dl> </li> 
      </ul> <a name="flags--"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>flags</h4> <pre>public&nbsp;int&nbsp;flags()</pre> 
        <div class="block" data-fanyi="1">
          返回此模式的匹配标志。 
        </div> 
        <dl> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           当此模式被编译时指定的匹配标志 
         </dd> 
        </dl> </li> 
      </ul> <a name="matches-java.lang.String-java.lang.CharSequence-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>matches</h4> <pre>public static&nbsp;boolean&nbsp;matches(<a href="../../../java/lang/String.html" title="class in java.lang">String</a>&nbsp;regex,
                              <a href="../../../java/lang/CharSequence.html" title="interface in java.lang">CharSequence</a>&nbsp;input)</pre> 
        <div class="block" data-fanyi="1">
          编译给定的正则表达式，并试图匹配给定的输入反对它。 
         <p data-fanyi="1">这种方便的形式方法的调用</p> 
         <blockquote> 
          <pre>
 Pattern.matches(regex, input);</pre> 
         </blockquote>表现一样，表达 
         <blockquote> 
          <pre>
 Pattern.compile(regex).matcher(input).matches()</pre> 
         </blockquote> 
         <p data-fanyi="1">如果一个模式是要多次使用，编译它一次，并重用它将是更有效的比调用该方法，每一次。</p> 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>regex</code> -要编译的表达 
         </dd> 
         <dd data-fanyi="1"> 
          <code>input</code> -字符序列匹配 
         </dd> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           是否在输入上的正则表达式匹配 
         </dd> 
         <dt> 
          <span class="throwsLabel">异常</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/util/regex/PatternSyntaxException.html" title="class in java.util.regex">PatternSyntaxException</a></code> -如果表达式的语法是无效的 
         </dd> 
        </dl> </li> 
      </ul> <a name="split-java.lang.CharSequence-int-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>split</h4> <pre>public&nbsp;<a href="../../../java/lang/String.html" title="class in java.lang">String</a>[]&nbsp;split(<a href="../../../java/lang/CharSequence.html" title="interface in java.lang">CharSequence</a>&nbsp;input,
                      int&nbsp;limit)</pre> 
        <div class="block" data-fanyi="1">
          将给定的输入序列拆分为这个模式的匹配。 
         <p data-fanyi="1">此方法返回的数组包含每个子串是由另一个序列匹配这个模式或是由输入序列的末端终止终止输入序列。数组中的子串在它们发生在输入命令。如果这种模式不匹配任何序列的输入产生的数组只有一个元素，即以字符串形式输入序列。</p> 
         <p data-fanyi="1">当有开始的输入序列，然后一个空字符串是包含在领先的阵列开始正面宽度匹配。一零宽度匹配而是一开始就不会产生这样的领导子空。</p> 
         <p data-fanyi="1">的<tt>limit</tt>参数控制模式应用的次数，因此影响结果数组的长度。如果限制N大于零则模式将被应用最多N&nbsp;-&nbsp;1次，数组的长度将不大于n，和数组的最后一项将包含所有输入超出最后匹配的分隔符。如果n是非正的，那么该模式将被应用尽可能多的时间和数组可以有任何长度。如果n是零，那么该模式将被应用尽可能多的时间，数组可以有任何长度，并尾随空字符串将被丢弃。</p> 
         <p data-fanyi="1">例如，输入<tt>"boo:and:foo"</tt>，得到以下结果与这些参数：</p> 
         <blockquote> 
          <table cellpadding="1" cellspacing="0" summary="Split examples showing regex, limit, and result"> 
           <tbody> 
            <tr> 
             <th align="left"><i>Regex&nbsp;&nbsp;&nbsp;&nbsp;</i></th> 
             <th align="left"><i>Limit&nbsp;&nbsp;&nbsp;&nbsp;</i></th> 
             <th align="left"><i>Result&nbsp;&nbsp;&nbsp;&nbsp;</i></th> 
            </tr> 
            <tr> 
             <td align="center">:</td> 
             <td align="center">2</td> 
             <td><tt>{ "boo", "and:foo" }</tt></td> 
            </tr> 
            <tr> 
             <td align="center">:</td> 
             <td align="center">5</td> 
             <td><tt>{ "boo", "and", "foo" }</tt></td> 
            </tr> 
            <tr> 
             <td align="center">:</td> 
             <td align="center">-2</td> 
             <td><tt>{ "boo", "and", "foo" }</tt></td> 
            </tr> 
            <tr> 
             <td align="center">o</td> 
             <td align="center">5</td> 
             <td><tt>{ "b", "", ":and:f", "", "" }</tt></td> 
            </tr> 
            <tr> 
             <td align="center">o</td> 
             <td align="center">-2</td> 
             <td><tt>{ "b", "", ":and:f", "", "" }</tt></td> 
            </tr> 
            <tr> 
             <td align="center">o</td> 
             <td align="center">0</td> 
             <td><tt>{ "b", "", ":and:f" }</tt></td> 
            </tr> 
           </tbody> 
          </table> 
         </blockquote> 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>input</code> -字符序列被分裂 
         </dd> 
         <dd data-fanyi="1"> 
          <code>limit</code>结果阈值，如上 
         </dd> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           通过分裂这个模式的匹配的输入来计算的字符串数组 
         </dd> 
        </dl> </li> 
      </ul> <a name="split-java.lang.CharSequence-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>split</h4> <pre>public&nbsp;<a href="../../../java/lang/String.html" title="class in java.lang">String</a>[]&nbsp;split(<a href="../../../java/lang/CharSequence.html" title="interface in java.lang">CharSequence</a>&nbsp;input)</pre> 
        <div class="block" data-fanyi="1">
          将给定的输入序列拆分为这个模式的匹配。 
         <p data-fanyi="1">这种方法是通过调用两<a href="../../../java/util/regex/Pattern.html#split-java.lang.CharSequence-int-"><code>split</code></a>如果论证方法与给定输入序列和零的极限参数。因此不包括在结果数组中的尾随空字符串。</p> 
         <p data-fanyi="1">例如，输入<tt>"boo:and:foo"</tt>，得到以下结果与这些表达式：</p> 
         <blockquote> 
          <table cellpadding="1" cellspacing="0" summary="Split examples showing regex and result"> 
           <tbody> 
            <tr> 
             <th align="left"><i>Regex&nbsp;&nbsp;&nbsp;&nbsp;</i></th> 
             <th align="left"><i>Result</i></th> 
            </tr> 
            <tr> 
             <td align="center">:</td> 
             <td><tt>{ "boo", "and", "foo" }</tt></td> 
            </tr> 
            <tr> 
             <td align="center">o</td> 
             <td><tt>{ "b", "", ":and:f" }</tt></td> 
            </tr> 
           </tbody> 
          </table> 
         </blockquote> 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>input</code> -字符序列被分裂 
         </dd> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           通过分裂这个模式的匹配的输入来计算的字符串数组 
         </dd> 
        </dl> </li> 
      </ul> <a name="quote-java.lang.String-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>quote</h4> <pre>public static&nbsp;<a href="../../../java/lang/String.html" title="class in java.lang">String</a>&nbsp;quote(<a href="../../../java/lang/String.html" title="class in java.lang">String</a>&nbsp;s)</pre> 
        <div class="block" data-fanyi="1">
          返回指定 
         <code>String</code>文字模式 
         <code>String</code>。在输入序列 
         <p data-fanyi="1">这种方法产生的<code>String</code>可用于创建<code>Pattern</code>将匹配字符串<code>s</code>就像文字图案。</p>元字符或转义序列将没有特殊意义。 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>s</code> -被激活的字符串 
         </dd> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           字符串替换 
         </dd> 
         <dt> 
          <span class="simpleTagLabel">从以下版本开始：</span> 
         </dt> 
         <dd data-fanyi="1">
           一点五 
         </dd> 
        </dl> </li> 
      </ul> <a name="asPredicate--"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>asPredicate</h4> <pre>public&nbsp;<a href="../../../java/util/function/Predicate.html" title="interface in java.util.function">Predicate</a>&lt;<a href="../../../java/lang/String.html" title="class in java.lang">String</a>&gt;&nbsp;asPredicate()</pre> 
        <div class="block" data-fanyi="1">
          创建一个可以用于匹配字符串的谓词。 
        </div> 
        <dl> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           可以用于字符串匹配的谓词 
         </dd> 
         <dt> 
          <span class="simpleTagLabel">从以下版本开始：</span> 
         </dt> 
         <dd data-fanyi="1">
           一点八 
         </dd> 
        </dl> </li> 
      </ul> <a name="splitAsStream-java.lang.CharSequence-"> 
       <!--   --> </a> 
      <ul class="blockListLast"> 
       <li class="blockList"> <h4>splitAsStream</h4> <pre>public&nbsp;<a href="../../../java/util/stream/Stream.html" title="interface in java.util.stream">Stream</a>&lt;<a href="../../../java/lang/String.html" title="class in java.lang">String</a>&gt;&nbsp;splitAsStream(<a href="../../../java/lang/CharSequence.html" title="interface in java.lang">CharSequence</a>&nbsp;input)</pre> 
        <div class="block" data-fanyi="1">
          从给定的输入序列创建一个流，围绕这个模式的匹配。 
         <p data-fanyi="1">流通过该方法返回包含每个子串是由另一个序列匹配这个模式或是由输入序列的末端终止终止输入序列。流中的子串在它们发生在输入命令。尾随空字符串将被丢弃，而不是在流中遇到。</p> 
         <p data-fanyi="1">如果这种模式不匹配任何序列的输入产生的流只有一个元素，即以字符串形式输入序列。</p> 
         <p data-fanyi="1">当有开始的输入序列，然后空主导子包含在流的开始正面宽度匹配。一零宽度匹配而是一开始就不会产生这样的领导子空。</p> 
         <p data-fanyi="1">如果输入序列是可变的，它必须在终端的流操作的执行过程中保持不变。否则，终端流操作的结果是不确定的。</p> 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>input</code> -字符序列被分裂 
         </dd> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           通过分裂此模式的匹配的输入而计算的字符串流 
         </dd> 
         <dt> 
          <span class="simpleTagLabel">从以下版本开始：</span> 
         </dt> 
         <dd data-fanyi="1">
           一点八 
         </dd> 
         <dt> 
          <span class="seeLabel">另请参见：</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <a href="../../../java/util/regex/Pattern.html#split-java.lang.CharSequence-"><code>split(CharSequence)</code></a> 
         </dd> 
        </dl> </li> 
      </ul> </li> 
    </ul> </li> 
  </ul> 
 </div> 
</div> 
<!-- ========= END OF CLASS DATA ========= --> 
<!-- ======= START OF BOTTOM NAVBAR ====== --> 
<div class="bottomNav"> 
 <a name="navbar.bottom"> 
  <!--   --> </a> 
 <div class="skipNav"> 
  <a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a> 
 </div> 
 <a name="navbar.bottom.firstrow"> 
  <!--   --> </a> 
 <ul class="navList" title="Navigation"> 
  <li><a href="../../../overview-summary.html">概述</a></li> 
  <li><a href="package-summary.html">软件包</a></li> 
  <li class="navBarCell1Rev">类</li> 
  <li><a href="class-use/Pattern.html">使用</a></li> 
  <li><a href="package-tree.html">树</a></li> 
  <li><a href="../../../deprecated-list.html">已过时的</a></li> 
  <li><a href="../../../index-files/index-1.html">索引</a></li> 
  <li><a href="../../../help-doc.html">帮助</a></li> 
 </ul> 
 <div class="aboutLanguage"> 
  <strong>Java™&nbsp;Platform<br>Standard&nbsp;Ed.&nbsp;8</strong> 
 </div> 
</div> 
<div class="subNav"> 
 <ul class="navList"> 
  <li><a href="../../../java/util/regex/MatchResult.html" title="interface in java.util.regex"><span class="typeNameLink">上一个</span></a></li> 
  <li><a href="../../../java/util/regex/PatternSyntaxException.html" title="class in java.util.regex"><span class="typeNameLink">下一个</span></a></li> 
 </ul> 
 <ul class="navList"> 
  <li><a href="../../../index.html?java/util/regex/Pattern.html" target="_top">框架</a></li> 
  <li><a href="Pattern.html" target="_top">无框架</a></li> 
 </ul> 
 <ul class="navList" id="allclasses_navbar_bottom"> 
  <li><a href="../../../allclasses-noframe.html">所有类</a></li> 
 </ul> 
 <div> 
  <script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script> 
 </div> 
 <div> 
  <ul class="subNavList"> 
   <li>概要：</li> 
   <li>嵌套</li> 
   <li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li> 
   <li>构造方法</li> 
   <li><a href="#method.summary">方法</a></li> 
  </ul> 
  <ul class="subNavList"> 
   <li>详细信息：</li> 
   <li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li> 
   <li>构造方法</li> 
   <li><a href="#method.detail">方法</a></li> 
  </ul> 
 </div> 
 <a name="skip.navbar.bottom"> 
  <!--   --> </a> 
</div> 
<!-- ======== END OF BOTTOM NAVBAR ======= --> 
<p class="legalCopy"><small><font size="-1"> <a href="http://bugreport.sun.com/bugreport/">Submit a bug or feature</a> <br>For further API reference and developer documentation, see <a href="http://download.oracle.com/javase/8/docs/index.html" target="_blank">Java SE Documentation</a>. That documentation contains more detailed, developer-targeted descriptions, with conceptual overviews, definitions of terms, workarounds, and working code examples.<br> Copyright © 1993, 2014, Oracle and/or its affiliates. All rights reserved. </font></small> </p> 
<div id="adDiv"> 


 <div></div> 
</div> 
<p></p>