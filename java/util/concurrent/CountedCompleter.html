<!-- NewPage -->   
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<!-- Generated by javadoc (1.8.0) on Tue Mar 04 03:12:51 PST 2014 --> 
<title>CountedCompleter (Java Platform SE 8 )</title> 
<meta name="date" content="2014-03-04"> 
<meta name="keywords" content="java.util.concurrent.CountedCompleter class"> 
<meta name="keywords" content="compute()"> 
<meta name="keywords" content="onCompletion()"> 
<meta name="keywords" content="onExceptionalCompletion()"> 
<meta name="keywords" content="getCompleter()"> 
<meta name="keywords" content="getPendingCount()"> 
<meta name="keywords" content="setPendingCount()"> 
<meta name="keywords" content="addToPendingCount()"> 
<meta name="keywords" content="compareAndSetPendingCount()"> 
<meta name="keywords" content="decrementPendingCountUnlessZero()"> 
<meta name="keywords" content="getRoot()"> 
<meta name="keywords" content="tryComplete()"> 
<meta name="keywords" content="propagateCompletion()"> 
<meta name="keywords" content="complete()"> 
<meta name="keywords" content="firstComplete()"> 
<meta name="keywords" content="nextComplete()"> 
<meta name="keywords" content="quietlyCompleteRoot()"> 
<meta name="keywords" content="helpComplete()"> 
<meta name="keywords" content="exec()"> 
<meta name="keywords" content="getRawResult()"> 
<meta name="keywords" content="setRawResult()"> 
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style"> 
<script type="text/javascript" src="../../../script.js"></script> 
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="CountedCompleter (Java Platform SE 8 )";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":10,"i1":10,"i2":10,"i3":6,"i4":10,"i5":10,"i6":10,"i7":10,"i8":10,"i9":10,"i10":10,"i11":10,"i12":10,"i13":10,"i14":10,"i15":10,"i16":10,"i17":10,"i18":10,"i19":10};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],4:["t3","Abstract Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script> 
<noscript>
  &lt;div&gt; JavaScript is disabled on your browser. 
</noscript> 
<!-- ========= START OF TOP NAVBAR ======= -->   
<div class="topNav"> 
 <a name="navbar.top"> 
  <!--   --> </a> 
 <div class="skipNav"> 
  <a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a> 
 </div> 
 <a name="navbar.top.firstrow"> 
  <!--   --> </a> 
 <ul class="navList" title="Navigation"> 
  <li><a href="../../../overview-summary.html">概述</a></li> 
  <li><a href="package-summary.html">软件包</a></li> 
  <li class="navBarCell1Rev">类</li> 
  <li><a href="class-use/CountedCompleter.html">使用</a></li> 
  <li><a href="package-tree.html">树</a></li> 
  <li><a href="../../../deprecated-list.html">已过时的</a></li> 
  <li><a href="../../../index-files/index-1.html">索引</a></li> 
  <li><a href="../../../help-doc.html">帮助</a></li> 
 </ul> 
 <div class="aboutLanguage"> 
  <strong>Java™&nbsp;Platform<br>Standard&nbsp;Ed.&nbsp;8</strong> 
 </div> 
</div> 
<div class="subNav"> 
 <ul class="navList"> 
  <li><a href="../../../java/util/concurrent/CountDownLatch.html" title="class in java.util.concurrent"><span class="typeNameLink">上一个</span></a></li> 
  <li><a href="../../../java/util/concurrent/CyclicBarrier.html" title="class in java.util.concurrent"><span class="typeNameLink">下一个</span></a></li> 
 </ul> 
 <ul class="navList"> 
  <li><a href="../../../index.html?java/util/concurrent/CountedCompleter.html" target="_top">框架</a></li> 
  <li><a href="CountedCompleter.html" target="_top">无框架</a></li> 
 </ul> 
 <ul class="navList" id="allclasses_navbar_top"> 
  <li><a href="../../../allclasses-noframe.html">所有类</a></li> 
 </ul> 
 <div> 
  <script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script> 
 </div> 
 <div> 
  <ul class="subNavList"> 
   <li>概要：</li> 
   <li>嵌套</li> 
   <li>字段</li> 
   <li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li> 
   <li><a href="#method.summary">方法</a></li> 
  </ul> 
  <ul class="subNavList"> 
   <li>详细信息：</li> 
   <li>字段</li> 
   <li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li> 
   <li><a href="#method.detail">方法</a></li> 
  </ul> 
 </div> 
 <a name="skip.navbar.top"> 
  <!--   --> </a> 
</div> 
<!-- ========= END OF TOP NAVBAR ========= --> 
<!-- ======== START OF CLASS DATA ======== --> 
<div class="header"> 
 <div class="subTitle">
   compact1, compact2, compact3 
 </div> 
 <div class="subTitle">
   java.util.concurrent 
 </div> 
 <h2 title="Class CountedCompleter" class="title">Class CountedCompleter&lt;T&gt;</h2> 
</div> 
<div class="contentContainer"> 
 <ul class="inheritance"> 
  <li><a href="../../../java/lang/Object.html" title="class in java.lang">java.lang.Object</a></li> 
  <li> 
   <ul class="inheritance"> 
    <li><a href="../../../java/util/concurrent/ForkJoinTask.html" title="class in java.util.concurrent">java.util.concurrent.ForkJoinTask</a>&lt;T&gt;</li> 
    <li> 
     <ul class="inheritance"> 
      <li>java.util.concurrent.CountedCompleter&lt;T&gt;</li> 
     </ul> </li> 
   </ul> </li> 
 </ul> 
 <div class="description"> 
  <ul class="blockList"> 
   <li class="blockList"> 
    <dl> 
     <dt>
       All Implemented Interfaces: 
     </dt> 
     <dd data-fanyi="1"> 
      <a href="../../../java/io/Serializable.html" title="interface in java.io">Serializable</a>， 
      <a href="../../../java/util/concurrent/Future.html" title="interface in java.util.concurrent">Future</a> 
      <t></t> 
     </dd> 
    </dl> 
    <hr> <br> <pre>public abstract class <span class="typeNameLabel">CountedCompleter&lt;T&gt;</span>
extends <a href="../../../java/util/concurrent/ForkJoinTask.html" title="class in java.util.concurrent">ForkJoinTask</a>&lt;T&gt;</pre> 
    <div class="block" data-fanyi="1">
      一个执行时触发，没有剩余的未决诉讼 
     <a href="../../../java/util/concurrent/ForkJoinTask.html" title="class in java.util.concurrent"><code>ForkJoinTask</code></a>完成动作。countedcompleters一般是在任务档和堵塞的存在比其他形式的forkjointasks更强大，但不太直观的程序。采用countedcompleter是相似的其他竣工部件（如 
     <a href="../../../java/nio/channels/CompletionHandler.html" title="interface in java.nio.channels"><code>CompletionHandler</code></a>）除了多待完成可能需要触发 
     <a href="../../../java/util/concurrent/CountedCompleter.html#onCompletion-java.util.concurrent.CountedCompleter-"><code>onCompletion(CountedCompleter)</code></a>完成动作，不只是一个。除非初始化，否则， 
     <a href="../../../java/util/concurrent/CountedCompleter.html#getPendingCount--">pending count</a>的从零开始的，但可能是（原子）的使用方法 
     <a href="../../../java/util/concurrent/CountedCompleter.html#setPendingCount-int-"><code>setPendingCount(int)</code></a>， 
     <a href="../../../java/util/concurrent/CountedCompleter.html#addToPendingCount-int-"><code>addToPendingCount(int)</code></a>，和 
     <a href="../../../java/util/concurrent/CountedCompleter.html#compareAndSetPendingCount-int-int-"><code>compareAndSetPendingCount(int, int)</code></a>改变。在调用 
     <a href="../../../java/util/concurrent/CountedCompleter.html#tryComplete--"><code>tryComplete()</code></a>未决诉讼，如果计数为零，这是递减的；否则，执行完成的动作，如果完成本身已经完成，过程继续它的完成者。作为与相关同步组件如 
     <a href="../../../java/util/concurrent/Phaser.html" title="class in java.util.concurrent"><code>Phaser</code></a>和 
     <a href="../../../java/util/concurrent/Semaphore.html" title="class in java.util.concurrent"><code>Semaphore</code></a>的情况下，这些方法只会影响内部计数；他们没有建立任何进一步的内部簿记。特别是，挂起的任务的身份不被维护。如下图所示，您可以创建一个子类，在需要时记录一些或所有挂起的任务或它们的结果。如下图所示，还提供了实用的方法支持定制完成遍历。然而，因为countedcompleters只提供基本的同步机制，它可以创建子类进一步抽象，保持联系，领域有用，和额外的支持方法适合一组相关的用法。 
     <p data-fanyi="1">一个具体的countedcompleter类必须定义方法<a href="../../../java/util/concurrent/CountedCompleter.html#compute--"><code>compute()</code></a>，应该在大多数情况下（如下图所示），<code>tryComplete()</code>一旦调用返回之前。类也可以选择重写方法<a href="../../../java/util/concurrent/CountedCompleter.html#onCompletion-java.util.concurrent.CountedCompleter-"><code>onCompletion(CountedCompleter)</code></a>在正常完成执行的操作和方法<a href="../../../java/util/concurrent/CountedCompleter.html#onExceptionalCompletion-java.lang.Throwable-java.util.concurrent.CountedCompleter-"><code>onExceptionalCompletion(Throwable, CountedCompleter)</code></a>在任何异常动作。</p> 
     <p data-fanyi="1">countedcompleters通常不承担结果，在这种情况下，他们通常称为<code>CountedCompleter&lt;Void&gt;</code>，永远作为一个结果值返回<code>null</code>。在其他情况下，你应该重写方法<a href="../../../java/util/concurrent/CountedCompleter.html#getRawResult--"><code>getRawResult()</code></a>提供从<code>join(), invoke()</code>结果，和相关的方法。总的来说，这个方法应该返回一个字段的值（或一个或多个字段的功能），将结果完成后的countedcompleter对象。方法<a href="../../../java/util/concurrent/CountedCompleter.html#setRawResult-T-"><code>setRawResult(T)</code></a>默认countedcompleters不起作用。这是可能的，但很少适用，要重写此方法，以保持保持其他对象或字段保持结果数据。</p> 
     <p data-fanyi="1">一个countedcompleter，本身并没有一个完整的（即，其中<a href="../../../java/util/concurrent/CountedCompleter.html#getCompleter--"><code>getCompleter()</code></a>返回<code>null</code>）可以被用来作为一个附加功能正常forkjointask。然而，任何完成，则另一者只作为其他计算内部的帮手，所以自己的任务状态（如法如<a href="../../../java/util/concurrent/ForkJoinTask.html#isDone--"><code>ForkJoinTask.isDone()</code></a>报道）是任意的；这种状态的变化只有在<a href="../../../java/util/concurrent/CountedCompleter.html#complete-T-"><code>complete(T)</code></a>，<a href="../../../java/util/concurrent/ForkJoinTask.html#cancel-boolean-"><code>ForkJoinTask.cancel(boolean)</code></a>显式调用，<a href="../../../java/util/concurrent/ForkJoinTask.html#completeExceptionally-java.lang.Throwable-"><code>ForkJoinTask.completeExceptionally(Throwable)</code></a>或在<code>compute</code>出色的完成方法。在任何特殊的完成，异常可能传递到任务的完成者（及其完善，等等），如果存在有没有已经完成。同样，取消内部countedcompleter对完成只是局部效应，所以不常有用。</p> 
     <p data-fanyi="1"><b data-fanyi="1">示例用法。</b></p> 
     <p data-fanyi="1"><b data-fanyi="1">并行递归分解。</b> countedcompleters可布置在树上类似于那些经常使用<a href="../../../java/util/concurrent/RecursiveAction.html" title="class in java.util.concurrent"><code>RecursiveAction</code></a>s，虽然参与建立他们通常的结构变化。在这里，每个任务的完成是在计算树的父。尽管他们需要更多一点的记账，countedcompleters可能是更好的选择将可能耗时的操作时（不能进一步细分）对数组或集合中的每个元素；尤其是当操作需要不同的时间来完成一些元素比其他人，或是因为内在的变化（例如我o）或副作用如垃圾收集。因为countedcompleters提供自己的延续，不需要等待其他线程块执行。</p> 
     <p data-fanyi="1">例如，这里是一个类的初始版本，使用由两个递归分解划分成一个单一块（叶任务）。即使工作分为个人电话，基于树的技术通常比直接叉叶的任务，因为他们减少线程间的通信，提高负载均衡。在递归的情况下，每一对的第二个任务完成触发其母完成（因为是执行，没有结果相结合的默认无操作实施方法<code>onCompletion</code>不重写）。一个静态的实用方法设置基本任务和调用它（在这里，隐式地使用<a href="../../../java/util/concurrent/ForkJoinPool.html#commonPool--"><code>ForkJoinPool.commonPool()</code></a>）。</p> 
     <pre data-fanyi="1"><code>
 class MyOperation&lt;E&gt; { void apply(E e) { ... }  }

 class ForEach&lt;E&gt; extends CountedCompleter&lt;Void&gt; {

   public static &lt;E&gt; void forEach(E[] array, MyOperation&lt;E&gt; op) {
     new ForEach&lt;E&gt;(null, array, op, 0, array.length).invoke();
   }

   final E[] array; final MyOperation&lt;E&gt; op; final int lo, hi;
   ForEach(CountedCompleter&lt;?&gt; p, E[] array, MyOperation&lt;E&gt; op, int lo, int hi) {
     super(p);
     this.array = array; this.op = op; this.lo = lo; this.hi = hi;
   }

   public void compute() { // version 1
     if (hi - lo &gt;= 2) {
       int mid = (lo + hi) &gt;&gt;&gt; 1;
       setPendingCount(2); // must set pending count before fork
       new ForEach(this, array, op, mid, hi).fork(); // right child
       new ForEach(this, array, op, lo, mid).fork(); // left child
     }
     else if (hi &gt; lo)
       op.apply(array[lo]);
     tryComplete();
   }
 }</code></pre>本设计可以注意在递归情况改善，任务无关的任务后分叉，所以可以直接调用它的任务返回之前离开。（这是尾递归去除。模拟），因为在执行任务返回左边的任务（而不是通过调用 
     <code>tryComplete</code>）待数设置为： 
     <pre data-fanyi="1"><code>
 class ForEach&lt;E&gt; ...
   public void compute() { // version 2
     if (hi - lo &gt;= 2) {
       int mid = (lo + hi) &gt;&gt;&gt; 1;
       setPendingCount(1); // only one pending
       new ForEach(this, array, op, mid, hi).fork(); // right child
       new ForEach(this, array, op, lo, mid).compute(); // direct invoke
     }
     else {
       if (hi &gt; lo)
         op.apply(array[lo]);
       tryComplete();
     }
   }
 </code></pre>作为进一步改进，注意左边的任务甚至不需要存在。而不是创建一个新的，我们可以重复使用原来的任务，并添加一个待计数每个叉。此外，因为在这棵树上没有任务实现 
     <a href="../../../java/util/concurrent/CountedCompleter.html#onCompletion-java.util.concurrent.CountedCompleter-"><code>onCompletion(CountedCompleter)</code></a>方法， 
     <code>tryComplete()</code>可以用 
     <a href="../../../java/util/concurrent/CountedCompleter.html#propagateCompletion--"><code>propagateCompletion()</code></a>。 
     <pre data-fanyi="1"><code>
 class ForEach&lt;E&gt; ...
   public void compute() { // version 3
     int l = lo,  h = hi;
     while (h - l &gt;= 2) {
       int mid = (l + h) &gt;&gt;&gt; 1;
       addToPendingCount(1);
       new ForEach(this, array, op, mid, h).fork(); // right child
       h = mid;
     }
     if (h &gt; l)
       op.apply(array[l]);
     propagateCompletion();
   }
 </code></pre>额外的改进的类可能需要预先挂起计数使他们可以建立专业类的构造函数，叶的步骤，细分的说，四，而不是每两个迭代，并采用自适应阈值而不是细分到单元素。 
     <p data-fanyi="1"><b data-fanyi="1">搜索.</b>树countedcompleters可以搜索在一个数据结构的不同部分的值或属性，并报告在<a href="../../../java/util/concurrent/atomic/AtomicReference.html" title="class in java.util.concurrent.atomic"><code>AtomicReference</code></a>结果尽快找到一个。其他人可以调查结果，以避免不必要的工作。（你可以另外<a href="../../../java/util/concurrent/ForkJoinTask.html#cancel-boolean-">cancel</a>其他任务，但它通常是简单、有效的让他们注意到结果集，那么跳过进一步处理。）说明再次用全分配数组（再次，在实践中，叶的任务几乎总是可以处理多个元素）：</p> 
     <pre data-fanyi="1"><code>
 class Searcher&lt;E&gt; extends CountedCompleter&lt;E&gt; {
   final E[] array; final AtomicReference&lt;E&gt; result; final int lo, hi;
   Searcher(CountedCompleter&lt;?&gt; p, E[] array, AtomicReference&lt;E&gt; result, int lo, int hi) {
     super(p);
     this.array = array; this.result = result; this.lo = lo; this.hi = hi;
   }
   public E getRawResult() { return result.get(); }
   public void compute() { // similar to ForEach version 3
     int l = lo,  h = hi;
     while (result.get() == null &amp;&amp; h &gt;= l) {
       if (h - l &gt;= 2) {
         int mid = (l + h) &gt;&gt;&gt; 1;
         addToPendingCount(1);
         new Searcher(this, array, result, mid, h).fork();
         h = mid;
       }
       else {
         E x = array[l];
         if (matches(x) &amp;&amp; result.compareAndSet(null, x))
           quietlyCompleteRoot(); // root task is now joinable
         break;
       }
     }
     tryComplete(); // normally complete whether or not found
   }
   boolean matches(E e) { ... } // return true if found

   public static &lt;E&gt; E search(E[] array) {
       return new Searcher&lt;E&gt;(null, array, new AtomicReference&lt;E&gt;(), 0, array.length).invoke();
   }
 }</code></pre>在这个例子中，以及在哪些任务没有其他的影响除了compareandset共同作用的结果，后无条件调用 
     <code>tryComplete</code>可以条件（ 
     <code>if (result.get() == null) tryComplete();</code>）因为没有进一步的簿记管理所需完成的任务完成后，根。 
     <p data-fanyi="1"><b data-fanyi="1">记录任务。</b> countedcompleter任务相结合的多个子任务的结果通常需要获得这些结果的方法<a href="../../../java/util/concurrent/CountedCompleter.html#onCompletion-java.util.concurrent.CountedCompleter-"><code>onCompletion(CountedCompleter)</code></a>。如下面的类说明（执行一个简化的形式在Map减少映射和减少所有类型<code>E</code>），做到这一点的方法之一在分而治之的设计是每个子任务的记录，它的兄弟姐妹，所以它可以访问的方法<code>onCompletion</code>。该技术适用于在其中结合左和右的结果并不重要，订单减少；下令减少需要明确的左/右的名称。其他streamlinings在上述例子的变种也可以申请。</p> 
     <pre data-fanyi="1"><code>
 class MyMapper&lt;E&gt; { E apply(E v) {  ...  } }
 class MyReducer&lt;E&gt; { E apply(E x, E y) {  ...  } }
 class MapReducer&lt;E&gt; extends CountedCompleter&lt;E&gt; {
   final E[] array; final MyMapper&lt;E&gt; mapper;
   final MyReducer&lt;E&gt; reducer; final int lo, hi;
   MapReducer&lt;E&gt; sibling;
   E result;
   MapReducer(CountedCompleter&lt;?&gt; p, E[] array, MyMapper&lt;E&gt; mapper,
              MyReducer&lt;E&gt; reducer, int lo, int hi) {
     super(p);
     this.array = array; this.mapper = mapper;
     this.reducer = reducer; this.lo = lo; this.hi = hi;
   }
   public void compute() {
     if (hi - lo &gt;= 2) {
       int mid = (lo + hi) &gt;&gt;&gt; 1;
       MapReducer&lt;E&gt; left = new MapReducer(this, array, mapper, reducer, lo, mid);
       MapReducer&lt;E&gt; right = new MapReducer(this, array, mapper, reducer, mid, hi);
       left.sibling = right;
       right.sibling = left;
       setPendingCount(1); // only right is pending
       right.fork();
       left.compute();     // directly execute left
     }
     else {
       if (hi &gt; lo)
           result = mapper.apply(array[lo]);
       tryComplete();
     }
   }
   public void onCompletion(CountedCompleter&lt;?&gt; caller) {
     if (caller != this) {
       MapReducer&lt;E&gt; child = (MapReducer&lt;E&gt;)caller;
       MapReducer&lt;E&gt; sib = child.sibling;
       if (sib == null || sib.result == null)
         result = child.result;
       else
         result = reducer.apply(child.result, sib.result);
     }
   }
   public E getRawResult() { return result; }

   public static &lt;E&gt; E mapReduce(E[] array, MyMapper&lt;E&gt; mapper, MyReducer&lt;E&gt; reducer) {
     return new MapReducer&lt;E&gt;(null, array, mapper, reducer,
                              0, array.length).invoke();
   }
 }</code></pre>这里，方法 
     <code>onCompletion</code>需要形成共同的许多完成设计相结合的结果。这个回调方式触发每一次任务，在两个不同的上下文中，挂起计数，或变为零：（1）通过任务本身，如果其未决的计数为零，在调用 
     <code>tryComplete</code>，或（2）任何其子任务在完成和递减的等待计数为零。争论的 
     <code>caller</code>区分例。通常，当对方是 
     <code>this</code>，没有必要采取行动。否则，调用方的参数可以使用（通常是通过一个演员）提供一个值（和/或链接到其他值）进行合并。如果正确使用有待统计，发生在 
     <code>onCompletion</code>行动（一次）在完成一个任务和子任务。在这种方法中不需要额外的同步，以确保访问此任务或其他已完成任务的字段的线程安全性。 
     <p data-fanyi="1"><b data-fanyi="1">完成遍历</b>。如果使用<code>onCompletion</code>过程完成是不可行或不方便，你可以使用的方法<a href="../../../java/util/concurrent/CountedCompleter.html#firstComplete--"><code>firstComplete()</code></a>和<a href="../../../java/util/concurrent/CountedCompleter.html#nextComplete--"><code>nextComplete()</code></a>创建定制的遍历。例如，定义一个mapreducer只打出右侧的任务在第三个例子的形式，完成未尽的任务必须合作减少环节，可以做如下：</p> 
     <pre data-fanyi="1"><code>
 class MapReducer&lt;E&gt; extends CountedCompleter&lt;E&gt; { // version 2
   final E[] array; final MyMapper&lt;E&gt; mapper;
   final MyReducer&lt;E&gt; reducer; final int lo, hi;
   MapReducer&lt;E&gt; forks, next; // record subtask forks in list
   E result;
   MapReducer(CountedCompleter&lt;?&gt; p, E[] array, MyMapper&lt;E&gt; mapper,
              MyReducer&lt;E&gt; reducer, int lo, int hi, MapReducer&lt;E&gt; next) {
     super(p);
     this.array = array; this.mapper = mapper;
     this.reducer = reducer; this.lo = lo; this.hi = hi;
     this.next = next;
   }
   public void compute() {
     int l = lo,  h = hi;
     while (h - l &gt;= 2) {
       int mid = (l + h) &gt;&gt;&gt; 1;
       addToPendingCount(1);
       (forks = new MapReducer(this, array, mapper, reducer, mid, h, forks)).fork();
       h = mid;
     }
     if (h &gt; l)
       result = mapper.apply(array[l]);
     // process completions by reducing along and advancing subtask links
     for (CountedCompleter&lt;?&gt; c = firstComplete(); c != null; c = c.nextComplete()) {
       for (MapReducer t = (MapReducer)c, s = t.forks;  s != null; s = t.forks = s.next)
         t.result = reducer.apply(t.result, s.result);
     }
   }
   public E getRawResult() { return result; }

   public static &lt;E&gt; E mapReduce(E[] array, MyMapper&lt;E&gt; mapper, MyReducer&lt;E&gt; reducer) {
     return new MapReducer&lt;E&gt;(null, array, mapper, reducer,
                              0, array.length, null).invoke();
   }
 }</code></pre> 
     <p data-fanyi="1"><b data-fanyi="1">触发器。</b>一些countedcompleters本身不分叉，而是作为其他设计管道位；包括一个或多个异步任务触发另一个异步任务的完成。例如:</p> 
     <pre data-fanyi="1"><code>
 class HeaderBuilder extends CountedCompleter&lt;...&gt; { ... }
 class BodyBuilder extends CountedCompleter&lt;...&gt; { ... }
 class PacketSender extends CountedCompleter&lt;...&gt; {
   PacketSender(...) { super(null, 1); ... } // trigger on second completion
   public void compute() { } // never called
   public void onCompletion(CountedCompleter&lt;?&gt; caller) { sendPacket(); }
 }
 // sample use:
 PacketSender p = new PacketSender();
 new HeaderBuilder(p, ...).fork();
 new BodyBuilder(p, ...).fork();
 </code></pre> 
    </div> 
    <dl> 
     <dt> 
      <span class="simpleTagLabel">从以下版本开始：</span> 
     </dt> 
     <dd data-fanyi="1">
       一点八 
     </dd> 
     <dt> 
      <span class="seeLabel">另请参见：</span> 
     </dt> 
     <dd data-fanyi="1"> 
      <a href="../../../serialized-form.html#java.util.concurrent.CountedCompleter">Serialized Form</a> 
     </dd> 
    </dl> </li> 
  </ul> 
 </div> 
 <div class="summary"> 
  <ul class="blockList"> 
   <li class="blockList"> 
    <!-- ======== CONSTRUCTOR SUMMARY ======== --> 
    <ul class="blockList"> 
     <li class="blockList"><a name="constructor.summary"> 
       <!--   --> </a> <h3>构造方法摘要</h3> 
      <table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation"> 
       <caption> 
        <span>构造方法</span> 
        <span class="tabEnd">&nbsp;</span> 
       </caption> 
       <tbody> 
        <tr> 
         <th class="colFirst" scope="col">Modifier</th> 
         <th class="colLast" scope="col">Constructor and Description</th> 
        </tr> 
        <tr class="altColor"> 
         <td class="colFirst"><code>protected </code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/CountedCompleter.html#CountedCompleter--">CountedCompleter</a></span>()</code> 
          <div class="block" data-fanyi="1">
            创造没有完成和初始挂起计数零的一个新countedcompleter。 
          </div> </td> 
        </tr> 
        <tr class="rowColor"> 
         <td class="colFirst"><code>protected </code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/CountedCompleter.html#CountedCompleter-java.util.concurrent.CountedCompleter-">CountedCompleter</a></span>(<a href="../../../java/util/concurrent/CountedCompleter.html" title="class in java.util.concurrent">CountedCompleter</a>&lt;?&gt;&nbsp;completer)</code> 
          <div class="block" data-fanyi="1">
            创建具有给定的完成和一个初始挂起计数零的一个新countedcompleter。 
          </div> </td> 
        </tr> 
        <tr class="altColor"> 
         <td class="colFirst"><code>protected </code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/CountedCompleter.html#CountedCompleter-java.util.concurrent.CountedCompleter-int-">CountedCompleter</a></span>(<a href="../../../java/util/concurrent/CountedCompleter.html" title="class in java.util.concurrent">CountedCompleter</a>&lt;?&gt;&nbsp;completer, int&nbsp;initialPendingCount)</code> 
          <div class="block" data-fanyi="1">
            创建具有给定的完成和初始待统计的新countedcompleter。 
          </div> </td> 
        </tr> 
       </tbody> 
      </table> </li> 
    </ul> 
    <!-- ========== METHOD SUMMARY =========== --> 
    <ul class="blockList"> 
     <li class="blockList"><a name="method.summary"> 
       <!--   --> </a> <h3>方法摘要</h3> 
      <table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation"> 
       <caption> 
        <span id="t0" class="activeTableTab"><span>所有方法</span><span class="tabEnd">&nbsp;</span></span> 
        <span id="t2" class="tableTab"><span><a href="javascript:show(2);">接口方法</a></span><span class="tabEnd">&nbsp;</span></span> 
        <span id="t3" class="tableTab"><span><a href="javascript:show(4);">抽象方法</a></span><span class="tabEnd">&nbsp;</span></span> 
        <span id="t4" class="tableTab"><span><a href="javascript:show(8);">具体的方法</a></span><span class="tabEnd">&nbsp;</span></span> 
       </caption> 
       <tbody> 
        <tr> 
         <th class="colFirst" scope="col">Modifier and Type</th> 
         <th class="colLast" scope="col">Method and Description</th> 
        </tr> 
        <tr id="i0" class="altColor"> 
         <td class="colFirst"><code>void</code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/CountedCompleter.html#addToPendingCount-int-">addToPendingCount</a></span>(int&nbsp;delta)</code> 
          <div class="block" data-fanyi="1">
            添加（原子）给定值挂起计数。 
          </div> </td> 
        </tr> 
        <tr id="i1" class="rowColor"> 
         <td class="colFirst"><code>boolean</code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/CountedCompleter.html#compareAndSetPendingCount-int-int-">compareAndSetPendingCount</a></span>(int&nbsp;expected, int&nbsp;count)</code> 
          <div class="block" data-fanyi="1">
            集（原子）挂起计数的计数只有目前是给定的期望值。 
          </div> </td> 
        </tr> 
        <tr id="i2" class="altColor"> 
         <td class="colFirst"><code>void</code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/CountedCompleter.html#complete-T-">complete</a></span>(<a href="../../../java/util/concurrent/CountedCompleter.html" title="type parameter in CountedCompleter">T</a>&nbsp;rawResult)</code> 
          <div class="block" data-fanyi="1">
            无论在数量，调用 
           <a href="../../../java/util/concurrent/CountedCompleter.html#onCompletion-java.util.concurrent.CountedCompleter-"><code>onCompletion(CountedCompleter)</code></a>，标志着这项任务完成，进一步引发 
           <a href="../../../java/util/concurrent/CountedCompleter.html#tryComplete--"><code>tryComplete()</code></a>这个任务的完成，如果存在。 
          </div> </td> 
        </tr> 
        <tr id="i3" class="rowColor"> 
         <td class="colFirst"><code>abstract void</code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/CountedCompleter.html#compute--">compute</a></span>()</code> 
          <div class="block" data-fanyi="1">
            此任务执行的主要计算。 
          </div> </td> 
        </tr> 
        <tr id="i4" class="altColor"> 
         <td class="colFirst"><code>int</code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/CountedCompleter.html#decrementPendingCountUnlessZero--">decrementPendingCountUnlessZero</a></span>()</code> 
          <div class="block" data-fanyi="1">
            如果挂起计数为零，（原子）减少它。 
          </div> </td> 
        </tr> 
        <tr id="i5" class="rowColor"> 
         <td class="colFirst"><code>protected boolean</code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/CountedCompleter.html#exec--">exec</a></span>()</code> 
          <div class="block" data-fanyi="1">
            贯彻执行公约countedcompleters。 
          </div> </td> 
        </tr> 
        <tr id="i6" class="altColor"> 
         <td class="colFirst"><code><a href="../../../java/util/concurrent/CountedCompleter.html" title="class in java.util.concurrent">CountedCompleter</a>&lt;?&gt;</code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/CountedCompleter.html#firstComplete--">firstComplete</a></span>()</code> 
          <div class="block" data-fanyi="1">
            如果这个任务的挂起计数为零，返回此任务；否则将其挂起计数并返回 
           <code>null</code>。 
          </div> </td> 
        </tr> 
        <tr id="i7" class="rowColor"> 
         <td class="colFirst"><code><a href="../../../java/util/concurrent/CountedCompleter.html" title="class in java.util.concurrent">CountedCompleter</a>&lt;?&gt;</code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/CountedCompleter.html#getCompleter--">getCompleter</a></span>()</code> 
          <div class="block" data-fanyi="1">
            返回此任务的构造函数建立完成，或 
           <code>null</code>如果没有。 
          </div> </td> 
        </tr> 
        <tr id="i8" class="altColor"> 
         <td class="colFirst"><code>int</code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/CountedCompleter.html#getPendingCount--">getPendingCount</a></span>()</code> 
          <div class="block" data-fanyi="1">
            返回当前挂起的计数。 
          </div> </td> 
        </tr> 
        <tr id="i9" class="rowColor"> 
         <td class="colFirst"><code><a href="../../../java/util/concurrent/CountedCompleter.html" title="type parameter in CountedCompleter">T</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/CountedCompleter.html#getRawResult--">getRawResult</a></span>()</code> 
          <div class="block" data-fanyi="1">
            返回计算的结果。 
          </div> </td> 
        </tr> 
        <tr id="i10" class="altColor"> 
         <td class="colFirst"><code><a href="../../../java/util/concurrent/CountedCompleter.html" title="class in java.util.concurrent">CountedCompleter</a>&lt;?&gt;</code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/CountedCompleter.html#getRoot--">getRoot</a></span>()</code> 
          <div class="block" data-fanyi="1">
            返回当前计算的根；即，这个任务没有完成，其他的全是根。 
          </div> </td> 
        </tr> 
        <tr id="i11" class="rowColor"> 
         <td class="colFirst"><code>void</code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/CountedCompleter.html#helpComplete-int-">helpComplete</a></span>(int&nbsp;maxTasks)</code> 
          <div class="block" data-fanyi="1">
            如果这个任务没有完成，尝试过程最多给其他未处理的任务，这个任务是完成路径数，如果是已知的存在。 
          </div> </td> 
        </tr> 
        <tr id="i12" class="altColor"> 
         <td class="colFirst"><code><a href="../../../java/util/concurrent/CountedCompleter.html" title="class in java.util.concurrent">CountedCompleter</a>&lt;?&gt;</code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/CountedCompleter.html#nextComplete--">nextComplete</a></span>()</code> 
          <div class="block" data-fanyi="1">
            如果这个任务没有完成，调用和返回 
           <code>null</code> 
           <a href="../../../java/util/concurrent/ForkJoinTask.html#quietlyComplete--"><code>ForkJoinTask.quietlyComplete()</code></a>。 
          </div> </td> 
        </tr> 
        <tr id="i13" class="rowColor"> 
         <td class="colFirst"><code>void</code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/CountedCompleter.html#onCompletion-java.util.concurrent.CountedCompleter-">onCompletion</a></span>(<a href="../../../java/util/concurrent/CountedCompleter.html" title="class in java.util.concurrent">CountedCompleter</a>&lt;?&gt;&nbsp;caller)</code> 
          <div class="block" data-fanyi="1">
            执行一个动作时，方法调用 
           <a href="../../../java/util/concurrent/CountedCompleter.html#tryComplete--"><code>tryComplete()</code></a>待计数为零，或当无条件 
           <a href="../../../java/util/concurrent/CountedCompleter.html#complete-T-"><code>complete(T)</code></a>调用方法。 
          </div> </td> 
        </tr> 
        <tr id="i14" class="altColor"> 
         <td class="colFirst"><code>boolean</code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/CountedCompleter.html#onExceptionalCompletion-java.lang.Throwable-java.util.concurrent.CountedCompleter-">onExceptionalCompletion</a></span>(<a href="../../../java/lang/Throwable.html" title="class in java.lang">Throwable</a>&nbsp;ex, <a href="../../../java/util/concurrent/CountedCompleter.html" title="class in java.util.concurrent">CountedCompleter</a>&lt;?&gt;&nbsp;caller)</code> 
          <div class="block" data-fanyi="1">
            执行一个动作时 
           <a href="../../../java/util/concurrent/ForkJoinTask.html#completeExceptionally-java.lang.Throwable-"><code>ForkJoinTask.completeExceptionally(Throwable)</code></a>调用方法或方法 
           <a href="../../../java/util/concurrent/CountedCompleter.html#compute--"><code>compute()</code></a>抛出一个异常，这工作已经不能正常完成，否则。 
          </div> </td> 
        </tr> 
        <tr id="i15" class="rowColor"> 
         <td class="colFirst"><code>void</code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/CountedCompleter.html#propagateCompletion--">propagateCompletion</a></span>()</code> 
          <div class="block" data-fanyi="1">
            相当于 
           <a href="../../../java/util/concurrent/CountedCompleter.html#tryComplete--"><code>tryComplete()</code></a>但不调用 
           <a href="../../../java/util/concurrent/CountedCompleter.html#onCompletion-java.util.concurrent.CountedCompleter-"><code>onCompletion(CountedCompleter)</code></a>沿完成路径：如果挂起计数为零，递减计数；否则，同样试图完成这一任务的完成，如果存在的话，其他的是这个任务完成。 
          </div> </td> 
        </tr> 
        <tr id="i16" class="altColor"> 
         <td class="colFirst"><code>void</code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/CountedCompleter.html#quietlyCompleteRoot--">quietlyCompleteRoot</a></span>()</code> 
          <div class="block" data-fanyi="1">
            相当于 
           <code>getRoot().quietlyComplete()</code>。 
          </div> </td> 
        </tr> 
        <tr id="i17" class="rowColor"> 
         <td class="colFirst"><code>void</code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/CountedCompleter.html#setPendingCount-int-">setPendingCount</a></span>(int&nbsp;count)</code> 
          <div class="block" data-fanyi="1">
            将挂起的计数设置为给定的值。 
          </div> </td> 
        </tr> 
        <tr id="i18" class="altColor"> 
         <td class="colFirst"><code>protected void</code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/CountedCompleter.html#setRawResult-T-">setRawResult</a></span>(<a href="../../../java/util/concurrent/CountedCompleter.html" title="type parameter in CountedCompleter">T</a>&nbsp;t)</code> 
          <div class="block" data-fanyi="1">
            一，轴承countedcompleters可以用来帮助保持结果数据的方法。 
          </div> </td> 
        </tr> 
        <tr id="i19" class="rowColor"> 
         <td class="colFirst"><code>void</code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/util/concurrent/CountedCompleter.html#tryComplete--">tryComplete</a></span>()</code> 
          <div class="block" data-fanyi="1">
            如果挂起计数为零，递减计数；否则调用 
           <a href="../../../java/util/concurrent/CountedCompleter.html#onCompletion-java.util.concurrent.CountedCompleter-"><code>onCompletion(CountedCompleter)</code></a>然后同样试图完成这一任务的完成，如果存在的话，其他的是这个任务完成。 
          </div> </td> 
        </tr> 
       </tbody> 
      </table> 
      <ul class="blockList"> 
       <li class="blockList"><a name="methods.inherited.from.class.java.util.concurrent.ForkJoinTask"> 
         <!--   --> </a> <h3>Methods inherited from class&nbsp;java.util.concurrent.<a href="../../../java/util/concurrent/ForkJoinTask.html" title="class in java.util.concurrent">ForkJoinTask</a></h3> <code><a href="../../../java/util/concurrent/ForkJoinTask.html#adapt-java.util.concurrent.Callable-">adapt</a>, <a href="../../../java/util/concurrent/ForkJoinTask.html#adapt-java.lang.Runnable-">adapt</a>, <a href="../../../java/util/concurrent/ForkJoinTask.html#adapt-java.lang.Runnable-T-">adapt</a>, <a href="../../../java/util/concurrent/ForkJoinTask.html#cancel-boolean-">cancel</a>, <a href="../../../java/util/concurrent/ForkJoinTask.html#compareAndSetForkJoinTaskTag-short-short-">compareAndSetForkJoinTaskTag</a>, <a href="../../../java/util/concurrent/ForkJoinTask.html#completeExceptionally-java.lang.Throwable-">completeExceptionally</a>, <a href="../../../java/util/concurrent/ForkJoinTask.html#fork--">fork</a>, <a href="../../../java/util/concurrent/ForkJoinTask.html#get--">get</a>, <a href="../../../java/util/concurrent/ForkJoinTask.html#get-long-java.util.concurrent.TimeUnit-">get</a>, <a href="../../../java/util/concurrent/ForkJoinTask.html#getException--">getException</a>, <a href="../../../java/util/concurrent/ForkJoinTask.html#getForkJoinTaskTag--">getForkJoinTaskTag</a>, <a href="../../../java/util/concurrent/ForkJoinTask.html#getPool--">getPool</a>, <a href="../../../java/util/concurrent/ForkJoinTask.html#getQueuedTaskCount--">getQueuedTaskCount</a>, <a href="../../../java/util/concurrent/ForkJoinTask.html#getSurplusQueuedTaskCount--">getSurplusQueuedTaskCount</a>, <a href="../../../java/util/concurrent/ForkJoinTask.html#helpQuiesce--">helpQuiesce</a>, <a href="../../../java/util/concurrent/ForkJoinTask.html#inForkJoinPool--">inForkJoinPool</a>, <a href="../../../java/util/concurrent/ForkJoinTask.html#invoke--">invoke</a>, <a href="../../../java/util/concurrent/ForkJoinTask.html#invokeAll-java.util.Collection-">invokeAll</a>, <a href="../../../java/util/concurrent/ForkJoinTask.html#invokeAll-java.util.concurrent.ForkJoinTask...-">invokeAll</a>, <a href="../../../java/util/concurrent/ForkJoinTask.html#invokeAll-java.util.concurrent.ForkJoinTask-java.util.concurrent.ForkJoinTask-">invokeAll</a>, <a href="../../../java/util/concurrent/ForkJoinTask.html#isCancelled--">isCancelled</a>, <a href="../../../java/util/concurrent/ForkJoinTask.html#isCompletedAbnormally--">isCompletedAbnormally</a>, <a href="../../../java/util/concurrent/ForkJoinTask.html#isCompletedNormally--">isCompletedNormally</a>, <a href="../../../java/util/concurrent/ForkJoinTask.html#isDone--">isDone</a>, <a href="../../../java/util/concurrent/ForkJoinTask.html#join--">join</a>, <a href="../../../java/util/concurrent/ForkJoinTask.html#peekNextLocalTask--">peekNextLocalTask</a>, <a href="../../../java/util/concurrent/ForkJoinTask.html#pollNextLocalTask--">pollNextLocalTask</a>, <a href="../../../java/util/concurrent/ForkJoinTask.html#pollTask--">pollTask</a>, <a href="../../../java/util/concurrent/ForkJoinTask.html#quietlyComplete--">quietlyComplete</a>, <a href="../../../java/util/concurrent/ForkJoinTask.html#quietlyInvoke--">quietlyInvoke</a>, <a href="../../../java/util/concurrent/ForkJoinTask.html#quietlyJoin--">quietlyJoin</a>, <a href="../../../java/util/concurrent/ForkJoinTask.html#reinitialize--">reinitialize</a>, <a href="../../../java/util/concurrent/ForkJoinTask.html#setForkJoinTaskTag-short-">setForkJoinTaskTag</a>, <a href="../../../java/util/concurrent/ForkJoinTask.html#tryUnfork--">tryUnfork</a></code></li> 
      </ul> 
      <ul class="blockList"> 
       <li class="blockList"><a name="methods.inherited.from.class.java.lang.Object"> 
         <!--   --> </a> <h3>Methods inherited from class&nbsp;java.lang.<a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></h3> <code><a href="../../../java/lang/Object.html#clone--">clone</a>, <a href="../../../java/lang/Object.html#equals-java.lang.Object-">equals</a>, <a href="../../../java/lang/Object.html#finalize--">finalize</a>, <a href="../../../java/lang/Object.html#getClass--">getClass</a>, <a href="../../../java/lang/Object.html#hashCode--">hashCode</a>, <a href="../../../java/lang/Object.html#notify--">notify</a>, <a href="../../../java/lang/Object.html#notifyAll--">notifyAll</a>, <a href="../../../java/lang/Object.html#toString--">toString</a>, <a href="../../../java/lang/Object.html#wait--">wait</a>, <a href="../../../java/lang/Object.html#wait-long-">wait</a>, <a href="../../../java/lang/Object.html#wait-long-int-">wait</a></code></li> 
      </ul> </li> 
    </ul> </li> 
  </ul> 
 </div> 
 <div class="details"> 
  <ul class="blockList"> 
   <li class="blockList"> 
    <!-- ========= CONSTRUCTOR DETAIL ======== --> 
    <ul class="blockList"> 
     <li class="blockList"><a name="constructor.detail"> 
       <!--   --> </a> <h3>Constructor Detail</h3> <a name="CountedCompleter-java.util.concurrent.CountedCompleter-int-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>CountedCompleter</h4> <pre>protected&nbsp;CountedCompleter(<a href="../../../java/util/concurrent/CountedCompleter.html" title="class in java.util.concurrent">CountedCompleter</a>&lt;?&gt;&nbsp;completer,
                           int&nbsp;initialPendingCount)</pre> 
        <div class="block" data-fanyi="1">
          创建具有给定的完成和初始待统计的新countedcompleter。 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>completer</code> -这个任务的完成者，或 
          <code>null</code>如果没有 
         </dd> 
         <dd data-fanyi="1"> 
          <code>initialPendingCount</code> -初始挂起计数 
         </dd> 
        </dl> </li> 
      </ul> <a name="CountedCompleter-java.util.concurrent.CountedCompleter-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>CountedCompleter</h4> <pre>protected&nbsp;CountedCompleter(<a href="../../../java/util/concurrent/CountedCompleter.html" title="class in java.util.concurrent">CountedCompleter</a>&lt;?&gt;&nbsp;completer)</pre> 
        <div class="block" data-fanyi="1">
          创建具有给定的完成和一个初始挂起计数零的一个新countedcompleter。 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>completer</code> -这个任务的完成者，或 
          <code>null</code>如果没有 
         </dd> 
        </dl> </li> 
      </ul> <a name="CountedCompleter--"> 
       <!--   --> </a> 
      <ul class="blockListLast"> 
       <li class="blockList"> <h4>CountedCompleter</h4> <pre>protected&nbsp;CountedCompleter()</pre> 
        <div class="block" data-fanyi="1">
          创造没有完成和初始挂起计数零的一个新countedcompleter。 
        </div> </li> 
      </ul> </li> 
    </ul> 
    <!-- ============ METHOD DETAIL ========== --> 
    <ul class="blockList"> 
     <li class="blockList"><a name="method.detail"> 
       <!--   --> </a> <h3>方法详细信息</h3> <a name="compute--"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>compute</h4> <pre>public abstract&nbsp;void&nbsp;compute()</pre> 
        <div class="block" data-fanyi="1">
          此任务执行的主要计算。 
        </div> </li> 
      </ul> <a name="onCompletion-java.util.concurrent.CountedCompleter-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>onCompletion</h4> <pre>public&nbsp;void&nbsp;onCompletion(<a href="../../../java/util/concurrent/CountedCompleter.html" title="class in java.util.concurrent">CountedCompleter</a>&lt;?&gt;&nbsp;caller)</pre> 
        <div class="block" data-fanyi="1">
          执行一个动作时，方法调用 
         <a href="../../../java/util/concurrent/CountedCompleter.html#tryComplete--"><code>tryComplete()</code></a>待计数为零，或当无条件 
         <a href="../../../java/util/concurrent/CountedCompleter.html#complete-T-"><code>complete(T)</code></a>调用方法。默认情况下，此方法不做任何事。您可以通过检查给定来电者参数的身份来区分情况。如果不等于 
         <code>this</code>，那么它是一个典型的任务，可能包含的结果（和/或链接到其他结果）相结合。 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>caller</code> -任务调用这个方法（这可能是这个任务本身） 
         </dd> 
        </dl> </li> 
      </ul> <a name="onExceptionalCompletion-java.lang.Throwable-java.util.concurrent.CountedCompleter-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>onExceptionalCompletion</h4> <pre>public&nbsp;boolean&nbsp;onExceptionalCompletion(<a href="../../../java/lang/Throwable.html" title="class in java.lang">Throwable</a>&nbsp;ex,
                                       <a href="../../../java/util/concurrent/CountedCompleter.html" title="class in java.util.concurrent">CountedCompleter</a>&lt;?&gt;&nbsp;caller)</pre> 
        <div class="block" data-fanyi="1">
          执行一个动作时 
         <a href="../../../java/util/concurrent/ForkJoinTask.html#completeExceptionally-java.lang.Throwable-"><code>ForkJoinTask.completeExceptionally(Throwable)</code></a>调用方法或方法 
         <a href="../../../java/util/concurrent/CountedCompleter.html#compute--"><code>compute()</code></a>抛出一个异常，这工作已经不能正常完成，否则。在进入这个方法，这个任务 
         <a href="../../../java/util/concurrent/ForkJoinTask.html#isCompletedAbnormally--"><code>ForkJoinTask.isCompletedAbnormally()</code></a>。此方法的返回值控制进一步传播：如果 
         <code>true</code>这任务已经完成，没有完成，那全是同时完成的异常，这一异常者。此方法的默认实现不返回 
         <code>true</code>除外。 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>ex</code> -例外 
         </dd> 
         <dd data-fanyi="1"> 
          <code>caller</code> -任务调用这个方法（这可能是这个任务本身） 
         </dd> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           如果这 
          <code>true</code>例外应传播这项任务的完成，如果存在 
         </dd> 
        </dl> </li> 
      </ul> <a name="getCompleter--"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>getCompleter</h4> <pre>public final&nbsp;<a href="../../../java/util/concurrent/CountedCompleter.html" title="class in java.util.concurrent">CountedCompleter</a>&lt;?&gt;&nbsp;getCompleter()</pre> 
        <div class="block" data-fanyi="1">
          返回此任务的构造函数建立完成，或 
         <code>null</code>如果没有。 
        </div> 
        <dl> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           更完全的 
         </dd> 
        </dl> </li> 
      </ul> <a name="getPendingCount--"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>getPendingCount</h4> <pre>public final&nbsp;int&nbsp;getPendingCount()</pre> 
        <div class="block" data-fanyi="1">
          返回当前挂起的计数。 
        </div> 
        <dl> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           当前挂起计数 
         </dd> 
        </dl> </li> 
      </ul> <a name="setPendingCount-int-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>setPendingCount</h4> <pre>public final&nbsp;void&nbsp;setPendingCount(int&nbsp;count)</pre> 
        <div class="block" data-fanyi="1">
          将挂起的计数设置为给定的值。 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>count</code> -伯爵 
         </dd> 
        </dl> </li> 
      </ul> <a name="addToPendingCount-int-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>addToPendingCount</h4> <pre>public final&nbsp;void&nbsp;addToPendingCount(int&nbsp;delta)</pre> 
        <div class="block" data-fanyi="1">
          添加（原子）给定值挂起计数。 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>delta</code> -价值增加 
         </dd> 
        </dl> </li> 
      </ul> <a name="compareAndSetPendingCount-int-int-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>compareAndSetPendingCount</h4> <pre>public final&nbsp;boolean&nbsp;compareAndSetPendingCount(int&nbsp;expected,
                                               int&nbsp;count)</pre> 
        <div class="block" data-fanyi="1">
          集（原子）挂起计数的计数只有目前是给定的期望值。 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>expected</code> -期望值 
         </dd> 
         <dd data-fanyi="1"> 
          <code>count</code> -新价值 
         </dd> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>true</code>如果成功 
         </dd> 
        </dl> </li> 
      </ul> <a name="decrementPendingCountUnlessZero--"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>decrementPendingCountUnlessZero</h4> <pre>public final&nbsp;int&nbsp;decrementPendingCountUnlessZero()</pre> 
        <div class="block" data-fanyi="1">
          如果挂起计数为零，（原子）减少它。 
        </div> 
        <dl> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           初始（undecremented）等待数着进入这个方法 
         </dd> 
        </dl> </li> 
      </ul> <a name="getRoot--"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>getRoot</h4> <pre>public final&nbsp;<a href="../../../java/util/concurrent/CountedCompleter.html" title="class in java.util.concurrent">CountedCompleter</a>&lt;?&gt;&nbsp;getRoot()</pre> 
        <div class="block" data-fanyi="1">
          返回当前计算的根；即，这个任务没有完成，其他的全是根。 
        </div> 
        <dl> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           当前计算的根 
         </dd> 
        </dl> </li> 
      </ul> <a name="tryComplete--"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>tryComplete</h4> <pre>public final&nbsp;void&nbsp;tryComplete()</pre> 
        <div class="block" data-fanyi="1">
          如果挂起计数为零，递减计数；否则调用 
         <a href="../../../java/util/concurrent/CountedCompleter.html#onCompletion-java.util.concurrent.CountedCompleter-"><code>onCompletion(CountedCompleter)</code></a>然后同样试图完成这一任务的完成，如果存在的话，其他的是这个任务完成。 
        </div> </li> 
      </ul> <a name="propagateCompletion--"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>propagateCompletion</h4> <pre>public final&nbsp;void&nbsp;propagateCompletion()</pre> 
        <div class="block" data-fanyi="1">
          相当于 
         <a href="../../../java/util/concurrent/CountedCompleter.html#tryComplete--"><code>tryComplete()</code></a>但不调用 
         <a href="../../../java/util/concurrent/CountedCompleter.html#onCompletion-java.util.concurrent.CountedCompleter-"><code>onCompletion(CountedCompleter)</code></a>沿完成路径：如果挂起计数为零，递减计数；否则，同样试图完成这一任务的完成，如果存在的话，其他的是这个任务完成。这种方法可能是有用的情况下 
         <code>onCompletion</code>不应该在哪里，或者不需要，被调用每个者在计算。 
        </div> </li> 
      </ul> <a name="complete-java.lang.Object-"> 
       <!--   --> </a><a name="complete-T-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>complete</h4> <pre>public&nbsp;void&nbsp;complete(<a href="../../../java/util/concurrent/CountedCompleter.html" title="type parameter in CountedCompleter">T</a>&nbsp;rawResult)</pre> 
        <div class="block" data-fanyi="1">
          无论在数量，调用 
         <a href="../../../java/util/concurrent/CountedCompleter.html#onCompletion-java.util.concurrent.CountedCompleter-"><code>onCompletion(CountedCompleter)</code></a>，标志着这项任务完成，进一步引发 
         <a href="../../../java/util/concurrent/CountedCompleter.html#tryComplete--"><code>tryComplete()</code></a>这个任务的完成，如果存在。给定的rawresult作为参数调用 
         <a href="../../../java/util/concurrent/CountedCompleter.html#onCompletion-java.util.concurrent.CountedCompleter-"><code>onCompletion(CountedCompleter)</code></a> 
         <a href="../../../java/util/concurrent/CountedCompleter.html#setRawResult-T-"><code>setRawResult(T)</code></a>或标记这个任务完成之前；它的价值才有意义 
         <code>setRawResult</code>类重写。此方法不修改挂起的计数。 
         <p data-fanyi="1">这种方法可能是有用的当强迫完成只要一有人（而不是所有）的几个子任务的结果。然而，在共同的（推荐）的案件中，<code>setRawResult</code>不重写，这种效果可以更简单地使用<code>quietlyCompleteRoot();</code>获得。</p> 
        </div> 
        <dl> 
         <dt> 
          <span class="overrideSpecifyLabel">重写：</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/util/concurrent/ForkJoinTask.html#complete-V-">complete</a></code>&nbsp;方法重写，继承类&nbsp; 
          <code><a href="../../../java/util/concurrent/ForkJoinTask.html" title="class in java.util.concurrent">ForkJoinTask</a>&lt;<a href="../../../java/util/concurrent/CountedCompleter.html" title="type parameter in CountedCompleter">T</a>&gt;</code> 
         </dd> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>rawResult</code> -原结果 
         </dd> 
        </dl> </li> 
      </ul> <a name="firstComplete--"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>firstComplete</h4> <pre>public final&nbsp;<a href="../../../java/util/concurrent/CountedCompleter.html" title="class in java.util.concurrent">CountedCompleter</a>&lt;?&gt;&nbsp;firstComplete()</pre> 
        <div class="block" data-fanyi="1">
          如果这个任务的挂起计数为零，返回此任务；否则将其挂起计数并返回 
         <code>null</code>。这种方法是设计用于完成遍历循环 
         <a href="../../../java/util/concurrent/CountedCompleter.html#nextComplete--"><code>nextComplete()</code></a>。 
        </div> 
        <dl> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           这个任务，如果等待计数为零，否则 
          <code>null</code> 
         </dd> 
        </dl> </li> 
      </ul> <a name="nextComplete--"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>nextComplete</h4> <pre>public final&nbsp;<a href="../../../java/util/concurrent/CountedCompleter.html" title="class in java.util.concurrent">CountedCompleter</a>&lt;?&gt;&nbsp;nextComplete()</pre> 
        <div class="block" data-fanyi="1">
          如果这个任务没有完成，调用和返回 
         <code>null</code> 
         <a href="../../../java/util/concurrent/ForkJoinTask.html#quietlyComplete--"><code>ForkJoinTask.quietlyComplete()</code></a>。或者，如果完整的申请数非零，减少待计数并返回 
         <code>null</code>。否则，返回去。这种方法可以作为一个同质的任务层次完成遍历循环部分： 
         <pre data-fanyi="1"><code>
 for (CountedCompleter&lt;?&gt; c = firstComplete();
      c != null;
      c = c.nextComplete()) {
   // ... process c ...
 }</code></pre> 
        </div> 
        <dl> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           如果没有完成，或 
          <code>null</code> 
         </dd> 
        </dl> </li> 
      </ul> <a name="quietlyCompleteRoot--"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>quietlyCompleteRoot</h4> <pre>public final&nbsp;void&nbsp;quietlyCompleteRoot()</pre> 
        <div class="block" data-fanyi="1">
          相当于 
         <code>getRoot().quietlyComplete()</code>。 
        </div> </li> 
      </ul> <a name="helpComplete-int-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>helpComplete</h4> <pre>public final&nbsp;void&nbsp;helpComplete(int&nbsp;maxTasks)</pre> 
        <div class="block" data-fanyi="1">
          如果这个任务没有完成，尝试过程最多给其他未处理的任务，这个任务是完成路径数，如果是已知的存在。 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>maxTasks</code> -任务的最大数目的过程。如果小于或等于零，则没有处理任务。 
         </dd> 
        </dl> </li> 
      </ul> <a name="exec--"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>exec</h4> <pre>protected final&nbsp;boolean&nbsp;exec()</pre> 
        <div class="block" data-fanyi="1">
          贯彻执行公约countedcompleters。 
        </div> 
        <dl> 
         <dt> 
          <span class="overrideSpecifyLabel">Specified by:</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/util/concurrent/ForkJoinTask.html#exec--">exec</a></code>&nbsp;方法重写，继承类&nbsp; 
          <code><a href="../../../java/util/concurrent/ForkJoinTask.html" title="class in java.util.concurrent">ForkJoinTask</a>&lt;<a href="../../../java/util/concurrent/CountedCompleter.html" title="type parameter in CountedCompleter">T</a>&gt;</code> 
         </dd> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>true</code>如果这个任务已经完成正常 
         </dd> 
        </dl> </li> 
      </ul> <a name="getRawResult--"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>getRawResult</h4> <pre>public&nbsp;<a href="../../../java/util/concurrent/CountedCompleter.html" title="type parameter in CountedCompleter">T</a>&nbsp;getRawResult()</pre> 
        <div class="block" data-fanyi="1">
          返回计算的结果。默认情况下，返回 
         <code>null</code>，这是适当的 
         <code>Void</code>行动，但在其他情况下，需要重写，几乎总是返回一个字段或函数的一个字段保存结果完成后。 
        </div> 
        <dl> 
         <dt> 
          <span class="overrideSpecifyLabel">Specified by:</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/util/concurrent/ForkJoinTask.html#getRawResult--">getRawResult</a></code>&nbsp;方法重写，继承类&nbsp; 
          <code><a href="../../../java/util/concurrent/ForkJoinTask.html" title="class in java.util.concurrent">ForkJoinTask</a>&lt;<a href="../../../java/util/concurrent/CountedCompleter.html" title="type parameter in CountedCompleter">T</a>&gt;</code> 
         </dd> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           计算的结果 
         </dd> 
        </dl> </li> 
      </ul> <a name="setRawResult-java.lang.Object-"> 
       <!--   --> </a><a name="setRawResult-T-"> 
       <!--   --> </a> 
      <ul class="blockListLast"> 
       <li class="blockList"> <h4>setRawResult</h4> <pre>protected&nbsp;void&nbsp;setRawResult(<a href="../../../java/util/concurrent/CountedCompleter.html" title="type parameter in CountedCompleter">T</a>&nbsp;t)</pre> 
        <div class="block" data-fanyi="1">
          一，轴承countedcompleters可以用来帮助保持结果数据的方法。默认情况下，什么都不做。覆盖是不推荐。然而，如果重写此方法以更新现有对象或领域，那么它必须是线程安全的定义。 
        </div> 
        <dl> 
         <dt> 
          <span class="overrideSpecifyLabel">Specified by:</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/util/concurrent/ForkJoinTask.html#setRawResult-V-">setRawResult</a></code>&nbsp;方法重写，继承类&nbsp; 
          <code><a href="../../../java/util/concurrent/ForkJoinTask.html" title="class in java.util.concurrent">ForkJoinTask</a>&lt;<a href="../../../java/util/concurrent/CountedCompleter.html" title="type parameter in CountedCompleter">T</a>&gt;</code> 
         </dd> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>t</code> -价值 
         </dd> 
        </dl> </li> 
      </ul> </li> 
    </ul> </li> 
  </ul> 
 </div> 
</div> 
<!-- ========= END OF CLASS DATA ========= --> 
<!-- ======= START OF BOTTOM NAVBAR ====== --> 
<div class="bottomNav"> 
 <a name="navbar.bottom"> 
  <!--   --> </a> 
 <div class="skipNav"> 
  <a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a> 
 </div> 
 <a name="navbar.bottom.firstrow"> 
  <!--   --> </a> 
 <ul class="navList" title="Navigation"> 
  <li><a href="../../../overview-summary.html">概述</a></li> 
  <li><a href="package-summary.html">软件包</a></li> 
  <li class="navBarCell1Rev">类</li> 
  <li><a href="class-use/CountedCompleter.html">使用</a></li> 
  <li><a href="package-tree.html">树</a></li> 
  <li><a href="../../../deprecated-list.html">已过时的</a></li> 
  <li><a href="../../../index-files/index-1.html">索引</a></li> 
  <li><a href="../../../help-doc.html">帮助</a></li> 
 </ul> 
 <div class="aboutLanguage"> 
  <strong>Java™&nbsp;Platform<br>Standard&nbsp;Ed.&nbsp;8</strong> 
 </div> 
</div> 
<div class="subNav"> 
 <ul class="navList"> 
  <li><a href="../../../java/util/concurrent/CountDownLatch.html" title="class in java.util.concurrent"><span class="typeNameLink">上一个</span></a></li> 
  <li><a href="../../../java/util/concurrent/CyclicBarrier.html" title="class in java.util.concurrent"><span class="typeNameLink">下一个</span></a></li> 
 </ul> 
 <ul class="navList"> 
  <li><a href="../../../index.html?java/util/concurrent/CountedCompleter.html" target="_top">框架</a></li> 
  <li><a href="CountedCompleter.html" target="_top">无框架</a></li> 
 </ul> 
 <ul class="navList" id="allclasses_navbar_bottom"> 
  <li><a href="../../../allclasses-noframe.html">所有类</a></li> 
 </ul> 
 <div> 
  <script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script> 
 </div> 
 <div> 
  <ul class="subNavList"> 
   <li>概要：</li> 
   <li>嵌套</li> 
   <li>字段</li> 
   <li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li> 
   <li><a href="#method.summary">方法</a></li> 
  </ul> 
  <ul class="subNavList"> 
   <li>详细信息：</li> 
   <li>字段</li> 
   <li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li> 
   <li><a href="#method.detail">方法</a></li> 
  </ul> 
 </div> 
 <a name="skip.navbar.bottom"> 
  <!--   --> </a> 
</div> 
<!-- ======== END OF BOTTOM NAVBAR ======= --> 
<p class="legalCopy"><small><font size="-1"> <a href="http://bugreport.sun.com/bugreport/">Submit a bug or feature</a> <br>For further API reference and developer documentation, see <a href="http://download.oracle.com/javase/8/docs/index.html" target="_blank">Java SE Documentation</a>. That documentation contains more detailed, developer-targeted descriptions, with conceptual overviews, definitions of terms, workarounds, and working code examples.<br> Copyright © 1993, 2014, Oracle and/or its affiliates. All rights reserved. </font></small> </p> 
<div id="adDiv"> 


 <div></div> 
</div> 
<p></p>