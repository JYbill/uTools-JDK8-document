<!-- NewPage -->   
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<!-- Generated by javadoc (1.8.0) on Tue Mar 04 03:13:28 PST 2014 --> 
<title>java.util.stream (Java Platform SE 8 )</title> 
<meta name="date" content="2014-03-04"> 
<meta name="keywords" content="java.util.stream package"> 
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style"> 
<script type="text/javascript" src="../../../script.js"></script> 
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="java.util.stream (Java Platform SE 8 )";
        }
    }
    catch(err) {
    }
//-->
</script> 
<noscript>
  &lt;div&gt; JavaScript is disabled on your browser. 
</noscript> 
<!-- ========= START OF TOP NAVBAR ======= -->   
<div class="topNav"> 
 <a name="navbar.top"> 
  <!--   --> </a> 
 <div class="skipNav"> 
  <a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a> 
 </div> 
 <a name="navbar.top.firstrow"> 
  <!--   --> </a> 
 <ul class="navList" title="Navigation"> 
  <li><a href="../../../overview-summary.html">概述</a></li> 
  <li class="navBarCell1Rev">软件包</li> 
  <li>类</li> 
  <li><a href="package-use.html">使用</a></li> 
  <li><a href="package-tree.html">树</a></li> 
  <li><a href="../../../deprecated-list.html">已过时的</a></li> 
  <li><a href="../../../index-files/index-1.html">索引</a></li> 
  <li><a href="../../../help-doc.html">帮助</a></li> 
 </ul> 
 <div class="aboutLanguage"> 
  <strong>Java™&nbsp;Platform<br>Standard&nbsp;Ed.&nbsp;8</strong> 
 </div> 
</div> 
<div class="subNav"> 
 <ul class="navList"> 
  <li><a href="../../../java/util/spi/compact2-package-summary.html">Prev&nbsp;Package</a></li> 
  <li><a href="../../../java/util/zip/compact2-package-summary.html">Next&nbsp;Package</a></li> 
 </ul> 
 <ul class="navList"> 
  <li><a href="../../../index.html?java/util/stream/compact2-package-summary.html" target="_top">框架</a></li> 
  <li><a href="compact2-package-summary.html" target="_top">无框架</a></li> 
 </ul> 
 <ul class="navList" id="allclasses_navbar_top"> 
  <li><a href="../../../allclasses-noframe.html">所有类</a></li> 
 </ul> 
 <div> 
  <script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script> 
 </div> 
 <a name="skip.navbar.top"> 
  <!--   --> </a> 
</div> 
<!-- ========= END OF TOP NAVBAR ========= --> 
<div class="header"> 
 <div class="subTitle">
   compact2 
 </div> 
 <h1 title="Package" class="title">Package&nbsp;java.util.stream</h1> 
 <div class="docSummary"> 
  <div class="block" data-fanyi="1">
    类，以支持元素流上的功能样式操作，如Map减少集合上的转换。 
  </div> 
 </div> 
 <p>See:&nbsp;<a href="#package.description">描述</a></p> 
</div> 
<div class="contentContainer"> 
 <ul class="blockList"> 
  <li class="blockList"> 
   <table class="typeSummary" border="0" cellpadding="3" cellspacing="0" summary="Interface Summary table, listing interfaces, and an explanation"> 
    <caption> 
     <span>接口摘要</span> 
     <span class="tabEnd">&nbsp;</span> 
    </caption> 
    <tbody> 
     <tr> 
      <th class="colFirst" scope="col">接口</th> 
      <th class="colLast" scope="col">描述</th> 
     </tr> 
    </tbody> 
    <tbody> 
     <tr class="altColor"> 
      <td class="colFirst"><a href="../../../java/util/stream/BaseStream.html" title="interface in java.util.stream">BaseStream</a>&lt;T,S extends <a href="../../../java/util/stream/BaseStream.html" title="interface in java.util.stream">BaseStream</a>&lt;T,S&gt;&gt;</td> 
      <td class="colLast"> 
       <div class="block" data-fanyi="1">
         用于流的基本接口，它是支持顺序和并行聚合操作的元素的序列。 
       </div> </td> 
     </tr> 
     <tr class="rowColor"> 
      <td class="colFirst"><a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream">Collector</a>&lt;T,A,R&gt;</td> 
      <td class="colLast"> 
       <div class="block" data-fanyi="1">
         一个 
        <a href="../../../java/util/stream/package-summary.html#Reduction">mutable reduction operation</a>积累输入元素到一个可变的结果的容器，可随意变换积累的结果到最后表示，毕竟输入元素已被处理。 
       </div> </td> 
     </tr> 
     <tr class="altColor"> 
      <td class="colFirst"><a href="../../../java/util/stream/DoubleStream.html" title="interface in java.util.stream">DoubleStream</a></td> 
      <td class="colLast"> 
       <div class="block" data-fanyi="1">
         支持序列和并行聚合操作的原始双值元素序列。 
       </div> </td> 
     </tr> 
     <tr class="rowColor"> 
      <td class="colFirst"><a href="../../../java/util/stream/DoubleStream.Builder.html" title="interface in java.util.stream">DoubleStream.Builder</a></td> 
      <td class="colLast"> 
       <div class="block" data-fanyi="1">
         一 
        <code>DoubleStream</code>易变的建设者。 
       </div> </td> 
     </tr> 
     <tr class="altColor"> 
      <td class="colFirst"><a href="../../../java/util/stream/IntStream.html" title="interface in java.util.stream">IntStream</a></td> 
      <td class="colLast"> 
       <div class="block" data-fanyi="1">
         原始序列的int值元素支持串行和并行的聚合操作。 
       </div> </td> 
     </tr> 
     <tr class="rowColor"> 
      <td class="colFirst"><a href="../../../java/util/stream/IntStream.Builder.html" title="interface in java.util.stream">IntStream.Builder</a></td> 
      <td class="colLast"> 
       <div class="block" data-fanyi="1">
         一个 
        <code>IntStream</code>易变的建设者。 
       </div> </td> 
     </tr> 
     <tr class="altColor"> 
      <td class="colFirst"><a href="../../../java/util/stream/LongStream.html" title="interface in java.util.stream">LongStream</a></td> 
      <td class="colLast"> 
       <div class="block" data-fanyi="1">
         支持序列和并行聚合操作的原始长值元素序列。 
       </div> </td> 
     </tr> 
     <tr class="rowColor"> 
      <td class="colFirst"><a href="../../../java/util/stream/LongStream.Builder.html" title="interface in java.util.stream">LongStream.Builder</a></td> 
      <td class="colLast"> 
       <div class="block" data-fanyi="1">
         一 
        <code>LongStream</code>易变的建设者。 
       </div> </td> 
     </tr> 
     <tr class="altColor"> 
      <td class="colFirst"><a href="../../../java/util/stream/Stream.html" title="interface in java.util.stream">Stream</a>&lt;T&gt;</td> 
      <td class="colLast"> 
       <div class="block" data-fanyi="1">
         支持顺序和并行聚合操作的元素序列。 
       </div> </td> 
     </tr> 
     <tr class="rowColor"> 
      <td class="colFirst"><a href="../../../java/util/stream/Stream.Builder.html" title="interface in java.util.stream">Stream.Builder</a>&lt;T&gt;</td> 
      <td class="colLast"> 
       <div class="block" data-fanyi="1">
         一 
        <code>Stream</code>易变的建设者。 
       </div> </td> 
     </tr> 
    </tbody> 
   </table> </li> 
  <li class="blockList"> 
   <table class="typeSummary" border="0" cellpadding="3" cellspacing="0" summary="Class Summary table, listing classes, and an explanation"> 
    <caption> 
     <span>类摘要</span> 
     <span class="tabEnd">&nbsp;</span> 
    </caption> 
    <tbody> 
     <tr> 
      <th class="colFirst" scope="col">类</th> 
      <th class="colLast" scope="col">描述</th> 
     </tr> 
    </tbody> 
    <tbody> 
     <tr class="altColor"> 
      <td class="colFirst"><a href="../../../java/util/stream/Collectors.html" title="class in java.util.stream">Collectors</a></td> 
      <td class="colLast"> 
       <div class="block" data-fanyi="1">
         实现 
        <a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream"><code>Collector</code></a>实现各种有用的还原操作，如积累元素的集合，总结元素根据不同的标准，等等。 
       </div> </td> 
     </tr> 
     <tr class="rowColor"> 
      <td class="colFirst"><a href="../../../java/util/stream/StreamSupport.html" title="class in java.util.stream">StreamSupport</a></td> 
      <td class="colLast"> 
       <div class="block" data-fanyi="1">
         用于创建和操作流的低电平实用方法。 
       </div> </td> 
     </tr> 
    </tbody> 
   </table> </li> 
  <li class="blockList"> 
   <table class="typeSummary" border="0" cellpadding="3" cellspacing="0" summary="Enum Summary table, listing enums, and an explanation"> 
    <caption> 
     <span>枚举摘要</span> 
     <span class="tabEnd">&nbsp;</span> 
    </caption> 
    <tbody> 
     <tr> 
      <th class="colFirst" scope="col">Enum</th> 
      <th class="colLast" scope="col">描述</th> 
     </tr> 
    </tbody> 
    <tbody> 
     <tr class="altColor"> 
      <td class="colFirst"><a href="../../../java/util/stream/Collector.Characteristics.html" title="enum in java.util.stream">Collector.Characteristics</a></td> 
      <td class="colLast"> 
       <div class="block" data-fanyi="1">
         特征表明一个 
        <code>Collector</code>性能，可用于优化还原的实现。 
       </div> </td> 
     </tr> 
    </tbody> 
   </table> </li> 
 </ul> 
 <a name="package.description"> 
  <!--   --> </a> 
 <h2 title="Package java.util.stream Description">Package java.util.stream Description</h2> 
 <div class="block" data-fanyi="1">
   类，以支持元素流上的功能样式操作，如Map减少集合上的转换。例如： 
  <pre data-fanyi="1"><code>
     int sum = widgets.stream()
                      .filter(b -&gt; b.getColor() == RED)
                      .mapToInt(b -&gt; b.getWeight())
                      .sum();
 </code></pre> 
  <p data-fanyi="1">这里我们使用<code>widgets</code>，一<code>Collection&lt;Widget&gt;</code>，作为一个流源，然后进行过滤图减少流获得的红色小部件的重量的总和。（求和是一个<a href="../../../java/util/stream/package-summary.html#Reduction">reduction</a>操作。例）</p> 
  <p data-fanyi="1">在这个包中引入的关键抽象是流。这类<a href="../../../java/util/stream/Stream.html" title="interface in java.util.stream"><code>Stream</code></a>，<a href="../../../java/util/stream/IntStream.html" title="interface in java.util.stream"><code>IntStream</code></a>，<a href="../../../java/util/stream/LongStream.html" title="interface in java.util.stream"><code>LongStream</code></a>，和<a href="../../../java/util/stream/DoubleStream.html" title="interface in java.util.stream"><code>DoubleStream</code></a>是流对象和原始<code>int</code>，<code>long</code>和<code>double</code>类型。流从不同的集合在几个方面：</p> 
  <ul data-fanyi="1"> 
   <li data-fanyi="1">没有存储。数据流不是存储元素的数据结构；相反，它将元素从数据结构、数组、生成器函数或I / O通道等源传递到计算操作的管道中传递。</li> 
   <li data-fanyi="1">功能性。一个流上的操作产生一个结果，但不修改它的源。例如，过滤收集得到的<code>Stream</code>产生一个新的<code>Stream</code>没有过滤的元素，而不是从源集合中移除元素。</li> 
   <li data-fanyi="1">懒惰寻找。许多流操作，如过滤、映射，或去除重复，可以懒洋洋地，暴露的机会，优化。例如，“发现第一<code>String</code>连续三个元音”不需要检查所有输入的字符串。流的操作分为中级（<code>Stream</code>-producing）业务和终端（价值或副作用产生）的操作。中间操作总是懒惰的。</li> 
   <li data-fanyi="1">可能是无界的。虽然集合有一个有限的大小，流不需要。短路手术如<code>limit(n)</code>或<code>findFirst()</code>可以允许无限流计算在有限的时间内完成。</li> 
   <li data-fanyi="1">消费品。流的元素只在流的生命期间访问过一次。像一个<a href="../../../java/util/Iterator.html" title="interface in java.util"><code>Iterator</code></a>，一个新的流必须产生重温源相同的元素。</li> 
  </ul>流可以多种方式获得。一些例子包括： 
  <ul data-fanyi="1"> 
   <li data-fanyi="1">从<a href="../../../java/util/Collection.html" title="interface in java.util"><code>Collection</code></a>通过<code>stream()</code>和<code>parallelStream()</code>方法；</li> 
   <li data-fanyi="1">从一个数组通过<a href="../../../java/util/Arrays.html#stream-T:A-"><code>Arrays.stream(Object[])</code></a>；</li> 
   <li data-fanyi="1">从静态工厂方法的流类，如<a href="../../../java/util/stream/Stream.html#of-T...-"><code>Stream.of(Object[])</code></a>，<a href="../../../java/util/stream/IntStream.html#range-int-int-"><code>IntStream.range(int, int)</code></a>或<a href="../../../java/util/stream/Stream.html#iterate-T-java.util.function.UnaryOperator-"><code>Stream.iterate(Object, UnaryOperator)</code></a>；</li> 
   <li data-fanyi="1">一个文件的线可以从<a href="../../../java/io/BufferedReader.html#lines--"><code>BufferedReader.lines()</code></a>；</li> 
   <li data-fanyi="1">文件路径的数据流可以从<a href="../../../java/nio/file/Files.html" title="class in java.nio.file"><code>Files</code></a>获得方法；</li> 
   <li data-fanyi="1">随机数流可以从<a href="../../../java/util/Random.html#ints--"><code>Random.ints()</code></a>；</li> 
   <li data-fanyi="1">许多其他流承载方法在JDK，包括<a href="../../../java/util/BitSet.html#stream--"><code>BitSet.stream()</code></a>，<a href="../../../java/util/regex/Pattern.html#splitAsStream-java.lang.CharSequence-"><code>Pattern.splitAsStream(java.lang.CharSequence)</code></a>，和<a href="../../../java/util/jar/JarFile.html#stream--"><code>JarFile.stream()</code></a>。</li> 
  </ul> 
  <p data-fanyi="1">额外的流源可通过第三方库使用<a href="../../../java/util/stream/package-summary.html#StreamSources">these techniques</a>提供。</p> 
  <h2 data-fanyi="1"><a name="../../../java/util/stream/StreamOps">Stream operations and pipelines</a></h2> 
  <p data-fanyi="1">流操作分为中间和终端操作，并组合成流管道。蒸汽管道由一个源（如<code>Collection</code>、数组、发电功能，或I/O通道）；其次是零个或多个如<code>Stream.filter</code>或<code>Stream.map</code>中间业务；和终端操作如<code>Stream.forEach</code>或<code>Stream.reduce</code>。</p> 
  <p data-fanyi="1">中间业务返回一个新的流。他们总是懒洋洋的；执行中间操作如<code>filter()</code>实际上并没有进行任何的过滤，而是创建一个新的流，当走过，包含的元素的初始流匹配给定的谓词。直到执行管道的终端操作时，管道源的遍历才开始。</p> 
  <p data-fanyi="1">终端操作，如<code>Stream.forEach</code>或<code>IntStream.sum</code>，可以遍历流产生的结果或副作用。在执行终端操作后，将被视为消耗流管道，并不能使用；如果您需要再次遍历同一数据源，则必须返回数据源以获得新的流。在几乎所有的情况下，终端操作都渴望，完成他们的遍历的数据源和处理的管道，然后返回。只有终端操作<code>iterator()</code>和<code>spliterator()</code>不是；这些是作为一个“逃生舱”使任意客户端的事件，现有业务不足以控制管道遍历任务。</p> 
  <p data-fanyi="1">处理流懒洋洋地允许显著功效；在管道如过滤图和上面的例子，过滤、映射和总结可以融合到单个数据传递，以最小的中间状态。懒惰也允许避免检查所有的数据，当它是没有必要的操作，如“找到第一个字符串超过1000个字符”，它是唯一必要的检查只是足够的字符串，找到一个具有所需的特性，而不检查所有的字符串从源提供。（当输入流是无限的，而不仅仅是大的，这种行为变得更加重要。）</p> 
  <p data-fanyi="1">中间业务进一步分为有状态和无状态的操作。无状态的操作，如<code>filter</code>和<code>map</code>，不保留状态从以前见过的元素时，处理的一种新的元素，每个元素可以对其他元素的独立的业务处理。有状态的操作，如<code>distinct</code>和<code>sorted</code>，可能包含先前看到的新的元素时，元素的处理状态。</p> 
  <p data-fanyi="1">有状态的操作可能需要处理整个输入之前产生的结果。例如，一个不能产生任何排序一个流的结果，直到一个已经看到流的所有元素。因此，在并行计算，一些管道状态中间操作可能需要多个传递数据或可能需要缓冲的重要数据。包含完全无状态中间操作的管道可以在一个单一的通中处理，无论是连续的或并行的，以最小的数据缓冲。</p> 
  <p data-fanyi="1">此外，一些业务被视为短路操作。中间业务是短路的话，当面对无限的输入，它可能会产生一个有限流的结果。终端短路的话，当面对无限的输入，它可以在有限的时间内终止。在管道具有短路手术是必要的，但不是充分的，对于一个无限流的正常终止，在有限的时间内处理条件。</p> 
  <h3 data-fanyi="1">并行</h3> 
  <p data-fanyi="1">一个明确的<code>for-</code>loop处理元素本质上是串行的。流便于并行执行重新计算为总运营的管道，而不是势在必行的操作单元。所有的流操作可以在串行或并行执行。在JDK的流实现创建并行串行流除非明确要求。例如，<code>Collection</code>方法<a href="../../../java/util/Collection.html#stream--"><code>Collection.stream()</code></a>和<a href="../../../java/util/Collection.html#parallelStream--"><code>Collection.parallelStream()</code></a>，产生串行和并行流分别；其他流承载方法如<a href="../../../java/util/stream/IntStream.html#range-int-int-"><code>IntStream.range(int, int)</code></a>产生顺序流但这些流可以有效地并行化方法通过调用它们的<a href="../../../java/util/stream/BaseStream.html#parallel--"><code>BaseStream.parallel()</code></a>。要执行以前的“小部件”查询的权重的总和，我们会做：</p> 
  <pre data-fanyi="1"><code>
     int sumOfWeights = widgets.</code><code><b>parallelStream()</b></code><code>
                               .filter(b -&gt; b.getColor() == RED)
                               .mapToInt(b -&gt; b.getWeight())
                               .sum();
 </code></pre> 
  <p data-fanyi="1">串行和并行版本的这个例子的差别仅为初始流的创作，用“<code>parallelStream()</code>”而不是“<code>stream()</code>”。当终端操作开始时，流管道按顺序或并行执行，取决于它被调用的流的方向。流是否将串行或并行执行可与<code>isParallel()</code>法确定，和一个流的方向可以用行动<a href="../../../java/util/stream/BaseStream.html#sequential--"><code>BaseStream.sequential()</code></a>和<a href="../../../java/util/stream/BaseStream.html#parallel--"><code>BaseStream.parallel()</code></a>修饰。当发起终端操作时，流管道按顺序或并行执行，取决于调用的流的模式。</p> 
  <p data-fanyi="1">除了确定为明确的不确定性的操作，如<code>findAny()</code>，流是否执行顺序或并行，不应改变计算的结果。</p> 
  <p data-fanyi="1">大多数流操作接受描述用户指定的行为参数，这往往是lambda表达式。为了保持正确的行为，这些行为参数必须是不干扰的，在大多数情况下，必须是无状态的。这样的参数一直是一个<a href="../../../java/util/stream/../function/package-summary.html">functional interface</a>如<a href="../../../java/util/function/Function.html" title="interface in java.util.function"><code>Function</code></a>实例，经常是lambda表达式或方法引用。</p> 
  <h3 data-fanyi="1"><a name="../../../java/util/stream/NonInterference">Non-interference</a></h3>流使你执行可能并行骨料歌剧在各种数据源的问题，甚至包括非线程安全的集合，如 
  <code>ArrayList</code>。这是可能的，只有当我们可以防止在一个流管道的执行过程中的数据源的干扰。除了逃生舱口操作 
  <code>iterator()</code>和 
  <code>spliterator()</code>，开始执行，当终端操作调用，和两端的终端操作完成时。对于大多数数据源，防止干扰意味着确保在执行过程中的所有过程中的数据源不被修改。这是一个显着的例外是流，其来源是并发集合，这是专门设计来处理并发修改。并发流的来源是那些 
  <code>Spliterator</code>报告 
  <code>CONCURRENT</code>特性。 
  <p data-fanyi="1">因此，在源可能不并发的流管道中的行为参数永远不应该修改流的数据源。一个行为参数被称为干扰一个非并发的数据源，如果它修改，或将要修改的原因，该流的数据源。不干涉的需要适用于所有的管道，而不仅仅是平行的管道。除非流源是并行的，一个流管道执行期间修改一个流的数据源可能导致异常，不正确的答案，或不符合标准的行为。乖巧的流源，源可以修改终端操作开始之前，这些修改将反映在覆盖的元素。例如，考虑下面的代码：</p> 
  <pre data-fanyi="1"><code>
     List&lt;String&gt; l = new ArrayList(Arrays.asList("one", "two"));
     Stream&lt;String&gt; sl = l.stream();
     l.add("three");
     String s = sl.collect(joining(" "));
 </code></pre>第一个列表创建由两个字符串：“一”和“二”。然后从该列表中创建一个流。下一个列表是通过添加三分之一个字符串修改：“三”。最后，流的元素被收集并结合在一起。由于名单的修改在终端操作的结果 
  <code>collect</code>开始将一个字符串“一二三”。所有的河流从JDK集合返回，和大多数其他JDK的类，在这种方式中表现得很好；被其他库生成的流，看到建筑乖流要求 
  <a href="../../../java/util/stream/package-summary.html#StreamSources">Low-level stream construction</a>。 
  <h3 data-fanyi="1"><a name="../../../java/util/stream/Statelessness">Stateless behaviors</a></h3>流管道的结果可能是不确定的或不正确的如果流操作的行为参数的状态。一个状态λ（或其他对象执行相应的功能接口）是一个其结果取决于任何一个国家可能的流管道的执行过程中的变化。一个状态λ是一个例子， 
  <code>map()</code>在参数： 
  <pre data-fanyi="1"><code>
     Set&lt;Integer&gt; seen = Collections.synchronizedSet(new HashSet&lt;&gt;());
     stream.parallel().map(e -&gt; { if (seen.add(e)) return 0; else return e; })...
 </code></pre>这里，如果映射操作的并行执行，对于相同的输入的结果可能会有所不同从跑来跑去，由于线程调度的差异，而与一个无国籍的lambda表达式的结果都是一样的。 
  <p data-fanyi="1">还请注意，试图从行为参数访问可变状态呈现给你关于安全和性能的一个不错的选择；如果你不同步访问的状态，你有一个数据竞争和因此你的代码了，但是如果你同步访问的状态，你将有可能破坏你所寻求的竞争受益于并行。最好的方法是避免状态行为参数流操作完全；通常有一种方法来调整流管道，避免有状态。</p> 
  <h3 data-fanyi="1">副作用</h3>副作用行为参数流操作，在一般情况下，不气馁，因为他们往往会导致无意侵犯的无国籍的要求，以及其他的线程安全的危害。 
  <p data-fanyi="1">如果行为参数也有副作用，除非明确声明，没有保证对这些副作用的<a href="../../../java/util/stream/../concurrent/package-summary.html#MemoryVisibility"><i>visibility</i></a>其他线程，也没有任何保证相同的流管道内的“同一”元素的不同业务在同一个线程中执行。此外，这些影响的顺序可能是令人惊讶的。即使管道约束产生的结果是随着流源遇到的顺序一致（例如，<code>IntStream.range(0,5).parallel().map(x -&gt; x*2).toArray()</code>必须产生<code>[0, 2, 4, 6, 8]</code>），不保证所作的映射函数应用于单个元素的顺序，或是线程的任何行为参数是给定的元素执行。</p> 
  <p data-fanyi="1">很多人可能会使用的副作用能更安全有效地表达无副作用的计算，如使用<a href="../../../java/util/stream/package-summary.html#Reduction">reduction</a>代替可变蓄电池。然而，副作用，如使用<code>println()</code>用于调试目的通常是无害的。少量的流操作，如<code>forEach()</code>和<code>peek()</code>，只能通过副作用；这些应谨慎使用。</p> 
  <p data-fanyi="1">作为一个例子，如何将一个流管道，不当使用的副作用之一，不，下面的代码搜索字符串的流匹配给定的正则表达式，并将匹配列表中的。</p> 
  <pre data-fanyi="1"><code>
     ArrayList&lt;String&gt; results = new ArrayList&lt;&gt;();
     stream.filter(s -&gt; pattern.matcher(s).matches())
           .forEach(s -&gt; results.add(s));  // Unnecessary use of side-effects!
 </code></pre>这个代码不必要使用的副作用。如果并行执行，对 
  <code>ArrayList</code>非线程安全会导致不正确的结果，并添加需要同步会造成冲突，破坏并行效益。此外，用在这里是完全不必要的副作用； 
  <code>forEach()</code>可以简单地用还原操作，更安全，更有效的替代，更适合并行化： 
  <pre data-fanyi="1"><code>
     List&lt;String&gt;results =
         stream.filter(s -&gt; pattern.matcher(s).matches())
               .collect(Collectors.toList());  // No side-effects!
 </code></pre> 
  <h3 data-fanyi="1"><a name="../../../java/util/stream/Ordering">Ordering</a></h3> 
  <p data-fanyi="1">流可能或可能没有定义的相遇顺序。是否一个流有一个遇到顺序取决于源和中间操作。一定的流源（如<code>List</code>或数组）本质上是有序的，而其他人（如<code>HashSet</code>）不。一些中间业务，如<code>sorted()</code>，可能在一个无序流实施遇到的顺序，以及其他可能呈现有序流无序，如<a href="../../../java/util/stream/BaseStream.html#unordered--"><code>BaseStream.unordered()</code></a>。此外，一些终端操作可以忽略遇到的顺序，如<code>forEach()</code>。</p> 
  <p data-fanyi="1">如果流是有序的，大多数的操作限制在他们遇到的元素排序操作；如果一个流的源是一个<code>List</code>含<code>[1, 2, 3]</code>，然后执行<code>map(x -&gt; x*2)</code>结果必须<code>[2, 4, 6]</code>。然而，如果源没有定义遭遇订单，然后任何排列的值将是一个有效的结果<code>[2, 4, 6]</code>。</p> 
  <p data-fanyi="1">对于连续的流，遇到顺序的存在或不存在不影响性能，只有决定论。如果一个流是有序的，相同的源上的相同的流管道的重复执行将产生一个相同的结果，如果它不被订购，重复执行可能会产生不同的结果。</p> 
  <p data-fanyi="1">对于并行流，放宽排序约束有时可以实现更高效的执行。一定的聚合操作，如过滤重复（<code>distinct()</code>）或减少（<code>Collectors.groupingBy()</code>）可以更有效地实现如果元素的顺序是不相关的。同样的，本质上是在遇到订单操作，如<code>limit()</code>可能需要缓冲，以确保适当的排序，破坏并行效益。如果流遇到了一个订单，但用户并不特别在意，遇到秩序，明确的命令流<a href="../../../java/util/stream/BaseStream.html#unordered--"><code>unordered()</code></a>可能提高某些状态或终端操作的并行性能。然而，大多数流管道，如“笔重块”上面的例子，还是并行效率甚至在序约束。</p> 
  <h2 data-fanyi="1"><a name="../../../java/util/stream/Reduction">Reduction operations</a></h2>还原操作（也叫折）以一系列的输入元素，并把它们结合成一个单一的总结的结果结合运行重复应用，比如找到一组数字的总和或最大，或积累元素下到一个列表。流类有一般还原操作的多形式，称为 
  <a href="../../../java/util/stream/Stream.html#reduce-java.util.function.BinaryOperator-"><code>reduce()</code></a>和 
  <a href="../../../java/util/stream/Stream.html#collect-java.util.stream.Collector-"><code>collect()</code></a>，以及多个专业的还原形式如 
  <a href="../../../java/util/stream/IntStream.html#sum--"><code>sum()</code></a>， 
  <a href="../../../java/util/stream/IntStream.html#max--"><code>max()</code></a>，或 
  <a href="../../../java/util/stream/IntStream.html#count--"><code>count()</code></a> 
  <p data-fanyi="1">当然，这样的操作可以很容易地实现简单的顺序循环，如：</p> 
  <pre data-fanyi="1"><code>
    int sum = 0;
    for (int x : numbers) {
       sum += x;
    }
 </code></pre>。然而，我们有充分的理由希望降低操作过变积累如上面。不仅是减少“抽象”--它在流作为一个整体，而不是单独的元素，但构建适当的降低操作本质上是并行的，只要功能（S）用于处理元素 
  <a href="../../../java/util/stream/package-summary.html#Associativity">associative</a>和 
  <a href="../../../java/util/stream/package-summary.html#NonInterfering">stateless</a>。例如，因为我们想找的总和的数字流，我们可以写： 
  <pre data-fanyi="1"><code>
    int sum = numbers.stream().reduce(0, (x,y) -&gt; x+y);
 </code></pre>或： 
  <pre data-fanyi="1"><code>
    int sum = numbers.stream().reduce(0, Integer::sum);
 </code></pre> 
  <p data-fanyi="1">这些减少操作可以安全地运行，几乎没有修改：</p> 
  <pre data-fanyi="1"><code>
    int sum = numbers.parallelStream().reduce(0, Integer::sum);
 </code></pre> 
  <p data-fanyi="1">还原parallellizes因为实现对并行数据子集的操作，然后将中间结果得到最终的正确答案。（即使语言有一个“分别平行”的结构，突变积累的方法，仍需要开发者对共享变量<code>sum</code>积累，以及所需的同步提供线程安全的更新将可能消除并行。任何性能增益）而不是使用<code>reduce()</code>删除所有并行还原操作的负担，和图书馆提供一个高效的并行执行，没有额外的同步要求。</p> 
  <p data-fanyi="1">前面所显示的“小部件”示例演示了如何减少与其他操作结合起来，以替换批量操作的循环。如果<code>widgets</code>是一家集<code>Widget</code>对象，其中有一个<code>getWeight</code>方法，我们可以找到最重的小工具：</p> 
  <pre data-fanyi="1"><code>
     OptionalInt heaviest = widgets.parallelStream()
                                   .mapToInt(Widget::getWeight)
                                   .max();
 </code></pre> 
  <p data-fanyi="1">在更一般的形式，在类型<code>&lt;T&gt;</code>产生的结果<code>&lt;U&gt;</code>型元素<code>reduce</code>操作需要三个参数：</p> 
  <pre data-fanyi="1"><code>
 &lt;U&gt; U reduce(U identity,
              BiFunction&lt;U, ? super T, U&gt; accumulator,
              BinaryOperator&lt;U&gt; combiner);
 </code></pre>这里的单位元是初始种子值的降低和默认的结果如果没有输入元素。蓄电池的功能需要一个部分的结果和下一个元素，并产生一个新的部分结果。组合功能结合两部分的结果产生一个新的部分结果。（组合是必要的平行减少，其中输入的分区，每个分区的一部分积累，计算后的部分结果相结合以产生一个最终的结果。） 
  <p data-fanyi="1">更正式的<code>identity</code>值必须为组合功能的身份。这意味着，所有<code>u</code>，<code>combiner.apply(identity, u)</code>等于<code>u</code>。此外，该<code>combiner</code>功能必须<a href="../../../java/util/stream/package-summary.html#Associativity">associative</a>必须用<code>accumulator</code>功能兼容：所有<code>u</code>和<code>t</code>，<code>combiner.apply(u, accumulator.apply(identity, t))</code>必须<code>equals()</code>到<code>accumulator.apply(u, t)</code>。</p> 
  <p data-fanyi="1">三个参数形式是两个参数形式的一个推广，将一个映射步骤合并成一个积累步骤。我们可以重新铸造简单的加权总和的例子，使用更一般的形式如下：</p> 
  <pre data-fanyi="1"><code>
     int sumOfWeights = widgets.stream()
                               .reduce(0,
                                       (sum, b) -&gt; sum + b.getWeight())
                                       Integer::sum);
 </code></pre>虽然明确的Map-Reduce形式更具可读性和因此通常应优先。广义的形式提供的情况下，显着的工作可以被优化，通过组合映射和减少到一个单一的功能。 
  <h3 data-fanyi="1"><a name="../../../java/util/stream/MutableReduction">Mutable reduction</a></h3>可变减操作积累输入元素到一个可变的结果的容器，如 
  <code>Collection</code>或 
  <code>StringBuilder</code>，正如处理的元素在流。 
  <p data-fanyi="1">如果我们想把一个流的字符串拼接成一个长字符串，我们可以达到与普通还原：</p> 
  <pre data-fanyi="1"><code>
     String concatenated = strings.reduce("", String::concat)
 </code></pre> 
  <p data-fanyi="1">我们会得到预期的结果，甚至会在平行工作。然而，我们可能不高兴的表现！这样一个实现将做大量的字符串复制，并且运行时间将是O（n（2））的字符数。一个更高效的方式将积累的结果为<a href="../../../java/lang/StringBuilder.html" title="class in java.lang"><code>StringBuilder</code></a>，这是一个积累的字符串可变容器。我们可以用同样的技术来并行可变减少因为我们做普通的还原。</p> 
  <p data-fanyi="1">可变减速操作称为<a href="../../../java/util/stream/Stream.html#collect-java.util.stream.Collector-"><code>collect()</code></a>，它收集在一起的结果到结果的容器如<code>Collection</code>。一<code>collect</code>操作需要三个功能：供应商功能构建结果容器的新实例，累加器函数将输入元件为结果的容器，和结合作用的合并之一结果在另一个容器的内容。这种形式非常类似于普通还原的一般形式：</p> 
  <pre data-fanyi="1"><code>
 &lt;R&gt; R collect(Supplier&lt;R&gt; supplier,
               BiConsumer&lt;R, ? super T&gt; accumulator,
               BiConsumer&lt;R, R&gt; combiner);
 </code></pre> 
  <p data-fanyi="1">与<code>reduce()</code>，在这个抽象的方式表达<code>collect</code>的一个好处是，它是适合并行化：我们可以积累部分结果并结合他们，只要积累和结合功能满足相应的要求。例如，收集流中的元素的字符串表示一个<code>ArrayList</code>，我们可以写出每形成明显的顺序：</p> 
  <pre data-fanyi="1"><code>
     ArrayList&lt;String&gt; strings = new ArrayList&lt;&gt;();
     for (T element : stream) {
         strings.add(element.toString());
     }
 </code></pre>或者我们可以使用一个并行收集形式： 
  <pre data-fanyi="1"><code>
     ArrayList&lt;String&gt; strings = stream.collect(() -&gt; new ArrayList&lt;&gt;(),
                                                (c, e) -&gt; c.add(e.toString()),
                                                (c1, c2) -&gt; c1.addAll(c2));
 </code></pre>或拉映射操作了蓄能器的功能，我们可以更简洁的表达： 
  <pre data-fanyi="1"><code>
     List&lt;String&gt; strings = stream.map(Object::toString)
                                  .collect(ArrayList::new, ArrayList::add, ArrayList::addAll);
 </code></pre>这里，我们的供应商是 
  <a href="../../../java/util/ArrayList.html#ArrayList--"><code>ArrayList constructor</code></a>，蓄能器添加字符串化元素的 
  <code>ArrayList</code>，和组合只是利用 
  <a href="../../../java/util/ArrayList.html#addAll-java.util.Collection-"><code>addAll</code></a>来复制ST从一个容器到另一个容器的环。 
  <p data-fanyi="1">三个方面<code>collect</code> --供应商、蓄能器、合路--紧密结合。我们可以用一个<a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream"><code>Collector</code></a>抽象捕获所有三个方面。收集串成<code>List</code>上面的例子可以改写为使用标准的<code>Collector</code>：</p> 
  <pre data-fanyi="1"><code>
     List&lt;String&gt; strings = stream.map(Object::toString)
                                  .collect(Collectors.toList());
 </code></pre> 
  <p data-fanyi="1">包装可减少到集热器的另一个优势：可组合性。这类<a href="../../../java/util/stream/Collectors.html" title="class in java.util.stream"><code>Collectors</code></a>包含收藏家许多预定义的工厂，包括组合器，变换器进入另一个。例如，假设我们有一个计算员工工资总额的收集器，如下所示：</p> 
  <pre data-fanyi="1"><code>
     Collector&lt;Employee, ?, Integer&gt; summingSalaries
         = Collectors.summingInt(Employee::getSalary);
 </code></pre>（第二类型参数的 
  <code>?</code>仅仅表明我们不在乎这个收藏家。中间用表示）如果我们想创造一个集按工资部门的总和，我们可以利用 
  <code>summingSalaries</code>使用 
  <a href="../../../java/util/stream/Collectors.html#groupingBy-java.util.function.Function-java.util.stream.Collector-"><code>groupingBy</code></a>： 
  <pre data-fanyi="1"><code>
     Map&lt;Department, Integer&gt; salariesByDept
         = employees.stream().collect(Collectors.groupingBy(Employee::getDepartment,
                                                            summingSalaries));
 </code></pre> 
  <p data-fanyi="1">与常规的还原操作，<code>collect()</code>操作只能并行如果合适的条件都满足了。对于任何部分积累的结果，将它与一个空的结果容器相结合，必须产生一个等效的结果。那是，一部分积累的结果，是<code>p</code>因蓄电池系列和组合调用，<code>p</code>必须相当于<code>combiner.apply(p, supplier.get())</code>。</p> 
  <p data-fanyi="1">此外，计算是分裂的，它必须产生一个等效的结果。对于任何输入元素<code>t1</code>和<code>t2</code>，在下面的计算结果<code>r1</code>和<code>r2</code>必须等价：</p> 
  <pre data-fanyi="1"><code>
     A a1 = supplier.get();
     accumulator.accept(a1, t1);
     accumulator.accept(a1, t2);
     R r1 = finisher.apply(a1);  // result without splitting

     A a2 = supplier.get();
     accumulator.accept(a2, t1);
     A a3 = supplier.get();
     accumulator.accept(a3, t2);
     R r2 = finisher.apply(combiner.apply(a2, a3));  // result with splitting
 </code></pre> 
  <p data-fanyi="1">在这里，等价性一般是指根据<a href="../../../java/lang/Object.html#equals-java.lang.Object-"><code>Object.equals(Object)</code></a>。但在某些情况下等价可放宽考虑差异。</p> 
  <h3 data-fanyi="1"><a name="../../../java/util/stream/ConcurrentReduction">Reduction, concurrency, and ordering</a></h3>与一些复杂的还原操作，例如一个 
  <code>collect()</code>产生 
  <code>Map</code>，如： 
  <pre data-fanyi="1"><code>
     Map&lt;Buyer, List&lt;Transaction&gt;&gt; salesByBuyer
         = txns.parallelStream()
               .collect(Collectors.groupingBy(Transaction::getBuyer));
 </code></pre>它实际上可能是并行执行的操作会适得其反。这是因为步骤的结合（合并一 
  <code>Map</code>到另一个键）可以是昂贵的一些 
  <code>Map</code>实现。 
  <p data-fanyi="1">假设，然而，用于减少的结果是一个同时可收集容器，如<a href="../../../java/util/concurrent/ConcurrentHashMap.html" title="class in java.util.concurrent"><code>ConcurrentHashMap</code></a>。在这种情况下，蓄能器的并行调用实际上可以把结果同时到相同的结果的容器，消除合并器合并结果容器需要。这可能提供了一个升压到并行执行性能。我们称之为并发还原。</p> 
  <p data-fanyi="1">一个支持并发的减少是有<a href="../../../java/util/stream/Collector.Characteristics.html#CONCURRENT"><code>Collector.Characteristics.CONCURRENT</code></a>特征<a href="../../../java/util/stream/Collector.html" title="interface in java.util.stream"><code>Collector</code></a>。然而，并发集合也有一个缺点。如果多个线程将结果存放在一个共享的容器中，则沉积结果的顺序是不确定的。因此，并发减少是唯一可能的，如果排序是不重要的流正在处理。的<a href="../../../java/util/stream/Stream.html#collect-java.util.stream.Collector-"><code>Stream.collect(Collector)</code></a>实施只会执行一个同步还原如果</p> 
  <ul data-fanyi="1"> 
   <li data-fanyi="1">流是平行的；</li> 
   <li data-fanyi="1">收藏家有<a href="../../../java/util/stream/Collector.Characteristics.html#CONCURRENT"><code>Collector.Characteristics.CONCURRENT</code></a>特性，和；</li> 
   <li data-fanyi="1">无论是流是无序的，或具有特色的<a href="../../../java/util/stream/Collector.Characteristics.html#UNORDERED"><code>Collector.Characteristics.UNORDERED</code></a>。</li> 
  </ul>可以确保流无序利用 
  <a href="../../../java/util/stream/BaseStream.html#unordered--"><code>BaseStream.unordered()</code></a>方法。例如： 
  <pre data-fanyi="1"><code>
     Map&lt;Buyer, List&lt;Transaction&gt;&gt; salesByBuyer
         = txns.parallelStream()
               .unordered()
               .collect(groupingByConcurrent(Transaction::getBuyer));
 </code></pre>（其中 
  <a href="../../../java/util/stream/Collectors.html#groupingByConcurrent-java.util.function.Function-"><code>Collectors.groupingByConcurrent(java.util.function.Function&lt;? super T, ? extends K&gt;)</code></a>是 
  <code>groupingBy</code>并行等效）。 
  <p data-fanyi="1">请注意，如果它是重要的是一个给定的键的元素出现在他们出现在源中的顺序，那么我们不能使用并发减少，因为顺序是并发插入的人员伤亡之一。然后，我们将被约束，以实现无论是一个连续的减少或合并为基础的并行还原。</p> 
  <h3 data-fanyi="1"><a name="../../../java/util/stream/Associativity">Associativity</a></h3>运算符或函数 
  <code>op</code>是联想如果以下认为： 
  <pre data-fanyi="1"><code>
     (a op b) op c == a op (b op c)
 </code></pre>这平行的重要性评价可以看出，如果我们扩大这四个方面： 
  <pre data-fanyi="1"><code>
     a op b op c op d == (a op b) op (c op d)
 </code></pre>所以我们可以评估 
  <code>(a op b)</code>平行 
  <code>(c op d)</code>，然后调用 
  <code>op</code>结果。 
  <p data-fanyi="1">联想业务的例子包括数字之外，最小，最大，和字符串连接。</p> 
  <h2 data-fanyi="1"><a name="../../../java/util/stream/StreamSources">Low-level stream construction</a></h2>为止，所有流实例方法一样 
  <a href="../../../java/util/Collection.html#stream--"><code>Collection.stream()</code></a>或 
  <a href="../../../java/util/Arrays.html#stream-T:A-"><code>Arrays.stream(Object[])</code></a>获得流。这些流轴承方法如何实现？ 
  <p data-fanyi="1"><a href="../../../java/util/stream/StreamSupport.html" title="class in java.util.stream"><code>StreamSupport</code></a>类创建一个流有一些低级的方法，都使用某种形式的一个<a href="../../../java/util/Spliterator.html" title="interface in java.util"><code>Spliterator</code></a>。一spliterator是一个<a href="../../../java/util/Iterator.html" title="interface in java.util"><code>Iterator</code></a>并行模拟；它描述了一个（可能是无限的）元素的集合，与顺序推进，支持批量的遍历，并剥离部分输入到另一个spliterator这可以并行处理。在最低水平，所有的数据流是由一个spliterator驱动。</p> 
  <p data-fanyi="1">有一些实现的选择实施spliterator，几乎都是权衡实施简单和运行性能的流使用spliterator。最简单的，但至少高性能的方法来创建一个spliterator是使用<a href="../../../java/util/Spliterators.html#spliteratorUnknownSize-java.util.Iterator-int-"><code>Spliterators.spliteratorUnknownSize(java.util.Iterator, int)</code></a>迭代器创建一个。而这样的spliterator会工作，它可能会提供并行性能差，因为我们已经失去了大小的信息（多大是底层的数据集），以及被约束到一个简单的分裂算法。</p> 
  <p data-fanyi="1">一个高质量的spliterator将提供平衡与已知大小的分裂，准确的尺寸信息，和其他一些<a href="../../../java/util/Spliterator.html#characteristics--"><code>characteristics</code></a>的spliterator或数据，可实现优化执行。</p> 
  <p data-fanyi="1">对于可变数据源spliterators有额外的挑战；结合数据时，由于数据的时间spliterator创建时间和蒸汽管道之间执行的变化。理想情况下，一个流的spliterator会报告<code>IMMUTABLE</code>或<code>CONCURRENT</code>特征；如果不应该<a href="../../../java/util/stream/../Spliterator.html#binding"><em>late-binding</em></a>。如果源不能直接提供推荐spliterator，可以间接地提供了一spliterator使用<code>Supplier</code>，构建流通过<code>Supplier</code>-accepting版本的<a href="../../../java/util/stream/StreamSupport.html#stream-java.util.function.Supplier-int-boolean-"><code>stream()</code></a>。是的spliterator从供应商只有在蒸汽管道的终端操作开始了。</p> 
  <p data-fanyi="1">这些要求显着减少的流源和执行的流管道的突变之间的潜在干扰的范围。基于期望的特性spliterators溪流，或那些使用基于工厂形式的供应商，是免疫的终端操作开始之前的数据源（提供修改行为参数的操作流满足互不干涉和无国籍要求的标准）。更多细节见<a href="../../../java/util/stream/package-summary.html#NonInterference">Non-Interference</a>。</p> 
 </div> 
 <dl> 
  <dt> 
   <span class="simpleTagLabel">从以下版本开始：</span> 
  </dt> 
  <dd>
    1.8 
  </dd> 
 </dl> 
</div> 
<!-- ======= START OF BOTTOM NAVBAR ====== --> 
<div class="bottomNav"> 
 <a name="navbar.bottom"> 
  <!--   --> </a> 
 <div class="skipNav"> 
  <a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a> 
 </div> 
 <a name="navbar.bottom.firstrow"> 
  <!--   --> </a> 
 <ul class="navList" title="Navigation"> 
  <li><a href="../../../overview-summary.html">概述</a></li> 
  <li class="navBarCell1Rev">软件包</li> 
  <li>类</li> 
  <li><a href="package-use.html">使用</a></li> 
  <li><a href="package-tree.html">树</a></li> 
  <li><a href="../../../deprecated-list.html">已过时的</a></li> 
  <li><a href="../../../index-files/index-1.html">索引</a></li> 
  <li><a href="../../../help-doc.html">帮助</a></li> 
 </ul> 
 <div class="aboutLanguage"> 
  <strong>Java™&nbsp;Platform<br>Standard&nbsp;Ed.&nbsp;8</strong> 
 </div> 
</div> 
<div class="subNav"> 
 <ul class="navList"> 
  <li><a href="../../../java/util/spi/compact2-package-summary.html">Prev&nbsp;Package</a></li> 
  <li><a href="../../../java/util/zip/compact2-package-summary.html">Next&nbsp;Package</a></li> 
 </ul> 
 <ul class="navList"> 
  <li><a href="../../../index.html?java/util/stream/compact2-package-summary.html" target="_top">框架</a></li> 
  <li><a href="compact2-package-summary.html" target="_top">无框架</a></li> 
 </ul> 
 <ul class="navList" id="allclasses_navbar_bottom"> 
  <li><a href="../../../allclasses-noframe.html">所有类</a></li> 
 </ul> 
 <div> 
  <script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script> 
 </div> 
 <a name="skip.navbar.bottom"> 
  <!--   --> </a> 
</div> 
<!-- ======== END OF BOTTOM NAVBAR ======= --> 
<p class="legalCopy"><small><font size="-1"> <a href="http://bugreport.sun.com/bugreport/">Submit a bug or feature</a> <br>For further API reference and developer documentation, see <a href="http://download.oracle.com/javase/8/docs/index.html" target="_blank">Java SE Documentation</a>. That documentation contains more detailed, developer-targeted descriptions, with conceptual overviews, definitions of terms, workarounds, and working code examples.<br> Copyright © 1993, 2014, Oracle and/or its affiliates. All rights reserved. </font></small> </p> 
<div id="adDiv"> 


 <div></div> 
</div> 
<p></p>