<!-- NewPage -->   
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<!-- Generated by javadoc (1.8.0) on Tue Mar 04 03:12:46 PST 2014 --> 
<title>MethodHandles (Java Platform SE 8 )</title> 
<meta name="date" content="2014-03-04"> 
<meta name="keywords" content="java.lang.invoke.MethodHandles class"> 
<meta name="keywords" content="lookup()"> 
<meta name="keywords" content="publicLookup()"> 
<meta name="keywords" content="reflectAs()"> 
<meta name="keywords" content="arrayElementGetter()"> 
<meta name="keywords" content="arrayElementSetter()"> 
<meta name="keywords" content="spreadInvoker()"> 
<meta name="keywords" content="exactInvoker()"> 
<meta name="keywords" content="invoker()"> 
<meta name="keywords" content="explicitCastArguments()"> 
<meta name="keywords" content="permuteArguments()"> 
<meta name="keywords" content="constant()"> 
<meta name="keywords" content="identity()"> 
<meta name="keywords" content="insertArguments()"> 
<meta name="keywords" content="dropArguments()"> 
<meta name="keywords" content="filterArguments()"> 
<meta name="keywords" content="collectArguments()"> 
<meta name="keywords" content="filterReturnValue()"> 
<meta name="keywords" content="foldArguments()"> 
<meta name="keywords" content="guardWithTest()"> 
<meta name="keywords" content="catchException()"> 
<meta name="keywords" content="throwException()"> 
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style"> 
<script type="text/javascript" src="../../../script.js"></script> 
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="MethodHandles (Java Platform SE 8 )";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":9,"i1":9,"i2":9,"i3":9,"i4":9,"i5":9,"i6":9,"i7":9,"i8":9,"i9":9,"i10":9,"i11":9,"i12":9,"i13":9,"i14":9,"i15":9,"i16":9,"i17":9,"i18":9,"i19":9,"i20":9,"i21":9};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script> 
<noscript>
  &lt;div&gt; JavaScript is disabled on your browser. 
</noscript> 
<!-- ========= START OF TOP NAVBAR ======= -->   
<div class="topNav"> 
 <a name="navbar.top"> 
  <!--   --> </a> 
 <div class="skipNav"> 
  <a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a> 
 </div> 
 <a name="navbar.top.firstrow"> 
  <!--   --> </a> 
 <ul class="navList" title="Navigation"> 
  <li><a href="../../../overview-summary.html">概述</a></li> 
  <li><a href="package-summary.html">软件包</a></li> 
  <li class="navBarCell1Rev">类</li> 
  <li><a href="class-use/MethodHandles.html">使用</a></li> 
  <li><a href="package-tree.html">树</a></li> 
  <li><a href="../../../deprecated-list.html">已过时的</a></li> 
  <li><a href="../../../index-files/index-1.html">索引</a></li> 
  <li><a href="../../../help-doc.html">帮助</a></li> 
 </ul> 
 <div class="aboutLanguage"> 
  <strong>Java™&nbsp;Platform<br>Standard&nbsp;Ed.&nbsp;8</strong> 
 </div> 
</div> 
<div class="subNav"> 
 <ul class="navList"> 
  <li><a href="../../../java/lang/invoke/MethodHandleProxies.html" title="class in java.lang.invoke"><span class="typeNameLink">上一个</span></a></li> 
  <li><a href="../../../java/lang/invoke/MethodHandles.Lookup.html" title="class in java.lang.invoke"><span class="typeNameLink">下一个</span></a></li> 
 </ul> 
 <ul class="navList"> 
  <li><a href="../../../index.html?java/lang/invoke/MethodHandles.html" target="_top">框架</a></li> 
  <li><a href="MethodHandles.html" target="_top">无框架</a></li> 
 </ul> 
 <ul class="navList" id="allclasses_navbar_top"> 
  <li><a href="../../../allclasses-noframe.html">所有类</a></li> 
 </ul> 
 <div> 
  <script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script> 
 </div> 
 <div> 
  <ul class="subNavList"> 
   <li>概要：</li> 
   <li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li> 
   <li>字段</li> 
   <li>构造方法</li> 
   <li><a href="#method.summary">方法</a></li> 
  </ul> 
  <ul class="subNavList"> 
   <li>详细信息：</li> 
   <li>字段</li> 
   <li>构造方法</li> 
   <li><a href="#method.detail">方法</a></li> 
  </ul> 
 </div> 
 <a name="skip.navbar.top"> 
  <!--   --> </a> 
</div> 
<!-- ========= END OF TOP NAVBAR ========= --> 
<!-- ======== START OF CLASS DATA ======== --> 
<div class="header"> 
 <div class="subTitle">
   compact1, compact2, compact3 
 </div> 
 <div class="subTitle">
   java.lang.invoke 
 </div> 
 <h2 title="Class MethodHandles" class="title">Class MethodHandles</h2> 
</div> 
<div class="contentContainer"> 
 <ul class="inheritance"> 
  <li><a href="../../../java/lang/Object.html" title="class in java.lang">java.lang.Object</a></li> 
  <li> 
   <ul class="inheritance"> 
    <li>java.lang.invoke.MethodHandles</li> 
   </ul> </li> 
 </ul> 
 <div class="description"> 
  <ul class="blockList"> 
   <li class="blockList"> 
    <hr> <br> <pre>public class <span class="typeNameLabel">MethodHandles</span>
extends <a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></pre> 
    <div class="block" data-fanyi="1">
      这个类完全由操作或返回方法处理的静态方法组成。他们分为几类： 
     <ul data-fanyi="1"> 
      <li data-fanyi="1">用于帮助创建方法和字段的方法处理的查找方法。</li> 
      <li data-fanyi="1">组合的方法，结合已有的方法处理或转换成新的。</li> 
      <li data-fanyi="1">其他的工厂方法创建的方法处理，效仿其他常见JVM操作或控制流模式。</li> 
     </ul> 
     <p data-fanyi="1"></p> 
    </div> 
    <dl> 
     <dt> 
      <span class="simpleTagLabel">从以下版本开始：</span> 
     </dt> 
     <dd data-fanyi="1">
       一点七 
     </dd> 
    </dl> </li> 
  </ul> 
 </div> 
 <div class="summary"> 
  <ul class="blockList"> 
   <li class="blockList"> 
    <!-- ======== NESTED CLASS SUMMARY ======== --> 
    <ul class="blockList"> 
     <li class="blockList"><a name="nested.class.summary"> 
       <!--   --> </a> <h3>Nested Class Summary</h3> 
      <table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Nested Class Summary table, listing nested classes, and an explanation"> 
       <caption> 
        <span>Nested Classes</span> 
        <span class="tabEnd">&nbsp;</span> 
       </caption> 
       <tbody> 
        <tr> 
         <th class="colFirst" scope="col">Modifier and Type</th> 
         <th class="colLast" scope="col">Class and Description</th> 
        </tr> 
        <tr class="altColor"> 
         <td class="colFirst"><code>static class&nbsp;</code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.Lookup.html" title="class in java.lang.invoke">MethodHandles.Lookup</a></span></code> 
          <div class="block" data-fanyi="1">
            查找对象是一个用于创建方法句柄的工厂，当创建需要访问检查时。 
          </div> </td> 
        </tr> 
       </tbody> 
      </table> </li> 
    </ul> 
    <!-- ========== METHOD SUMMARY =========== --> 
    <ul class="blockList"> 
     <li class="blockList"><a name="method.summary"> 
       <!--   --> </a> <h3>方法摘要</h3> 
      <table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation"> 
       <caption> 
        <span id="t0" class="activeTableTab"><span>所有方法</span><span class="tabEnd">&nbsp;</span></span> 
        <span id="t1" class="tableTab"><span><a href="javascript:show(1);">静态方法</a></span><span class="tabEnd">&nbsp;</span></span> 
        <span id="t4" class="tableTab"><span><a href="javascript:show(8);">具体的方法</a></span><span class="tabEnd">&nbsp;</span></span> 
       </caption> 
       <tbody> 
        <tr> 
         <th class="colFirst" scope="col">Modifier and Type</th> 
         <th class="colLast" scope="col">Method and Description</th> 
        </tr> 
        <tr id="i0" class="altColor"> 
         <td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#arrayElementGetter-java.lang.Class-">arrayElementGetter</a></span>(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;arrayClass)</code> 
          <div class="block" data-fanyi="1">
            产生一个方法来处理对数组元素的读取访问。 
          </div> </td> 
        </tr> 
        <tr id="i1" class="rowColor"> 
         <td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#arrayElementSetter-java.lang.Class-">arrayElementSetter</a></span>(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;arrayClass)</code> 
          <div class="block" data-fanyi="1">
            产生一个方法处理给数组元素的写访问权限。 
          </div> </td> 
        </tr> 
        <tr id="i2" class="altColor"> 
         <td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#catchException-java.lang.invoke.MethodHandle-java.lang.Class-java.lang.invoke.MethodHandle-">catchException</a></span>(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target, <a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;? extends <a href="../../../java/lang/Throwable.html" title="class in java.lang">Throwable</a>&gt;&nbsp;exType, <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;handler)</code> 
          <div class="block" data-fanyi="1">
            通过在异常处理程序中运行它，使一个适应目标方法句柄的方法处理。 
          </div> </td> 
        </tr> 
        <tr id="i3" class="rowColor"> 
         <td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#collectArguments-java.lang.invoke.MethodHandle-int-java.lang.invoke.MethodHandle-">collectArguments</a></span>(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target, int&nbsp;pos, <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;filter)</code> 
          <div class="block" data-fanyi="1">
            通过预处理与一个过滤器（另一个方法句柄）的参数的子序列来调整目标方法句柄。 
          </div> </td> 
        </tr> 
        <tr id="i4" class="altColor"> 
         <td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#constant-java.lang.Class-java.lang.Object-">constant</a></span>(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;type, <a href="../../../java/lang/Object.html" title="class in java.lang">Object</a>&nbsp;value)</code> 
          <div class="block" data-fanyi="1">
            产生一个请求的返回类型的方法句柄，它每次调用时返回给定的常数值。 
          </div> </td> 
        </tr> 
        <tr id="i5" class="rowColor"> 
         <td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#dropArguments-java.lang.invoke.MethodHandle-int-java.lang.Class...-">dropArguments</a></span>(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target, int&nbsp;pos, <a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;...&nbsp;valueTypes)</code> 
          <div class="block" data-fanyi="1">
            产生的方法处理，会丢弃一些虚拟的参数调用其他一些指定的空目标方法处理前。 
          </div> </td> 
        </tr> 
        <tr id="i6" class="altColor"> 
         <td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#dropArguments-java.lang.invoke.MethodHandle-int-java.util.List-">dropArguments</a></span>(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target, int&nbsp;pos, <a href="../../../java/util/List.html" title="interface in java.util">List</a>&lt;<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;&gt;&nbsp;valueTypes)</code> 
          <div class="block" data-fanyi="1">
            产生的方法处理，会丢弃一些虚拟的参数调用其他一些指定的空目标方法处理前。 
          </div> </td> 
        </tr> 
        <tr id="i7" class="rowColor"> 
         <td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#exactInvoker-java.lang.invoke.MethodType-">exactInvoker</a></span>(<a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;type)</code> 
          <div class="block" data-fanyi="1">
            产生了一种特殊的调用方法处理可用于调用任何方法处理给定类型的，如 
           <a href="../../../java/lang/invoke/MethodHandle.html#invokeExact-java.lang.Object...-"><code>invokeExact</code></a>。 
          </div> </td> 
        </tr> 
        <tr id="i8" class="altColor"> 
         <td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#explicitCastArguments-java.lang.invoke.MethodHandle-java.lang.invoke.MethodType-">explicitCastArguments</a></span>(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target, <a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;newType)</code> 
          <div class="block" data-fanyi="1">
            通过成对的参数和返回类型转换，生成一个适应给定方法句柄类型的方法句柄。 
          </div> </td> 
        </tr> 
        <tr id="i9" class="rowColor"> 
         <td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#filterArguments-java.lang.invoke.MethodHandle-int-java.lang.invoke.MethodHandle...-">filterArguments</a></span>(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target, int&nbsp;pos, <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>...&nbsp;filters)</code> 
          <div class="block" data-fanyi="1">
            采用目标法处理由预处理它的一个或多个参数，每一个都有自己独特的过滤功能，然后调用目标各预处理变量的相应的滤波函数的结果取代。 
          </div> </td> 
        </tr> 
        <tr id="i10" class="altColor"> 
         <td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#filterReturnValue-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-">filterReturnValue</a></span>(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target, <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;filter)</code> 
          <div class="block" data-fanyi="1">
            调整一个目标方法处理它的返回值（如果有的话）与一个过滤器（另一个方法处理）处理。 
          </div> </td> 
        </tr> 
        <tr id="i11" class="rowColor"> 
         <td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#foldArguments-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-">foldArguments</a></span>(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target, <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;combiner)</code> 
          <div class="block" data-fanyi="1">
            通过预处理某些参数的预处理来调整目标方法句柄，然后将该目标与预处理的结果调用，并插入到原始参数的序列中。 
          </div> </td> 
        </tr> 
        <tr id="i12" class="altColor"> 
         <td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#guardWithTest-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-">guardWithTest</a></span>(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;test, <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target, <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;fallback)</code> 
          <div class="block" data-fanyi="1">
            使一个方法处理适应一个目标方法句柄，通过使用一个测试，一个布尔值方法句柄来保护它。 
          </div> </td> 
        </tr> 
        <tr id="i13" class="rowColor"> 
         <td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#identity-java.lang.Class-">identity</a></span>(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;type)</code> 
          <div class="block" data-fanyi="1">
            产生调用时返回其唯一参数的方法句柄。 
          </div> </td> 
        </tr> 
        <tr id="i14" class="altColor"> 
         <td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#insertArguments-java.lang.invoke.MethodHandle-int-java.lang.Object...-">insertArguments</a></span>(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target, int&nbsp;pos, <a href="../../../java/lang/Object.html" title="class in java.lang">Object</a>...&nbsp;values)</code> 
          <div class="block" data-fanyi="1">
            提供一个目标方法处理在方法句柄调用之前的一个或多个绑定参数。 
          </div> </td> 
        </tr> 
        <tr id="i15" class="rowColor"> 
         <td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#invoker-java.lang.invoke.MethodType-">invoker</a></span>(<a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;type)</code> 
          <div class="block" data-fanyi="1">
            产生了一种特殊的调用方法处理可用于调用任何方法处理符合给定的类型，如 
           <a href="../../../java/lang/invoke/MethodHandle.html#invoke-java.lang.Object...-"><code>invoke</code></a>。 
          </div> </td> 
        </tr> 
        <tr id="i16" class="altColor"> 
         <td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandles.Lookup.html" title="class in java.lang.invoke">MethodHandles.Lookup</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#lookup--">lookup</a></span>()</code> 
          <div class="block" data-fanyi="1">
            返回一个 
           <a href="../../../java/lang/invoke/MethodHandles.Lookup.html" title="class in java.lang.invoke"><code>lookup object</code></a>全功能模拟都支持对方的字节码的行为。 
          </div> </td> 
        </tr> 
        <tr id="i17" class="rowColor"> 
         <td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#permuteArguments-java.lang.invoke.MethodHandle-java.lang.invoke.MethodType-int...-">permuteArguments</a></span>(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target, <a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;newType, int...&nbsp;reorder)</code> 
          <div class="block" data-fanyi="1">
            生产法处理适应给定的方法的调用顺序处理一个新的类型，通过重新排列参数。 
          </div> </td> 
        </tr> 
        <tr id="i18" class="altColor"> 
         <td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandles.Lookup.html" title="class in java.lang.invoke">MethodHandles.Lookup</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#publicLookup--">publicLookup</a></span>()</code> 
          <div class="block" data-fanyi="1">
            返回一个 
           <a href="../../../java/lang/invoke/MethodHandles.Lookup.html" title="class in java.lang.invoke"><code>lookup object</code></a>是值得信赖的微创。 
          </div> </td> 
        </tr> 
        <tr id="i19" class="rowColor"> 
         <td class="colFirst"><code>static &lt;T extends <a href="../../../java/lang/reflect/Member.html" title="interface in java.lang.reflect">Member</a>&gt;<br>T</code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#reflectAs-java.lang.Class-java.lang.invoke.MethodHandle-">reflectAs</a></span>(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;T&gt;&nbsp;expected, <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target)</code> 
          <div class="block" data-fanyi="1">
            执行检查的“裂缝”的 
           <a href="MethodHandleInfo.html#directmh">direct method handle</a>。 
          </div> </td> 
        </tr> 
        <tr id="i20" class="altColor"> 
         <td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#spreadInvoker-java.lang.invoke.MethodType-int-">spreadInvoker</a></span>(<a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;type, int&nbsp;leadingArgCount)</code> 
          <div class="block" data-fanyi="1">
            产生的方法处理这将调用任何方法处理给定的 
           <code>type</code>，与给定数量的尾参数由一个单一的尾 
           <code>Object[]</code>阵列取代。 
          </div> </td> 
        </tr> 
        <tr id="i21" class="rowColor"> 
         <td class="colFirst"><code>static <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.html#throwException-java.lang.Class-java.lang.Class-">throwException</a></span>(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;returnType, <a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;? extends <a href="../../../java/lang/Throwable.html" title="class in java.lang">Throwable</a>&gt;&nbsp;exType)</code> 
          <div class="block" data-fanyi="1">
            产生的方法处理，将给定的 
           <code>exType</code>例外。 
          </div> </td> 
        </tr> 
       </tbody> 
      </table> 
      <ul class="blockList"> 
       <li class="blockList"><a name="methods.inherited.from.class.java.lang.Object"> 
         <!--   --> </a> <h3>Methods inherited from class&nbsp;java.lang.<a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></h3> <code><a href="../../../java/lang/Object.html#clone--">clone</a>, <a href="../../../java/lang/Object.html#equals-java.lang.Object-">equals</a>, <a href="../../../java/lang/Object.html#finalize--">finalize</a>, <a href="../../../java/lang/Object.html#getClass--">getClass</a>, <a href="../../../java/lang/Object.html#hashCode--">hashCode</a>, <a href="../../../java/lang/Object.html#notify--">notify</a>, <a href="../../../java/lang/Object.html#notifyAll--">notifyAll</a>, <a href="../../../java/lang/Object.html#toString--">toString</a>, <a href="../../../java/lang/Object.html#wait--">wait</a>, <a href="../../../java/lang/Object.html#wait-long-">wait</a>, <a href="../../../java/lang/Object.html#wait-long-int-">wait</a></code></li> 
      </ul> </li> 
    </ul> </li> 
  </ul> 
 </div> 
 <div class="details"> 
  <ul class="blockList"> 
   <li class="blockList"> 
    <!-- ============ METHOD DETAIL ========== --> 
    <ul class="blockList"> 
     <li class="blockList"><a name="method.detail"> 
       <!--   --> </a> <h3>方法详细信息</h3> <a name="lookup--"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>lookup</h4> <pre>public static&nbsp;<a href="../../../java/lang/invoke/MethodHandles.Lookup.html" title="class in java.lang.invoke">MethodHandles.Lookup</a>&nbsp;lookup()</pre> 
        <div class="block" data-fanyi="1">
          返回一个 
         <a href="../../../java/lang/invoke/MethodHandles.Lookup.html" title="class in java.lang.invoke"><code>lookup object</code></a>全功能模拟都支持对方的字节码的行为。这些功能包括 
         <a href="MethodHandles.Lookup.html#privacc">private access</a>给调用者。在查找对象的工厂方法可以创建 
         <a href="MethodHandleInfo.html#directmh">direct method handles</a>任何成员，调用者通过字节码访问，包括保护和私人领域和方法。此查找对象是一个可能被委托给受信任代理的能力。不保存它的地方，不受信任的代码可以访问它。 
         <p data-fanyi="1">此方法是调用方敏感的，这意味着它可能会返回不同的值给不同的调用方。</p> 
         <p data-fanyi="1">对于任何给定的调用类<code>C</code>，查询返回的对象需要任何查找对象由JVM提供给在同一调用类<code>C</code>执行<a href="package-summary.html#indyinsn">invokedynamic instruction</a> Bootstrap方法等效的能力。</p> 
        </div> 
        <dl> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           此方法的调用方的查找对象，与私有访问 
         </dd> 
        </dl> </li> 
      </ul> <a name="publicLookup--"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>publicLookup</h4> <pre>public static&nbsp;<a href="../../../java/lang/invoke/MethodHandles.Lookup.html" title="class in java.lang.invoke">MethodHandles.Lookup</a>&nbsp;publicLookup()</pre> 
        <div class="block" data-fanyi="1">
          返回一个 
         <a href="../../../java/lang/invoke/MethodHandles.Lookup.html" title="class in java.lang.invoke"><code>lookup object</code></a>是值得信赖的微创。它只能用于创建用于可公开访问的字段和方法的方法句柄。 
         <p data-fanyi="1">作为一个纯粹的公约，这将<a href="../../../java/lang/Object.html" title="class in java.lang"><code>Object</code></a> <a href="../../../java/lang/invoke/MethodHandles.Lookup.html#lookupClass">lookup class</a>查找对象。</p> 
         <p style="font-size:smaller;" data-fanyi="1">讨论：查找类可以更改为任何其他类<code>C</code>使用<a href="../../../java/lang/invoke/MethodHandles.Lookup.html#in-java.lang.Class-"><code>publicLookup().in(C.class)</code></a>表达形式。由于所有类都有相同的对公共名称的访问，这样的变化将赋予没有新的访问权限。公共查询对象总是受<a href="MethodHandles.Lookup.html#secmgr">security manager checks</a>。另外，它无法访问<a href="MethodHandles.Lookup.html#callsens">caller sensitive methods</a>。</p> 
        </div> 
        <dl> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           一种可信赖的最小的查找对象 
         </dd> 
        </dl> </li> 
      </ul> <a name="reflectAs-java.lang.Class-java.lang.invoke.MethodHandle-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>reflectAs</h4> <pre>public static&nbsp;&lt;T extends <a href="../../../java/lang/reflect/Member.html" title="interface in java.lang.reflect">Member</a>&gt;&nbsp;T&nbsp;reflectAs(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;T&gt;&nbsp;expected,
                                             <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target)</pre> 
        <div class="block" data-fanyi="1">
          执行检查的“裂缝”的 
         <a href="MethodHandleInfo.html#directmh">direct method handle</a>。结果是如果用户已经获得了足以破解目标的方法处理查找对象，称为对目标 
         <a href="../../../java/lang/invoke/MethodHandles.Lookup.html#revealDirect-java.lang.invoke.MethodHandle-"><code>Lookup.revealDirect</code></a>获得符号引用，然后叫 
         <a href="../../../java/lang/invoke/MethodHandleInfo.html#reflectAs-java.lang.Class-java.lang.invoke.MethodHandles.Lookup-"><code>MethodHandleInfo.reflectAs</code></a>解决成员的象征意义。 
         <p data-fanyi="1">如果存在安全管理器，它的<code>checkPermission</code>方法称为一个<code>ReflectPermission("suppressAccessChecks")</code>许可。</p> 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数类型</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>T</code> -结果所期望的类型，要么 
          <a href="../../../java/lang/reflect/Member.html" title="interface in java.lang.reflect"><code>Member</code></a>或亚型 
         </dd> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>target</code> -一个直接的方法处理裂缝为符号参考组件 
         </dd> 
         <dd data-fanyi="1"> 
          <code>expected</code> -代表期望的结果类型 
          <code>T</code>类对象 
         </dd> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           方法、构造函数或字段对象的引用 
         </dd> 
         <dt> 
          <span class="throwsLabel">异常</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code>如果打电话的人是不是叫 
          <code>setAccessible</code>特权 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code>如果任一参数是 
          <code>null</code> 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> -如果目标不是一个直接的方法处理 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/ClassCastException.html" title="class in java.lang">ClassCastException</a></code> -如果成员不是预期的类型 
         </dd> 
         <dt> 
          <span class="simpleTagLabel">从以下版本开始：</span> 
         </dt> 
         <dd data-fanyi="1">
           一点八 
         </dd> 
        </dl> </li> 
      </ul> <a name="arrayElementGetter-java.lang.Class-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>arrayElementGetter</h4> <pre>public static&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;arrayElementGetter(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;arrayClass)
                                       throws <a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></pre> 
        <div class="block" data-fanyi="1">
          产生一个方法来处理对数组元素的读取访问。方法句柄的类型将有一个数组元素类型的返回类型。它的第一个参数是数组类型，第二将 
         <code>int</code>。 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>arrayClass</code> -数组类型 
         </dd> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           可以从给定的数组类型加载值的方法句柄 
         </dd> 
         <dt> 
          <span class="throwsLabel">异常</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> -如果参数为空 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> -如果arrayclass不是数组类型 
         </dd> 
        </dl> </li> 
      </ul> <a name="arrayElementSetter-java.lang.Class-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>arrayElementSetter</h4> <pre>public static&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;arrayElementSetter(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;arrayClass)
                                       throws <a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></pre> 
        <div class="block" data-fanyi="1">
          产生一个方法处理给数组元素的写访问权限。方法句柄的类型将有一个无效的返回类型。它的最后一个参数将是数组的元素类型。第一和第二个参数是数组类型，int。 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>arrayClass</code> -数组的类 
         </dd> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           可以将值存储到数组类型的方法处理 
         </dd> 
         <dt> 
          <span class="throwsLabel">异常</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> -如果参数为空 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> -如果arrayclass不是数组类型 
         </dd> 
        </dl> </li> 
      </ul> <a name="spreadInvoker-java.lang.invoke.MethodType-int-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>spreadInvoker</h4> <pre>public static&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;spreadInvoker(<a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;type,
                                         int&nbsp;leadingArgCount)</pre> 
        <div class="block" data-fanyi="1">
          产生的方法处理这将调用任何方法处理给定的 
         <code>type</code>，与给定数量的尾参数由一个单一的尾 
         <code>Object[]</code>阵列取代。由此产生的调用将使用下面的参数处理方法：这种方法 
         <ul data-fanyi="1"> 
          <li data-fanyi="1">一个<code>MethodHandle</code>目标</li> 
          <li data-fanyi="1">零个或多个主导价值观（被<code>leadingArgCount</code>）</li> 
          <li data-fanyi="1">包含尾随<code>Object[]</code>阵列参数</li> 
         </ul> 
         <p data-fanyi="1">调用程序会调用它的目标像一声<a href="../../../java/lang/invoke/MethodHandle.html#invoke-java.lang.Object...-"><code>invoke</code></a>与表示<code>type</code>。就是说，如果目标是给定的<code>type</code>，它会像<code>invokeExact</code>；否则它就好像<a href="../../../java/lang/invoke/MethodHandle.html#asType-java.lang.invoke.MethodType-"><code>asType</code></a>是用来转换目标所需的<code>type</code>。</p> 
         <p data-fanyi="1">返回调用程序的类型将不给予<code>type</code>，而是将除第一<code>leadingArgCount</code>由一个单一的阵列式<code>Object[]</code>取代所有参数，这将是最后一个参数。</p> 
         <p data-fanyi="1">调用其目标之前，调用程序将最终的阵列，将参考模型是必要的，而且还要将拓宽原始参数。如果，当调用被调用，提供的数组参数没有正确数量的元素，调用会抛出一个<a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang"><code>IllegalArgumentException</code></a>代替调用目标。</p> 
         <p data-fanyi="1">此方法相当于下面的代码（虽然它可能更有效）：</p> 
         <blockquote> 
          <pre><code>
MethodHandle invoker = MethodHandles.invoker(type);
int spreadArgCount = type.parameterCount() - leadingArgCount;
invoker = invoker.asSpreader(Object[].class, spreadArgCount);
return invoker;
 </code></pre> 
         </blockquote>投不反射或安全例外。 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>type</code> -目标型 
         </dd> 
         <dd data-fanyi="1"> 
          <code>leadingArgCount</code> -固定参数的数量，可以通过不变的目标 
         </dd> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           一种适用于调用给定类型的任何方法句柄的方法处理 
         </dd> 
         <dt> 
          <span class="throwsLabel">异常</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> -如果 
          <code>type</code>是空的 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> -如果 
          <code>leadingArgCount</code>不在范围从0到 
          <code>type.parameterCount()</code>包容，或者产生的方法处理的类型会 
          <a href="MethodHandle.html#maxarity">too many parameters</a> 
         </dd> 
        </dl> </li> 
      </ul> <a name="exactInvoker-java.lang.invoke.MethodType-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>exactInvoker</h4> <pre>public static&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;exactInvoker(<a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;type)</pre> 
        <div class="block" data-fanyi="1">
          产生了一种特殊的调用方法处理可用于调用任何方法处理给定类型的，如 
         <a href="../../../java/lang/invoke/MethodHandle.html#invokeExact-java.lang.Object...-"><code>invokeExact</code></a>。由此产生的调用将有一个类型，正好等于所需类型，除了它将接受型 
         <code>MethodHandle</code>额外的主要论点。 
         <p data-fanyi="1">此方法等效于下面的代码（尽管它可能是更有效的）：<code>publicLookup().findVirtual(MethodHandle.class, "invokeExact", type)</code></p> 
         <p style="font-size:smaller;" data-fanyi="1">讨论：调用方法处理可以是有用的工作时变未知类型的处理方法。例如，模拟<code>invokeExact</code>调用变量的方法处理<code>M</code>，提取其型<code>T</code>，查找<code>T</code>调用方法<code>X</code>，并调用调用的方法，为<code>X.invoke(T, A...)</code>。（这并不是说<code>X.invokeExact</code>，因为类型<code>T</code>是未知的。）如果蔓延，收集，或其他参数的转换是必需的，他们可以应用一次调用<code>X</code>和重复使用在许多<code>M</code>方法处理的值，只要是与<code>X</code>类型兼容。</p> 
         <p style="font-size:smaller;" data-fanyi="1">（注：调用方法是不通过反射API的核心。试图呼吁宣布invokeexact java.lang.reflect.method.invoke或调用方法将提高UnsupportedOperationException。）</p> 
         <p data-fanyi="1">此方法不抛出任何反射或安全异常。</p> 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>type</code> -目标型 
         </dd> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           一种适用于调用给定类型的任何方法句柄的方法处理 
         </dd> 
         <dt> 
          <span class="throwsLabel">异常</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code>如果产生的方法处理的类型会 
          <a href="MethodHandle.html#maxarity">too many parameters</a> 
         </dd> 
        </dl> </li> 
      </ul> <a name="invoker-java.lang.invoke.MethodType-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>invoker</h4> <pre>public static&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;invoker(<a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;type)</pre> 
        <div class="block" data-fanyi="1">
          产生了一种特殊的调用方法处理可用于调用任何方法处理符合给定的类型，如 
         <a href="../../../java/lang/invoke/MethodHandle.html#invoke-java.lang.Object...-"><code>invoke</code></a>。由此产生的调用将有一个类型，正好等于所需类型，除了它将接受型 
         <code>MethodHandle</code>额外的主要论点。 
         <p data-fanyi="1">调用其目标之前，如果目标不同于预期的类型，调用程序将参考下必要和箱、拆箱、或扩大原始值，如<a href="../../../java/lang/invoke/MethodHandle.html#asType-java.lang.invoke.MethodType-"><code>asType</code></a>。同样，返回值将被转换为必要的。如果目标是一个<a href="../../../java/lang/invoke/MethodHandle.html#asVarargsCollector-java.lang.Class-">variable arity method handle</a>，所需数量的转换将，又如<a href="../../../java/lang/invoke/MethodHandle.html#asType-java.lang.invoke.MethodType-"><code>asType</code></a>。</p> 
         <p data-fanyi="1">此方法等效于下面的代码（尽管它可能是更有效的）：<code>publicLookup().findVirtual(MethodHandle.class, "invoke", type)</code></p> 
         <p style="font-size:smaller;" data-fanyi="1">讨论：一个<a href="../../../java/lang/invoke/MethodType.html#genericMethodType-int-boolean-">general method type</a>是其中只提到<code>Object</code>参数和返回值。这种类型的调用可以调用任何方法处理相同数量的一般类型。</p> 
         <p style="font-size:smaller;" data-fanyi="1">（注：调用方法是不通过反射API的核心。试图呼吁宣布invokeexact java.lang.reflect.method.invoke或调用方法将提高UnsupportedOperationException。）</p> 
         <p data-fanyi="1">此方法不抛出任何反射或安全异常。</p> 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>type</code> -目标型 
         </dd> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           一种适用于调用任何方法处理可转换为给定类型的方法的方法 
         </dd> 
         <dt> 
          <span class="throwsLabel">异常</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code>如果产生的方法处理的类型会 
          <a href="MethodHandle.html#maxarity">too many parameters</a> 
         </dd> 
        </dl> </li> 
      </ul> <a name="explicitCastArguments-java.lang.invoke.MethodHandle-java.lang.invoke.MethodType-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>explicitCastArguments</h4> <pre>public static&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;explicitCastArguments(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target,
                                                 <a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;newType)</pre> 
        <div class="block" data-fanyi="1">
          通过成对的参数和返回类型转换，生成一个适应给定方法句柄类型的方法句柄。原始类型和新类型必须具有相同数量的参数。由此产生的方法处理保证报告一个类型，这是等于所需的新类型。 
         <p data-fanyi="1">如果原始类型和新类型是相等的，则返回目标。</p> 
         <p data-fanyi="1">同样的转换都可以作为<a href="../../../java/lang/invoke/MethodHandle.html#asType-java.lang.invoke.MethodType-"><code>MethodHandle.asType</code></a>，和一些附加的转换也是如果转换失败的应用。给定类型的T0，T1，下列转换应用如果可能的话，在任何转换或代替了<code>asType</code>：</p> 
         <ul data-fanyi="1"> 
          <li data-fanyi="1">如果T0和T1是引用，和T1是接口类型，那么类型T0的值作为一个T1没有投过。（这个处理接口遵循字节码校验器的用法）</li> 
          <li data-fanyi="1">如果T0是布尔和T1是一个原始的逻辑转换为一个字节的值，1为真，0为假。（此为治疗字节码校验器的用法）</li> 
          <li data-fanyi="1">如果T1与T0是一个原始的布尔值，T0是转换为字节通过java铸造转换（JLS 5.5），和结果的低阶位的测试，如<code>(x &amp; 1) != 0</code>。</li> 
          <li data-fanyi="1">如果T0和T1非布尔原语，然后一个java铸造转换（JLS 5.5）应用。（特别是T0将转换为T1的扩大或缩小。）</li> 
          <li data-fanyi="1">如果T0是参考和T1原始的拆箱转换将被应用在运行时，可能随后java铸造转换（JLS 5.5）的原始值，可能随后转换字节布尔测试的低阶位。</li> 
          <li data-fanyi="1">如果T0是参考和T1原始，如果引用为null时，介绍了一零值。</li> 
         </ul> 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>target</code> -处理方法调用后的参数重新输入 
         </dd> 
         <dd data-fanyi="1"> 
          <code>newType</code> --新方法处理预期的类型 
         </dd> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           在执行任何必要的参数转换后，将委托给目标的方法处理，并安排必要的返回值转换 
         </dd> 
         <dt> 
          <span class="throwsLabel">异常</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> -如果任一参数为null 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/invoke/WrongMethodTypeException.html" title="class in java.lang.invoke">WrongMethodTypeException</a></code> -如果转换不能 
         </dd> 
         <dt> 
          <span class="seeLabel">另请参见：</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <a href="../../../java/lang/invoke/MethodHandle.html#asType-java.lang.invoke.MethodType-"><code>MethodHandle.asType(java.lang.invoke.MethodType)</code></a> 
         </dd> 
        </dl> </li> 
      </ul> <a name="permuteArguments-java.lang.invoke.MethodHandle-java.lang.invoke.MethodType-int...-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>permuteArguments</h4> <pre>public static&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;permuteArguments(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target,
                                            <a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;newType,
                                            int...&nbsp;reorder)</pre> 
        <div class="block" data-fanyi="1">
          生产法处理适应给定的方法的调用顺序处理一个新的类型，通过重新排列参数。由此产生的方法处理保证报告一个类型，这是等于所需的新类型。 
         <p data-fanyi="1">给定的数组控件的排序。电话<code>#I</code>传入的参数的数量（价值<code>newType.parameterCount()</code>，叫<code>#O</code>输出参数的数量（价值<code>target.type().parameterCount()</code>）。然后重新排序数组的长度必须<code>#O</code>，每个元素必须是非负数小于<code>#I</code>。每<code>N</code>小于<code>#O</code>，<code>N</code>-th外向的争论将会从<code>I</code>-th传入的说法，在<code>I</code>是<code>reorder[N]</code>。</p> 
         <p data-fanyi="1">没有使用参数或返回值转换。每个传入的参数的类型，确定由<code>newType</code>，必须对相应的输出参数或参数类型相同的方法处理目标。<code>newType</code>的返回类型必须对原有的目标返回的类型相同。</p> 
         <p data-fanyi="1">重新排序数组不需要指定一个实际的排列。传入的参数将被复制，如果它的索引出现超过一次在数组中，和传入的参数将被删除，如果它的索引不出现在数组中。在<a href="../../../java/lang/invoke/MethodHandles.html#dropArguments-java.lang.invoke.MethodHandle-int-java.util.List-"><code>dropArguments</code></a>传入的参数的情况下，这是不是在排序数组中可以是任何类型，只有<code>newType</code>确定。</p> 
         <blockquote> 
          <pre><code>
import static java.lang.invoke.MethodHandles.*;
import static java.lang.invoke.MethodType.*;
...
MethodType intfn1 = methodType(int.class, int.class);
MethodType intfn2 = methodType(int.class, int.class, int.class);
MethodHandle sub = ... (int x, int y) -&gt; (x-y) ...;
assert(sub.type().equals(intfn2));
MethodHandle sub1 = permuteArguments(sub, intfn2, 0, 1);
MethodHandle rsub = permuteArguments(sub, intfn2, 1, 0);
assert((int)rsub.invokeExact(1, 100) == 99);
MethodHandle add = ... (int x, int y) -&gt; (x+y) ...;
assert(add.type().equals(intfn2));
MethodHandle twice = permuteArguments(add, intfn1, 0, 0);
assert(twice.type().equals(intfn1));
assert((int)twice.invokeExact(21) == 42);
 </code></pre> 
         </blockquote> 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>target</code> -处理方法调用后的参数重新排序 
         </dd> 
         <dd data-fanyi="1"> 
          <code>newType</code> --新方法处理预期的类型 
         </dd> 
         <dd data-fanyi="1"> 
          <code>reorder</code> -索引数组的排序控制 
         </dd> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           在它滴下未使用的参数和移动和/或复制其他参数时，将委托给目标的方法处理 
         </dd> 
         <dt> 
          <span class="throwsLabel">异常</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> -如果任一参数为空 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code>如果索引数组的长度不相等的目标的数量，或如果任何索引数组元素不为 
          <code>newType</code>参数的一个有效指标，如果在 
          <code>target.type()</code>和 
          <code>newType</code>两对应参数类型不相同， 
         </dd> 
        </dl> </li> 
      </ul> <a name="constant-java.lang.Class-java.lang.Object-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>constant</h4> <pre>public static&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;constant(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;type,
                                    <a href="../../../java/lang/Object.html" title="class in java.lang">Object</a>&nbsp;value)</pre> 
        <div class="block" data-fanyi="1">
          产生一个请求的返回类型的方法句柄，它每次调用时返回给定的常数值。 
         <p data-fanyi="1">在返回方法句柄之前，将传递的值转换为所请求的类型。如果所请求的类型是原始的，则尝试扩大原始转换，尝试其他引用转换。</p> 
         <p data-fanyi="1">返回的方法处理相当于<code>identity(type).bindTo(value)</code>。</p> 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>type</code> -所需的处理方法的返回类型 
         </dd> 
         <dd data-fanyi="1"> 
          <code>value</code>的价值回归 
         </dd> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           给定返回类型的方法句柄和没有返回给定值的参数的方法 
         </dd> 
         <dt> 
          <span class="throwsLabel">异常</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> -如果 
          <code>type</code>参数为null 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/ClassCastException.html" title="class in java.lang">ClassCastException</a></code> -如果该值不能转换为所需的返回类型 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code>如果给定类型 
          <code>void.class</code> 
         </dd> 
        </dl> </li> 
      </ul> <a name="identity-java.lang.Class-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>identity</h4> <pre>public static&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;identity(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;type)</pre> 
        <div class="block" data-fanyi="1">
          产生调用时返回其唯一参数的方法句柄。 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>type</code> -唯一的参数和所需的方法处理返回值的类型 
         </dd> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           一元的方法处理它接受并返回指定类型 
         </dd> 
         <dt> 
          <span class="throwsLabel">异常</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> -如果参数为空 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code>如果给定类型 
          <code>void.class</code> 
         </dd> 
        </dl> </li> 
      </ul> <a name="insertArguments-java.lang.invoke.MethodHandle-int-java.lang.Object...-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>insertArguments</h4> <pre>public static&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;insertArguments(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target,
                                           int&nbsp;pos,
                                           <a href="../../../java/lang/Object.html" title="class in java.lang">Object</a>...&nbsp;values)</pre> 
        <div class="block" data-fanyi="1">
          提供一个目标方法处理在方法句柄调用之前的一个或多个绑定参数。绑定参数对应的目标的正式参数被称为绑定参数。返回一个保存绑定参数的新方法句柄。当它被调用时，它接收到任何不绑定的参数的参数，将保存的参数绑定到它们的相应参数，并调用原始目标。 
         <p data-fanyi="1">新方法句柄的类型将从原来的目标类型下拉绑定参数的类型，因为新的方法句柄将不再需要由它的调用方提供的参数。</p> 
         <p data-fanyi="1">每个给定的参数对象必须匹配相应的绑定参数类型。如果绑定的参数类型是一个原始的，争论的对象必须是一个包装，并将取消装箱产生的原始值。</p> 
         <p data-fanyi="1"><code>pos</code>参数选取的参数是被束缚的。它可以零和nulln-1之间的范围内（含），在nulln是目标方法处理和零个数的值是数组的长度。</p> 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>target</code> -处理方法调用插入后的争论 
         </dd> 
         <dd data-fanyi="1"> 
          <code>pos</code> -如何插入参数（零为第一） 
         </dd> 
         <dd data-fanyi="1"> 
          <code>values</code> -参数序列插入 
         </dd> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           在调用原始方法句柄之前插入一个额外参数的方法处理 
         </dd> 
         <dt> 
          <span class="throwsLabel">异常</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> -如果目标或 
          <code>values</code>数组是空的 
         </dd> 
         <dt> 
          <span class="seeLabel">另请参见：</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <a href="../../../java/lang/invoke/MethodHandle.html#bindTo-java.lang.Object-"><code>MethodHandle.bindTo(java.lang.Object)</code></a> 
         </dd> 
        </dl> </li> 
      </ul> <a name="dropArguments-java.lang.invoke.MethodHandle-int-java.util.List-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>dropArguments</h4> <pre>public static&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;dropArguments(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target,
                                         int&nbsp;pos,
                                         <a href="../../../java/util/List.html" title="interface in java.util">List</a>&lt;<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;&gt;&nbsp;valueTypes)</pre> 
        <div class="block" data-fanyi="1">
          产生的方法处理，会丢弃一些虚拟的参数调用其他一些指定的空目标方法处理前。新方法处理的类型将与目标类型相同，但它也将包括哑参数类型，在某个给定位置。 
         <p data-fanyi="1">的<code>pos</code>说法可能零和nulln之间的范围内，在nulln是目标的数量。如果<code>pos</code>为零，虚拟的争论将先于目标的真正的辩论；如果<code>pos</code>是nulln他们会来后。</p> 
         <p data-fanyi="1"><b data-fanyi="1">例子:</b></p> 
         <blockquote> 
          <pre><code>
import static java.lang.invoke.MethodHandles.*;
import static java.lang.invoke.MethodType.*;
...
MethodHandle cat = lookup().findVirtual(String.class,
  "concat", methodType(String.class, String.class));
assertEquals("xy", (String) cat.invokeExact("x", "y"));
MethodType bigType = cat.type().insertParameterTypes(0, int.class, String.class);
MethodHandle d0 = dropArguments(cat, 0, bigType.parameterList().subList(0,2));
assertEquals(bigType, d0.type());
assertEquals("yz", (String) d0.invokeExact(123, "x", "y", "z"));
 </code></pre> 
         </blockquote> 
         <p data-fanyi="1">此方法也相当于下面的代码：</p> 
         <blockquote> 
          <pre>
 <a href="../../../java/lang/invoke/MethodHandles.html#dropArguments-java.lang.invoke.MethodHandle-int-java.lang.Class...-"><code>dropArguments</code></a><code> (target, pos, valueTypes.toArray(new Class[0]))</code>
 </pre> 
         </blockquote> 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>target</code> -处理方法调用的参数后下降 
         </dd> 
         <dd data-fanyi="1"> 
          <code>valueTypes</code>型（S）的参数（S）下降 
         </dd> 
         <dd data-fanyi="1"> 
          <code>pos</code> -第一个参数的位置下降（零的左边） 
         </dd> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           一种方法处理给定类型的参数的方法，在调用原始方法句柄之前 
         </dd> 
         <dt> 
          <span class="throwsLabel">异常</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> -如果目标是零，或者如果 
          <code>valueTypes</code>列表或其任何元素是空的 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> -如果 
          <code>valueTypes</code>任何元素 
          <code>void.class</code>，或者如果 
          <code>pos</code>阴性或超过目标的数量，或如果新方法处理的类型会有太多的参数 
         </dd> 
        </dl> </li> 
      </ul> <a name="dropArguments-java.lang.invoke.MethodHandle-int-java.lang.Class...-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>dropArguments</h4> <pre>public static&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;dropArguments(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target,
                                         int&nbsp;pos,
                                         <a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;...&nbsp;valueTypes)</pre> 
        <div class="block" data-fanyi="1">
          产生的方法处理，会丢弃一些虚拟的参数调用其他一些指定的空目标方法处理前。新方法处理的类型将与目标类型相同，但它也将包括哑参数类型，在某个给定位置。 
         <p data-fanyi="1">的<code>pos</code>说法可能零和nulln之间的范围内，在nulln是目标的数量。如果<code>pos</code>为零，虚拟的争论将先于目标的真正的辩论；如果<code>pos</code>是nulln他们会来后。</p> 
         <p data-fanyi="1"><b data-fanyi="1">例子:</b></p> 
         <blockquote> 
          <pre><code>
import static java.lang.invoke.MethodHandles.*;
import static java.lang.invoke.MethodType.*;
...
MethodHandle cat = lookup().findVirtual(String.class,
  "concat", methodType(String.class, String.class));
assertEquals("xy", (String) cat.invokeExact("x", "y"));
MethodHandle d0 = dropArguments(cat, 0, String.class);
assertEquals("yz", (String) d0.invokeExact("x", "y", "z"));
MethodHandle d1 = dropArguments(cat, 1, String.class);
assertEquals("xz", (String) d1.invokeExact("x", "y", "z"));
MethodHandle d2 = dropArguments(cat, 2, String.class);
assertEquals("xy", (String) d2.invokeExact("x", "y", "z"));
MethodHandle d12 = dropArguments(cat, 1, int.class, boolean.class);
assertEquals("xz", (String) d12.invokeExact("x", 12, true, "z"));
 </code></pre> 
         </blockquote> 
         <p data-fanyi="1">此方法也相当于下面的代码：</p> 
         <blockquote> 
          <pre>
 <a href="../../../java/lang/invoke/MethodHandles.html#dropArguments-java.lang.invoke.MethodHandle-int-java.util.List-"><code>dropArguments</code></a><code> (target, pos, Arrays.asList(valueTypes))</code>
 </pre> 
         </blockquote> 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>target</code> -处理方法调用的参数后下降 
         </dd> 
         <dd data-fanyi="1"> 
          <code>valueTypes</code>型（S）的参数（S）下降 
         </dd> 
         <dd data-fanyi="1"> 
          <code>pos</code> -第一个参数的位置下降（零的左边） 
         </dd> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           一种方法处理给定类型的参数的方法，在调用原始方法句柄之前 
         </dd> 
         <dt> 
          <span class="throwsLabel">异常</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> -如果目标是零，或者如果 
          <code>valueTypes</code>阵列或其任何元素是空的 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> -如果 
          <code>valueTypes</code>任何元素 
          <code>void.class</code>，或者如果 
          <code>pos</code>阴性或超过目标的数量，或如果新方法处理的类型会 
          <a href="MethodHandle.html#maxarity">too many parameters</a> 
         </dd> 
        </dl> </li> 
      </ul> <a name="filterArguments-java.lang.invoke.MethodHandle-int-java.lang.invoke.MethodHandle...-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>filterArguments</h4> <pre>public static&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;filterArguments(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target,
                                           int&nbsp;pos,
                                           <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>...&nbsp;filters)</pre> 
        <div class="block" data-fanyi="1">
          采用目标法处理由预处理它的一个或多个参数，每一个都有自己独特的过滤功能，然后调用目标各预处理变量的相应的滤波函数的结果取代。 
         <p data-fanyi="1">预处理是由一个或多个方法进行处理，在<code>filters</code>数组元素指定。过滤器的数组的第一个元素对应于目标的<code>pos</code>论点等顺序。</p> 
         <p data-fanyi="1">数组中的空参数被视为身份函数，并将相应的参数保持不变。（如果数组中没有非空元素，则返回原始目标。）每个筛选器应用于适配器的相应参数。</p> 
         <p data-fanyi="1">如果过滤器<code>F</code>适用于目标的<code>N</code>th论点，然后<code>F</code>必须以一个确切的参数处理方法。对<code>F</code>的唯一参数的类型替换目标对应的实参类型的改编方法处理。<code>F</code>的返回类型必须对目标对应的参数类型相同。</p> 
         <p data-fanyi="1">如果有元素的<code>filters</code>是错误（无效或不）不符合参数位置的目标。</p> 
         <p data-fanyi="1"><b data-fanyi="1">例子:</b></p> 
         <blockquote> 
          <pre><code>
import static java.lang.invoke.MethodHandles.*;
import static java.lang.invoke.MethodType.*;
...
MethodHandle cat = lookup().findVirtual(String.class,
  "concat", methodType(String.class, String.class));
MethodHandle upcase = lookup().findVirtual(String.class,
  "toUpperCase", methodType(String.class));
assertEquals("xy", (String) cat.invokeExact("x", "y"));
MethodHandle f0 = filterArguments(cat, 0, upcase);
assertEquals("Xy", (String) f0.invokeExact("x", "y")); // Xy
MethodHandle f1 = filterArguments(cat, 1, upcase);
assertEquals("xY", (String) f1.invokeExact("x", "y")); // xY
MethodHandle f2 = filterArguments(cat, 0, upcase, upcase);
assertEquals("XY", (String) f2.invokeExact("x", "y")); // XY
 </code></pre> 
         </blockquote> 
         <p data-fanyi="1">这是导致适配器的伪代码：</p> 
         <blockquote> 
          <pre><code>
 V target(P... p, A[i]... a[i], B... b);
 A[i] filter[i](V[i]);
 T adapter(P... p, V[i]... v[i], B... b) {
   return target(p..., f[i](v[i])..., b...);
 }
 </code></pre> 
         </blockquote> 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>target</code> -处理方法调用参数过滤后 
         </dd> 
         <dd data-fanyi="1"> 
          <code>pos</code> -第一个参数的位置过滤 
         </dd> 
         <dd data-fanyi="1"> 
          <code>filters</code>方法调用参数初步过滤处理 
         </dd> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           包含指定的参数过滤逻辑的方法处理 
         </dd> 
         <dt> 
          <span class="throwsLabel">异常</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> -如果 
          <code>filters</code>数组为空或目标是 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> -如果一个非空元素的 
          <code>filters</code>不对应实参类型的目标如上面所描述的匹配，或者如果 
          <code>pos+filters.length</code>大于 
          <code>target.type().parameterCount()</code>，或者产生的方法处理的类型会 
          <a href="MethodHandle.html#maxarity">too many parameters</a> 
         </dd> 
        </dl> </li> 
      </ul> <a name="collectArguments-java.lang.invoke.MethodHandle-int-java.lang.invoke.MethodHandle-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>collectArguments</h4> <pre>public static&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;collectArguments(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target,
                                            int&nbsp;pos,
                                            <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;filter)</pre> 
        <div class="block" data-fanyi="1">
          通过预处理与一个过滤器（另一个方法句柄）的参数的子序列来调整目标方法句柄。预处理的参数被过滤函数的结果（如果有的话）所取代。然后，目标是在修改后的（通常是缩短的）参数列表中调用。 
         <p data-fanyi="1">如果过滤器返回一个值，目标必须接受价值为<code>pos</code>其论点的位置，之前和/或之后没有通过的滤波器参数。如果筛选器返回无效，目标必须接受没有传递到筛选器的所有参数。没有理由重新排序，并从过滤器返回结果代替（为了）最初通过适配器参数全序列。</p> 
         <p data-fanyi="1">参数类型（如果有）的过滤器更换零或一个参数目标的类型、位置<code>pos</code>，在产生的适应方法处理。过滤器的返回类型（如果有）必须在位置<code>pos</code>目标参数类型相同，并且目标参数是通过过滤器的返回值提供。</p> 
         <p data-fanyi="1">在所有的情况下，<code>pos</code>必须大于或等于零，和<code>pos</code>也必须小于或等于目标的数量。</p> 
         <p data-fanyi="1"><b data-fanyi="1">例子:</b></p> 
         <blockquote> 
          <pre><code>
import static java.lang.invoke.MethodHandles.*;
import static java.lang.invoke.MethodType.*;
...
MethodHandle deepToString = publicLookup()
  .findStatic(Arrays.class, "deepToString", methodType(String.class, Object[].class));

MethodHandle ts1 = deepToString.asCollector(String[].class, 1);
assertEquals("[strange]", (String) ts1.invokeExact("strange"));

MethodHandle ts2 = deepToString.asCollector(String[].class, 2);
assertEquals("[up, down]", (String) ts2.invokeExact("up", "down"));

MethodHandle ts3 = deepToString.asCollector(String[].class, 3);
MethodHandle ts3_ts2 = collectArguments(ts3, 1, ts2);
assertEquals("[top, [up, down], strange]",
             (String) ts3_ts2.invokeExact("top", "up", "down", "strange"));

MethodHandle ts3_ts2_ts1 = collectArguments(ts3_ts2, 3, ts1);
assertEquals("[top, [up, down], [strange]]",
             (String) ts3_ts2_ts1.invokeExact("top", "up", "down", "strange"));

MethodHandle ts3_ts2_ts3 = collectArguments(ts3_ts2, 1, ts3);
assertEquals("[top, [[up, down, strange], charm], bottom]",
             (String) ts3_ts2_ts3.invokeExact("top", "up", "down", "strange", "charm", "bottom"));
 </code></pre> 
         </blockquote> 
         <p data-fanyi="1">这是导致适配器的伪代码：</p> 
         <blockquote> 
          <pre><code>
 T target(A...,V,C...);
 V filter(B...);
 T adapter(A... a,B... b,C... c) {
   V v = filter(b...);
   return target(a...,v,c...);
 }
 // and if the filter has no arguments:
 T target2(A...,V,C...);
 V filter2();
 T adapter2(A... a,C... c) {
   V v = filter2();
   return target2(a...,v,c...);
 }
 // and if the filter has a void return:
 T target3(A...,C...);
 void filter3(B...);
 void adapter3(A... a,B... b,C... c) {
   filter3(b...);
   return target3(a...,c...);
 }
 </code></pre> 
         </blockquote> 
         <p data-fanyi="1">一个收集适配器<code>collectArguments(mh, 0, coll)</code>相当于一首“褶皱”受影响的参数，然后下降，在单独的步骤如下：</p> 
         <blockquote> 
          <pre><code>
 mh = MethodHandles.dropArguments(mh, 1, coll.type().parameterList()); //step 2
 mh = MethodHandles.foldArguments(mh, coll); //step 1
 </code></pre> 
         </blockquote>如果目标处理方法没有参数除了消耗比结果（如果有）的滤波器 
         <code>coll</code>，然后 
         <code>collectArguments(mh, 0, coll)</code>相当于 
         <code>filterReturnValue(coll, mh)</code>。如果过滤法处理 
         <code>coll</code>消耗一个论点，并产生一个非空的结果，然后 
         <code>collectArguments(mh, N, coll)</code>相当于 
         <code>filterArguments(mh, N, coll)</code>。其它的对等是可能的但需要论证的排列。 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>target</code> -处理方法调用的参数序列后过滤 
         </dd> 
         <dd data-fanyi="1"> 
          <code>pos</code> -第一个适配器参数的位置通过过滤器，和/或目标参数接收滤波器的结果 
         </dd> 
         <dd data-fanyi="1"> 
          <code>filter</code>方法处理调用参数的顺序 
         </dd> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           处理方法包括指定参数序列滤波逻辑 
         </dd> 
         <dt> 
          <span class="throwsLabel">异常</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> -如果任一参数为null 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> -如果 
          <code>filter</code>返回类型是void，不作为目标的 
          <code>pos</code>参数相同，或者如果 
          <code>pos</code>不是0、目标性、包容性之间，或者产生的方法处理的类型会 
          <a href="MethodHandle.html#maxarity">too many parameters</a> 
         </dd> 
         <dt> 
          <span class="seeLabel">另请参见：</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <a href="../../../java/lang/invoke/MethodHandles.html#foldArguments-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-"><code>foldArguments(java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle)</code></a>， 
          <a href="../../../java/lang/invoke/MethodHandles.html#filterArguments-java.lang.invoke.MethodHandle-int-java.lang.invoke.MethodHandle...-"><code>filterArguments(java.lang.invoke.MethodHandle, int, java.lang.invoke.MethodHandle...)</code></a>， 
          <a href="../../../java/lang/invoke/MethodHandles.html#filterReturnValue-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-"><code>filterReturnValue(java.lang.invoke.MethodHandle, java.lang.invoke.MethodHandle)</code></a> 
         </dd> 
        </dl> </li> 
      </ul> <a name="filterReturnValue-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>filterReturnValue</h4> <pre>public static&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;filterReturnValue(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target,
                                             <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;filter)</pre> 
        <div class="block" data-fanyi="1">
          调整一个目标方法处理它的返回值（如果有的话）与一个过滤器（另一个方法处理）处理。过滤器的结果从适配器返回。 
         <p data-fanyi="1">如果目标返回一个值，过滤器必须接受该值作为其唯一的参数。如果目标返回无效，过滤器必须接受没有参数。</p> 
         <p data-fanyi="1">所得到的调整方法处理中的目标的返回类型替换了目标的返回类型。过滤器的参数类型（如果有的话）必须与目标的返回类型相同。</p> 
         <p data-fanyi="1"><b data-fanyi="1">例子:</b></p> 
         <blockquote> 
          <pre><code>
import static java.lang.invoke.MethodHandles.*;
import static java.lang.invoke.MethodType.*;
...
MethodHandle cat = lookup().findVirtual(String.class,
  "concat", methodType(String.class, String.class));
MethodHandle length = lookup().findVirtual(String.class,
  "length", methodType(int.class));
System.out.println((String) cat.invokeExact("x", "y")); // xy
MethodHandle f0 = filterReturnValue(cat, length);
System.out.println((int) f0.invokeExact("x", "y")); // 2
 </code></pre> 
         </blockquote> 
         <p data-fanyi="1">这是导致适配器的伪代码：</p> 
         <blockquote> 
          <pre><code>
 V target(A...);
 T filter(V);
 T adapter(A... a) {
   V v = target(a...);
   return filter(v);
 }
 // and if the target has a void return:
 void target2(A...);
 T filter2();
 T adapter2(A... a) {
   target2(a...);
   return filter2();
 }
 // and if the filter has a void return:
 V target3(A...);
 void filter3(V);
 void adapter3(A... a) {
   V v = target3(a...);
   filter3(v);
 }
 </code></pre> 
         </blockquote> 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>target</code> -处理方法调用的返回值滤波之前 
         </dd> 
         <dd data-fanyi="1"> 
          <code>filter</code>方法处理调用的返回值 
         </dd> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           采用包含指定的返回值滤波逻辑的方法处理 
         </dd> 
         <dt> 
          <span class="throwsLabel">异常</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> -如果任一参数为null 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> -如果 
          <code>filter</code>参数列表不目标的返回类型为上述比赛 
         </dd> 
        </dl> </li> 
      </ul> <a name="foldArguments-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>foldArguments</h4> <pre>public static&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;foldArguments(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target,
                                         <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;combiner)</pre> 
        <div class="block" data-fanyi="1">
          通过预处理某些参数的预处理来调整目标方法句柄，然后将该目标与预处理的结果调用，并插入到原始参数的序列中。 
         <p data-fanyi="1">预处理是通过<code>combiner</code>，第二种方法处理。传递到适配器的参数，第一个参数是<code>N</code>复制到组合，称为。（在这里，<code>N</code>定义为组合，参数个数）之后，控制权传递到目标，从之前插入原<code>N</code>传入的参数组合的结果。</p> 
         <p data-fanyi="1">如果合并器返回一个值，该目标的第一个参数的类型必须与合成器的返回类型是相同的，和下一步的目标<code>N</code>参数类型必须完全匹配的组合参数。</p> 
         <p data-fanyi="1">如果合并有void返回，没有结果将被插入，和目标的第一<code>N</code>参数类型必须完全匹配的组合参数。</p> 
         <p data-fanyi="1">由此产生的适配器类型作为目标相同，除了第一个参数的类型是下降的，如果它对应的组合的结果。</p> 
         <p data-fanyi="1">（注意，<a href="../../../java/lang/invoke/MethodHandles.html#dropArguments-java.lang.invoke.MethodHandle-int-java.util.List-"><code>dropArguments</code></a>可以用来去除任何争论或者是合成器或目标不希望收到。如果某些输入参数注定只为组合，考虑使用<a href="../../../java/lang/invoke/MethodHandle.html#asCollector-java.lang.Class-int-"><code>asCollector</code></a>相反，因为这些参数将不需要生活在进入目标堆栈。）</p> 
         <p data-fanyi="1"><b data-fanyi="1">例子:</b></p> 
         <blockquote> 
          <pre><code>
import static java.lang.invoke.MethodHandles.*;
import static java.lang.invoke.MethodType.*;
...
MethodHandle trace = publicLookup().findVirtual(java.io.PrintStream.class,
  "println", methodType(void.class, String.class))
    .bindTo(System.out);
MethodHandle cat = lookup().findVirtual(String.class,
  "concat", methodType(String.class, String.class));
assertEquals("boojum", (String) cat.invokeExact("boo", "jum"));
MethodHandle catTrace = foldArguments(cat, trace);
// also prints "boo":
assertEquals("boojum", (String) catTrace.invokeExact("boo", "jum"));
 </code></pre> 
         </blockquote> 
         <p data-fanyi="1">这是导致适配器的伪代码：</p> 
         <blockquote> 
          <pre><code>
 // there are N arguments in A...
 T target(V, A[N]..., B...);
 V combiner(A...);
 T adapter(A... a, B... b) {
   V v = combiner(a...);
   return target(v, a..., b...);
 }
 // and if the combiner has a void return:
 T target2(A[N]..., B...);
 void combiner2(A...);
 T adapter2(A... a, B... b) {
   combiner2(a...);
   return target2(a..., b...);
 }
 </code></pre> 
         </blockquote> 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>target</code> -处理方法调用后的参数组合 
         </dd> 
         <dd data-fanyi="1"> 
          <code>combiner</code>方法处理调用最初传入的参数 
         </dd> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           包含指定的参数折叠逻辑的方法句柄 
         </dd> 
         <dt> 
          <span class="throwsLabel">异常</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> -如果任一参数为null 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> -如果 
          <code>combiner</code>的返回类型是非空，不一样的目标的第一个参数的类型，或者如果目标初始 
          <code>N</code>参数类型（跳过一个匹配的 
          <code>combiner</code>的返回类型）不与 
          <code>combiner</code>参数类型相同 
         </dd> 
        </dl> </li> 
      </ul> <a name="guardWithTest-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>guardWithTest</h4> <pre>public static&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;guardWithTest(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;test,
                                         <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target,
                                         <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;fallback)</pre> 
        <div class="block" data-fanyi="1">
          使一个方法处理适应一个目标方法句柄，通过使用一个测试，一个布尔值方法句柄来保护它。如果保护失败，回退处理称为相反。所有三种方法处理都必须具有相同的参数和返回类型，但测试的返回类型必须为布尔值，并且允许测试的参数比其他两个方法处理的要少。 
         <p data-fanyi="1">这是导致适配器的伪代码：</p> 
         <blockquote> 
          <pre><code>
 boolean test(A...);
 T target(A...,B...);
 T fallback(A...,B...);
 T adapter(A... a,B... b) {
   if (test(a...))
     return target(a..., b...);
   else
     return fallback(a..., b...);
 }
 </code></pre> 
         </blockquote>注意测试参数（ 
         <code>a...</code>在伪代码）不能通过的测试执行的修改，所以从调用者的目标或回退适当。 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>test</code>方法处理用于试验，必须返回布尔值 
         </dd> 
         <dd data-fanyi="1"> 
          <code>target</code>法处理如果测试通过电话 
         </dd> 
         <dd data-fanyi="1"> 
          <code>fallback</code>方法如果测试失败呼叫处理 
         </dd> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           方法处理包含指定的，如果/然后/其他逻辑 
         </dd> 
         <dt> 
          <span class="throwsLabel">异常</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> -如果任一参数为空 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> -如果 
          <code>test</code>不返回布尔值，或如果所有三种类型不匹配（与 
          <code>test</code>返回类型更改为匹配的目标）。 
         </dd> 
        </dl> </li> 
      </ul> <a name="catchException-java.lang.invoke.MethodHandle-java.lang.Class-java.lang.invoke.MethodHandle-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>catchException</h4> <pre>public static&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;catchException(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target,
                                          <a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;? extends <a href="../../../java/lang/Throwable.html" title="class in java.lang">Throwable</a>&gt;&nbsp;exType,
                                          <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;handler)</pre> 
        <div class="block" data-fanyi="1">
          通过在异常处理程序中运行它，使一个适应目标方法句柄的方法处理。如果目标返回正常，适配器返回该值。如果一个异常匹配指定的类型被称为回退处理，而不是例外，加上原来的论点。 
         <p data-fanyi="1">目标和相应的处理程序必须具有相同的参数和返回类型，除了处理程序可以省略尾参数（类似于<a href="../../../java/lang/invoke/MethodHandles.html#guardWithTest-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-java.lang.invoke.MethodHandle-"><code>guardWithTest</code></a>谓语）。同时，处理器必须有<code>exType</code>或超额外的主要参数。</p> 
         <p data-fanyi="1">这是导致适配器的伪代码：</p> 
         <blockquote> 
          <pre><code>
 T target(A..., B...);
 T handler(ExType, A...);
 T adapter(A... a, B... b) {
   try {
     return target(a..., b...);
   } catch (ExType ex) {
     return handler(ex, a...);
   }
 }
 </code></pre> 
         </blockquote>注意保存的参数（ 
         <code>a...</code>在伪代码）不能由目标执行修改，所以从调用者的句柄，如果调用处理程序。 
         <p data-fanyi="1">目标和处理程序必须返回同一类型，即使处理程序总是抛出。（这可能发生，例如，因为处理程序是模拟<code>finally</code>条款）。创造这样一个抛处理，与<a href="../../../java/lang/invoke/MethodHandles.html#throwException-java.lang.Class-java.lang.Class-"><code>throwException</code></a>构成处理器生成逻辑，为了创造一个正确的返回类型的方法处理。</p> 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>target</code>方法处理呼叫 
         </dd> 
         <dd data-fanyi="1"> 
          <code>exType</code> -类型的异常处理程序将捕获的 
         </dd> 
         <dd data-fanyi="1"> 
          <code>handler</code>法处理如果匹配的异常被抛出的电话 
         </dd> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           方法包含指定的尝试/捕获逻辑的方法句柄 
         </dd> 
         <dt> 
          <span class="throwsLabel">异常</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> -如果任一参数为空 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> -如果 
          <code>handler</code>不接受特定的异常类型，或如果方法处理类型不在其返回类型及相应的参数匹配 
         </dd> 
        </dl> </li> 
      </ul> <a name="throwException-java.lang.Class-java.lang.Class-"> 
       <!--   --> </a> 
      <ul class="blockListLast"> 
       <li class="blockList"> <h4>throwException</h4> <pre>public static&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;throwException(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;returnType,
                                          <a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;? extends <a href="../../../java/lang/Throwable.html" title="class in java.lang">Throwable</a>&gt;&nbsp;exType)</pre> 
        <div class="block" data-fanyi="1">
          产生的方法处理，将给定的 
         <code>exType</code>例外。处理方法将接受一个参数 
         <code>exType</code>，立即把它作为例外。该方法将名义上指定返回的 
         <code>returnType</code>。返回类型可能是任何方便的：它不重要的方法处理的行为，因为它将永远不会返回。 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>returnType</code> -所需的处理方法的返回类型 
         </dd> 
         <dd data-fanyi="1"> 
          <code>exType</code> -所需的处理方法的参数类型 
         </dd> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           方法处理可以抛出给定的异常的方法 
         </dd> 
         <dt> 
          <span class="throwsLabel">异常</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> -如果任一参数为null 
         </dd> 
        </dl> </li> 
      </ul> </li> 
    </ul> </li> 
  </ul> 
 </div> 
</div> 
<!-- ========= END OF CLASS DATA ========= --> 
<!-- ======= START OF BOTTOM NAVBAR ====== --> 
<div class="bottomNav"> 
 <a name="navbar.bottom"> 
  <!--   --> </a> 
 <div class="skipNav"> 
  <a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a> 
 </div> 
 <a name="navbar.bottom.firstrow"> 
  <!--   --> </a> 
 <ul class="navList" title="Navigation"> 
  <li><a href="../../../overview-summary.html">概述</a></li> 
  <li><a href="package-summary.html">软件包</a></li> 
  <li class="navBarCell1Rev">类</li> 
  <li><a href="class-use/MethodHandles.html">使用</a></li> 
  <li><a href="package-tree.html">树</a></li> 
  <li><a href="../../../deprecated-list.html">已过时的</a></li> 
  <li><a href="../../../index-files/index-1.html">索引</a></li> 
  <li><a href="../../../help-doc.html">帮助</a></li> 
 </ul> 
 <div class="aboutLanguage"> 
  <strong>Java™&nbsp;Platform<br>Standard&nbsp;Ed.&nbsp;8</strong> 
 </div> 
</div> 
<div class="subNav"> 
 <ul class="navList"> 
  <li><a href="../../../java/lang/invoke/MethodHandleProxies.html" title="class in java.lang.invoke"><span class="typeNameLink">上一个</span></a></li> 
  <li><a href="../../../java/lang/invoke/MethodHandles.Lookup.html" title="class in java.lang.invoke"><span class="typeNameLink">下一个</span></a></li> 
 </ul> 
 <ul class="navList"> 
  <li><a href="../../../index.html?java/lang/invoke/MethodHandles.html" target="_top">框架</a></li> 
  <li><a href="MethodHandles.html" target="_top">无框架</a></li> 
 </ul> 
 <ul class="navList" id="allclasses_navbar_bottom"> 
  <li><a href="../../../allclasses-noframe.html">所有类</a></li> 
 </ul> 
 <div> 
  <script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script> 
 </div> 
 <div> 
  <ul class="subNavList"> 
   <li>概要：</li> 
   <li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li> 
   <li>字段</li> 
   <li>构造方法</li> 
   <li><a href="#method.summary">方法</a></li> 
  </ul> 
  <ul class="subNavList"> 
   <li>详细信息：</li> 
   <li>字段</li> 
   <li>构造方法</li> 
   <li><a href="#method.detail">方法</a></li> 
  </ul> 
 </div> 
 <a name="skip.navbar.bottom"> 
  <!--   --> </a> 
</div> 
<!-- ======== END OF BOTTOM NAVBAR ======= --> 
<p class="legalCopy"><small><font size="-1"> <a href="http://bugreport.sun.com/bugreport/">Submit a bug or feature</a> <br>For further API reference and developer documentation, see <a href="http://download.oracle.com/javase/8/docs/index.html" target="_blank">Java SE Documentation</a>. That documentation contains more detailed, developer-targeted descriptions, with conceptual overviews, definitions of terms, workarounds, and working code examples.<br> Copyright © 1993, 2014, Oracle and/or its affiliates. All rights reserved. </font></small> </p> 
<div id="adDiv"> 


 <div></div> 
</div> 
<p></p>