<!-- NewPage -->   
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<!-- Generated by javadoc (1.8.0) on Tue Mar 04 03:13:27 PST 2014 --> 
<title>java.lang.invoke (Java Platform SE 8 )</title> 
<meta name="date" content="2014-03-04"> 
<meta name="keywords" content="java.lang.invoke package"> 
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style"> 
<script type="text/javascript" src="../../../script.js"></script> 
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="java.lang.invoke (Java Platform SE 8 )";
        }
    }
    catch(err) {
    }
//-->
</script> 
<noscript>
  &lt;div&gt; JavaScript is disabled on your browser. 
</noscript> 
<!-- ========= START OF TOP NAVBAR ======= -->   
<div class="topNav"> 
 <a name="navbar.top"> 
  <!--   --> </a> 
 <div class="skipNav"> 
  <a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a> 
 </div> 
 <a name="navbar.top.firstrow"> 
  <!--   --> </a> 
 <ul class="navList" title="Navigation"> 
  <li><a href="../../../overview-summary.html">概述</a></li> 
  <li class="navBarCell1Rev">软件包</li> 
  <li>类</li> 
  <li><a href="package-use.html">使用</a></li> 
  <li><a href="package-tree.html">树</a></li> 
  <li><a href="../../../deprecated-list.html">已过时的</a></li> 
  <li><a href="../../../index-files/index-1.html">索引</a></li> 
  <li><a href="../../../help-doc.html">帮助</a></li> 
 </ul> 
 <div class="aboutLanguage"> 
  <strong>Java™&nbsp;Platform<br>Standard&nbsp;Ed.&nbsp;8</strong> 
 </div> 
</div> 
<div class="subNav"> 
 <ul class="navList"> 
  <li><a href="../../../java/lang/annotation/compact1-package-summary.html">Prev&nbsp;Package</a></li> 
  <li><a href="../../../java/lang/ref/compact1-package-summary.html">Next&nbsp;Package</a></li> 
 </ul> 
 <ul class="navList"> 
  <li><a href="../../../index.html?java/lang/invoke/compact1-package-summary.html" target="_top">框架</a></li> 
  <li><a href="compact1-package-summary.html" target="_top">无框架</a></li> 
 </ul> 
 <ul class="navList" id="allclasses_navbar_top"> 
  <li><a href="../../../allclasses-noframe.html">所有类</a></li> 
 </ul> 
 <div> 
  <script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script> 
 </div> 
 <a name="skip.navbar.top"> 
  <!--   --> </a> 
</div> 
<!-- ========= END OF TOP NAVBAR ========= --> 
<div class="header"> 
 <div class="subTitle">
   compact1 
 </div> 
 <h1 title="Package" class="title">Package&nbsp;java.lang.invoke</h1> 
 <div class="docSummary"> 
  <div class="block" data-fanyi="1"> 
   <code>java.lang.invoke</code>包中包含的动态语言支持的java核心类库和虚拟机直接提供。 
  </div> 
 </div> 
 <p>See:&nbsp;<a href="#package.description">描述</a></p> 
</div> 
<div class="contentContainer"> 
 <ul class="blockList"> 
  <li class="blockList"> 
   <table class="typeSummary" border="0" cellpadding="3" cellspacing="0" summary="Interface Summary table, listing interfaces, and an explanation"> 
    <caption> 
     <span>接口摘要</span> 
     <span class="tabEnd">&nbsp;</span> 
    </caption> 
    <tbody> 
     <tr> 
      <th class="colFirst" scope="col">接口</th> 
      <th class="colLast" scope="col">描述</th> 
     </tr> 
    </tbody> 
    <tbody> 
     <tr class="altColor"> 
      <td class="colFirst"><a href="../../../java/lang/invoke/MethodHandleInfo.html" title="interface in java.lang.invoke">MethodHandleInfo</a></td> 
      <td class="colLast"> 
       <div class="block" data-fanyi="1">
         一个符号引用的直接方法处理开裂成成分符号部分获得。 
       </div> </td> 
     </tr> 
    </tbody> 
   </table> </li> 
  <li class="blockList"> 
   <table class="typeSummary" border="0" cellpadding="3" cellspacing="0" summary="Class Summary table, listing classes, and an explanation"> 
    <caption> 
     <span>类摘要</span> 
     <span class="tabEnd">&nbsp;</span> 
    </caption> 
    <tbody> 
     <tr> 
      <th class="colFirst" scope="col">类</th> 
      <th class="colLast" scope="col">描述</th> 
     </tr> 
    </tbody> 
    <tbody> 
     <tr class="altColor"> 
      <td class="colFirst"><a href="../../../java/lang/invoke/CallSite.html" title="class in java.lang.invoke">CallSite</a></td> 
      <td class="colLast"> 
       <div class="block" data-fanyi="1">
         一个 
        <code>CallSite</code>是一个变量 
        <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke"><code>MethodHandle</code></a>持有人，即其 
        <code>target</code>。 
       </div> </td> 
     </tr> 
     <tr class="rowColor"> 
      <td class="colFirst"><a href="../../../java/lang/invoke/ConstantCallSite.html" title="class in java.lang.invoke">ConstantCallSite</a></td> 
      <td class="colLast"> 
       <div class="block" data-fanyi="1">
         一个 
        <code>ConstantCallSite</code>是 
        <a href="../../../java/lang/invoke/CallSite.html" title="class in java.lang.invoke"><code>CallSite</code></a>其目标是永久的，而且永远不会改变。 
       </div> </td> 
     </tr> 
     <tr class="altColor"> 
      <td class="colFirst"><a href="../../../java/lang/invoke/LambdaMetafactory.html" title="class in java.lang.invoke">LambdaMetafactory</a></td> 
      <td class="colLast"> 
       <div class="block" data-fanyi="1">
         方法方便简单的“对象”，实现由一个或多个接口，一个代表团提供 
        <a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke"><code>MethodHandle</code></a>创作，可能在式改编和部分论据评价。 
       </div> </td> 
     </tr> 
     <tr class="rowColor"> 
      <td class="colFirst"><a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></td> 
      <td class="colLast"> 
       <div class="block" data-fanyi="1">
         方法句柄是一个类型化的，直接可执行的引用到一个基本的方法、构造函数、字段或类似的低级操作，具有可选的参数或返回值的转换。 
       </div> </td> 
     </tr> 
     <tr class="altColor"> 
      <td class="colFirst"><a href="../../../java/lang/invoke/MethodHandleProxies.html" title="class in java.lang.invoke">MethodHandleProxies</a></td> 
      <td class="colLast"> 
       <div class="block" data-fanyi="1">
         这类由专门的静态方法，帮助适应方法处理其他JVM类型，如接口。 
       </div> </td> 
     </tr> 
     <tr class="rowColor"> 
      <td class="colFirst"><a href="../../../java/lang/invoke/MethodHandles.html" title="class in java.lang.invoke">MethodHandles</a></td> 
      <td class="colLast"> 
       <div class="block" data-fanyi="1">
         这个类完全由操作或返回方法处理的静态方法组成。 
       </div> </td> 
     </tr> 
     <tr class="altColor"> 
      <td class="colFirst"><a href="../../../java/lang/invoke/MethodHandles.Lookup.html" title="class in java.lang.invoke">MethodHandles.Lookup</a></td> 
      <td class="colLast"> 
       <div class="block" data-fanyi="1">
         查找对象是一个用于创建方法句柄的工厂，当创建需要访问检查时。 
       </div> </td> 
     </tr> 
     <tr class="rowColor"> 
      <td class="colFirst"><a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke">MethodType</a></td> 
      <td class="colLast"> 
       <div class="block" data-fanyi="1">
         方法类型表示接受和返回的参数和返回类型的方法处理，或通过方法处理调用方传递的参数和返回类型。 
       </div> </td> 
     </tr> 
     <tr class="altColor"> 
      <td class="colFirst"><a href="../../../java/lang/invoke/MutableCallSite.html" title="class in java.lang.invoke">MutableCallSite</a></td> 
      <td class="colLast"> 
       <div class="block" data-fanyi="1">
         一个 
        <code>MutableCallSite</code>是一个目标变量的行为像一个普通的领域 
        <a href="../../../java/lang/invoke/CallSite.html" title="class in java.lang.invoke"><code>CallSite</code></a>。 
       </div> </td> 
     </tr> 
     <tr class="rowColor"> 
      <td class="colFirst"><a href="../../../java/lang/invoke/SerializedLambda.html" title="class in java.lang.invoke">SerializedLambda</a></td> 
      <td class="colLast"> 
       <div class="block" data-fanyi="1">
         序列化形式的lambda表达式。 
       </div> </td> 
     </tr> 
     <tr class="altColor"> 
      <td class="colFirst"><a href="../../../java/lang/invoke/SwitchPoint.html" title="class in java.lang.invoke">SwitchPoint</a></td> 
      <td class="colLast"> 
       <div class="block" data-fanyi="1">
         一个 
        <code>SwitchPoint</code>是可以发布状态转换到其他线程对象。 
       </div> </td> 
     </tr> 
     <tr class="rowColor"> 
      <td class="colFirst"><a href="../../../java/lang/invoke/VolatileCallSite.html" title="class in java.lang.invoke">VolatileCallSite</a></td> 
      <td class="colLast"> 
       <div class="block" data-fanyi="1">
         一个 
        <code>VolatileCallSite</code>是 
        <a href="../../../java/lang/invoke/CallSite.html" title="class in java.lang.invoke"><code>CallSite</code></a>其目标行为一个volatile变量一样。 
       </div> </td> 
     </tr> 
    </tbody> 
   </table> </li> 
  <li class="blockList"> 
   <table class="typeSummary" border="0" cellpadding="3" cellspacing="0" summary="Exception Summary table, listing exceptions, and an explanation"> 
    <caption> 
     <span>异常摘要</span> 
     <span class="tabEnd">&nbsp;</span> 
    </caption> 
    <tbody> 
     <tr> 
      <th class="colFirst" scope="col">异常</th> 
      <th class="colLast" scope="col">描述</th> 
     </tr> 
    </tbody> 
    <tbody> 
     <tr class="altColor"> 
      <td class="colFirst"><a href="../../../java/lang/invoke/LambdaConversionException.html" title="class in java.lang.invoke">LambdaConversionException</a></td> 
      <td class="colLast"> 
       <div class="block" data-fanyi="1">
         lambdaconversionexception 
       </div> </td> 
     </tr> 
     <tr class="rowColor"> 
      <td class="colFirst"><a href="../../../java/lang/invoke/WrongMethodTypeException.html" title="class in java.lang.invoke">WrongMethodTypeException</a></td> 
      <td class="colLast"> 
       <div class="block" data-fanyi="1">
         抛出表示代码试图通过错误的方法类型调用一个方法句柄。 
       </div> </td> 
     </tr> 
    </tbody> 
   </table> </li> 
 </ul> 
 <a name="package.description"> 
  <!--   --> </a> 
 <h2 title="Package java.lang.invoke Description">Package java.lang.invoke Description</h2> 
 <div class="block" data-fanyi="1"> 
  <code>java.lang.invoke</code>包中包含的动态语言支持的java核心类库和虚拟机直接提供。 
  <p data-fanyi="1">在java虚拟机的规范描述，这个包一定类型的虚拟机有特殊关系的动态语言支持：</p> 
  <ul data-fanyi="1"> 
   <li data-fanyi="1">这类<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke"><code>MethodHandle</code></a>包含<a href="../../../java/lang/invoke/MethodHandle.html#sigpoly">signature polymorphic methods</a>可以链接不论其类型说明符。通常情况下，方法键需要类型描述符的精确匹配。</li> 
   <li data-fanyi="1">JVM字节码格式支持的类<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke"><code>MethodHandle</code></a>和<a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke"><code>MethodType</code></a>立即常数。</li> 
  </ul> 
  <h1 data-fanyi="1">有关java虚拟机的变化<a name="../../../java/lang/invoke/jvm_mods"></a>summary</h1>以下的底层信息总结了java虚拟机规范的相关部分。对于完整的细节，请参阅该规范的当前版本。每发生一 
  <code>invokedynamic</code>指令被称为动态调用站点。 
  <h2 data-fanyi="1"><a name="../../../java/lang/invoke/indyinsn"></a><code>invokedynamic</code>指令</h2>动态调用网站最初是在链接的状态。在这种状态下，调用站点调用没有目标方法。 
  <p data-fanyi="1">在JVM可以执行动态调用网站（一个<code>invokedynamic</code>指令），调用点必须首先联系。连接是通过调用一个方法进行调用的网站静态信息内容来完成的，而必须产生一个<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke"><code>method handle</code></a>使调用网站的行为。</p> 
  <p data-fanyi="1">每个<code>invokedynamic</code>指令静态指定自己的Bootstrap方法作为一个常量池参考。常量池引用还指定调用站点的名称和类型说明符，就像<code>invokevirtual</code>和其他调用指令。</p> 
  <p data-fanyi="1">将首先解决了Bootstrap方法的常量池入口，以及解决的动态调用站点类型说明符的一<a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke"><code>MethodType</code></a>对象。这个分辨率的过程可能会触发类加载。因此，它可能会抛出一个错误，如果一个类无法加载。此错误将成为动态调用站点执行的异常终止。关联不触发类初始化。</p> 
  <p data-fanyi="1">引导方法至少在三个值上调用：</p> 
  <ul data-fanyi="1"> 
   <li data-fanyi="1">一个<code>MethodHandles.Lookup</code>，对其中发生的动态调用网站查找对象调用类</li> 
   <li data-fanyi="1">一个<code>String</code>，在调用点提到的方法的名称</li> 
   <li data-fanyi="1">一个<code>MethodType</code>，解决类型说明符的电话</li> 
   <li data-fanyi="1">可选地，在1和251之间额外的静态参数从常量池</li> 
  </ul>调用如 
  <a href="../../../java/lang/invoke/MethodHandle.html#invoke-java.lang.Object...-"><code>MethodHandle.invoke</code></a>。返回的结果必须是一个 
  <a href="../../../java/lang/invoke/CallSite.html" title="class in java.lang.invoke"><code>CallSite</code></a>（或子类）。调用站点的目标类型必须完全等于来自动态调用站点的类型描述符的类型，并传递给引导方法。然后将该呼叫站点永久地连接到动态呼叫站点。 
  <p data-fanyi="1">在Java虚拟机规范的记录，从一个动态调用网站的联动所产生的所有的失败都是由一个<a href="../../../java/lang/BootstrapMethodError.html" title="class in java.lang"><code>BootstrapMethodError</code></a>报道，这被作为动态调用执行异常终止。如果发生这种情况，则将引发相同的错误，以执行动态调用站点的所有后续尝试。</p> 
  <h2 data-fanyi="1">定时联动</h2>动态调用的网站链接就在首次执行。引导方法调用实现联动发生在正在尝试执行第一个执行的线程中。 
  <p data-fanyi="1">如果有几个这样的线程，引导方法可以同时在多个线程中调用。因此，访问全局应用程序数据的引导方法必须采取针对竞争条件的通常的预防措施。在任何情况下，每一<code>invokedynamic</code>指令是链接或链接到一个独特的<code>CallSite</code>对象。</p> 
  <p data-fanyi="1">在一个应用程序，需要单独的行为动态调用的网站，他们的引导方法产生不同的<a href="../../../java/lang/invoke/CallSite.html" title="class in java.lang.invoke"><code>CallSite</code></a>对象，每一个连接请求。另外，应用程序可以单<code>CallSite</code>对象链接到几个<code>invokedynamic</code>指令，在这种情况下，改变目标的方法将在每个指令变得可见。</p> 
  <p data-fanyi="1">如果多个线程同时执行一个方法为一个单一的动态调用站点，JVM必须选择一个<code>CallSite</code>对象并安装它明显的所有线程。任何其他方法调用可以完成，但其结果是不容忽视的，其动态调用站点调用进行最初选择的目标对象。</p> 
  <p style="font-size:smaller;" data-fanyi="1">讨论：这些规则不允许JVM复制动态调用的网站，或者发出“电话无缘无故”的引导方法。每一个动态调用站点转换最多一次从链接的链接，就在第一次调用。没有办法撤消已完成的引导方法调用的效果。</p> 
  <h2 data-fanyi="1">引导方法的类型</h2>只要每个Bootstrap方法可以正确调用 
  <code>MethodHandle.invoke</code>，其详细的类型是任意的。例如，第一个参数可以 
  <code>Object</code>代替 
  <code>MethodHandles.Lookup</code>，和返回类型也可以代替 
  <code>CallSite</code> 
  <code>Object</code>。（注意，和堆叠的参数个数的限制类型的Bootstrap方法的法律类型适当类型的静态方法，子类的构造函数 
  <code>CallSite</code>。） 
  <p data-fanyi="1">如果一个给定的<code>invokedynamic</code>指令指定没有静态参数，指导的方法将三个参数调用，传达指令的调用类，名称，类型和方法。如果<code>invokedynamic</code>指令指定一个或多个静态参数，这些值将作为额外的参数传递的方法处理。（注意，因为有一个限制的255参数的任何方法，最多251个额外的参数可以提供，因为Bootstrap方法处理本身和它的三个参数也必须堆叠。）引导的方法会被调用，如果通过<code>MethodHandle.invoke</code>或<code>invokeWithArguments</code>。（没有办法说出这些区别。）</p> 
  <p data-fanyi="1">正常参数转换规则适用于所有的争论<code>MethodHandle.invoke</code>堆叠。例如，如果一个被推的值是一个原始类型，它可以转换为一个引用，通过装箱转换。如果引导的方法是可变数量的方法（其修改位<code>0x0080</code>设置），然后一些或所有指定的参数可以被收集到一个拖曳阵列参数。（这是不是一个特别的规则，而是一个有用的结果之间的相互作用<code>CONSTANT_MethodHandle</code>常数变元数方法，修改点和<a href="../../../java/lang/invoke/MethodHandle.html#asVarargsCollector-java.lang.Class-"><code>asVarargsCollector</code></a>转化。）</p> 
  <p data-fanyi="1">鉴于这些规则，这是法律的Bootstrap方法声明的示例，给出了不同数量<code>N</code>额外的参数。第一行（标记<code>*</code>）将为任何数目的额外参数的工作。</p> 
  <table border="1" cellpadding="5" summary="Static argument types"> 
   <tbody> 
    <tr> 
     <th>N</th> 
     <th>sample bootstrap method</th> 
    </tr> 
    <tr> 
     <td>*</td> 
     <td><code>CallSite bootstrap(Lookup caller, String name, MethodType type, Object... args)</code></td> 
    </tr> 
    <tr> 
     <td>*</td> 
     <td><code>CallSite bootstrap(Object... args)</code></td> 
    </tr> 
    <tr> 
     <td>*</td> 
     <td><code>CallSite bootstrap(Object caller, Object... nameAndTypeWithArgs)</code></td> 
    </tr> 
    <tr> 
     <td>0</td> 
     <td><code>CallSite bootstrap(Lookup caller, String name, MethodType type)</code></td> 
    </tr> 
    <tr> 
     <td>0</td> 
     <td><code>CallSite bootstrap(Lookup caller, Object... nameAndType)</code></td> 
    </tr> 
    <tr> 
     <td>1</td> 
     <td><code>CallSite bootstrap(Lookup caller, String name, MethodType type, Object arg)</code></td> 
    </tr> 
    <tr> 
     <td>2</td> 
     <td><code>CallSite bootstrap(Lookup caller, String name, MethodType type, Object... args)</code></td> 
    </tr> 
    <tr> 
     <td>2</td> 
     <td><code>CallSite bootstrap(Lookup caller, String name, MethodType type, String... args)</code></td> 
    </tr> 
    <tr> 
     <td>2</td> 
     <td><code>CallSite bootstrap(Lookup caller, String name, MethodType type, String x, int y)</code></td> 
    </tr> 
   </tbody> 
  </table>最后一个例子，假设额外的参数的类型 
  <code>CONSTANT_String</code>和 
  <code>CONSTANT_Integer</code>，分别。第二个例子假设所有额外的参数的类型 
  <code>CONSTANT_String</code>。其他例子与所有类型的额外参数。 
  <p data-fanyi="1">如上所述，引导方法的实际方法类型可能会有所不同。例如，第四个参数可以<code>MethodHandle</code>，如果是在<code>CONSTANT_InvokeDynamic</code>进入相应的常量的类型。在这种情况下，该<code>MethodHandle.invoke</code>呼叫将通过额外的方法处理常量作为<code>Object</code>，但<code>MethodHandle.invoke</code>型匹配机械将参考回<code>MethodHandle</code> Bootstrap方法之前调用。（如果一个字符串常量代替，由差生成的代码，通过投就会失败，导致<code>BootstrapMethodError</code>。）</p> 
  <p data-fanyi="1">请注意，由于上述规则的结果，引导方法可以接受一个原始的参数，如果它可以由一个常量池条目表示。然而，<code>boolean</code>型，<code>byte</code>，<code>short</code>论点，或<code>char</code>不能引导的方法，因为这些常量不能在常量池直接表示，和Bootstrap方法的调用将不会执行必要的窄化转换。</p> 
  <p data-fanyi="1">额外的Bootstrap方法的参数都是为了让语言实现安全、简洁编码元数据。在原则上，名称和额外的参数是多余的，因为每个调用的网站可以给自己独特的引导方法。这样的做法很可能会产生大量的类文件和常量池。</p> 
 </div> 
 <dl> 
  <dt> 
   <span class="simpleTagLabel">从以下版本开始：</span> 
  </dt> 
  <dd>
    1.7 
  </dd> 
 </dl> 
</div> 
<!-- ======= START OF BOTTOM NAVBAR ====== --> 
<div class="bottomNav"> 
 <a name="navbar.bottom"> 
  <!--   --> </a> 
 <div class="skipNav"> 
  <a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a> 
 </div> 
 <a name="navbar.bottom.firstrow"> 
  <!--   --> </a> 
 <ul class="navList" title="Navigation"> 
  <li><a href="../../../overview-summary.html">概述</a></li> 
  <li class="navBarCell1Rev">软件包</li> 
  <li>类</li> 
  <li><a href="package-use.html">使用</a></li> 
  <li><a href="package-tree.html">树</a></li> 
  <li><a href="../../../deprecated-list.html">已过时的</a></li> 
  <li><a href="../../../index-files/index-1.html">索引</a></li> 
  <li><a href="../../../help-doc.html">帮助</a></li> 
 </ul> 
 <div class="aboutLanguage"> 
  <strong>Java™&nbsp;Platform<br>Standard&nbsp;Ed.&nbsp;8</strong> 
 </div> 
</div> 
<div class="subNav"> 
 <ul class="navList"> 
  <li><a href="../../../java/lang/annotation/compact1-package-summary.html">Prev&nbsp;Package</a></li> 
  <li><a href="../../../java/lang/ref/compact1-package-summary.html">Next&nbsp;Package</a></li> 
 </ul> 
 <ul class="navList"> 
  <li><a href="../../../index.html?java/lang/invoke/compact1-package-summary.html" target="_top">框架</a></li> 
  <li><a href="compact1-package-summary.html" target="_top">无框架</a></li> 
 </ul> 
 <ul class="navList" id="allclasses_navbar_bottom"> 
  <li><a href="../../../allclasses-noframe.html">所有类</a></li> 
 </ul> 
 <div> 
  <script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script> 
 </div> 
 <a name="skip.navbar.bottom"> 
  <!--   --> </a> 
</div> 
<!-- ======== END OF BOTTOM NAVBAR ======= --> 
<p class="legalCopy"><small><font size="-1"> <a href="http://bugreport.sun.com/bugreport/">Submit a bug or feature</a> <br>For further API reference and developer documentation, see <a href="http://download.oracle.com/javase/8/docs/index.html" target="_blank">Java SE Documentation</a>. That documentation contains more detailed, developer-targeted descriptions, with conceptual overviews, definitions of terms, workarounds, and working code examples.<br> Copyright © 1993, 2014, Oracle and/or its affiliates. All rights reserved. </font></small> </p> 
<div id="adDiv"> 


 <div></div> 
</div> 
<p></p>