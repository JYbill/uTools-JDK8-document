<!-- NewPage -->   
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<!-- Generated by javadoc (1.8.0) on Tue Mar 04 03:12:46 PST 2014 --> 
<title>MethodHandle (Java Platform SE 8 )</title> 
<meta name="date" content="2014-03-04"> 
<meta name="keywords" content="java.lang.invoke.MethodHandle class"> 
<meta name="keywords" content="type()"> 
<meta name="keywords" content="invokeExact()"> 
<meta name="keywords" content="invoke()"> 
<meta name="keywords" content="invokeWithArguments()"> 
<meta name="keywords" content="asType()"> 
<meta name="keywords" content="asSpreader()"> 
<meta name="keywords" content="asCollector()"> 
<meta name="keywords" content="asVarargsCollector()"> 
<meta name="keywords" content="isVarargsCollector()"> 
<meta name="keywords" content="asFixedArity()"> 
<meta name="keywords" content="bindTo()"> 
<meta name="keywords" content="toString()"> 
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style"> 
<script type="text/javascript" src="../../../script.js"></script> 
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="MethodHandle (Java Platform SE 8 )";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":10,"i1":10,"i2":10,"i3":10,"i4":10,"i5":10,"i6":10,"i7":10,"i8":10,"i9":10,"i10":10,"i11":10,"i12":10};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script> 
<noscript>
  &lt;div&gt; JavaScript is disabled on your browser. 
</noscript> 
<!-- ========= START OF TOP NAVBAR ======= -->   
<div class="topNav"> 
 <a name="navbar.top"> 
  <!--   --> </a> 
 <div class="skipNav"> 
  <a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a> 
 </div> 
 <a name="navbar.top.firstrow"> 
  <!--   --> </a> 
 <ul class="navList" title="Navigation"> 
  <li><a href="../../../overview-summary.html">概述</a></li> 
  <li><a href="package-summary.html">软件包</a></li> 
  <li class="navBarCell1Rev">类</li> 
  <li><a href="class-use/MethodHandle.html">使用</a></li> 
  <li><a href="package-tree.html">树</a></li> 
  <li><a href="../../../deprecated-list.html">已过时的</a></li> 
  <li><a href="../../../index-files/index-1.html">索引</a></li> 
  <li><a href="../../../help-doc.html">帮助</a></li> 
 </ul> 
 <div class="aboutLanguage"> 
  <strong>Java™&nbsp;Platform<br>Standard&nbsp;Ed.&nbsp;8</strong> 
 </div> 
</div> 
<div class="subNav"> 
 <ul class="navList"> 
  <li><a href="../../../java/lang/invoke/LambdaMetafactory.html" title="class in java.lang.invoke"><span class="typeNameLink">上一个</span></a></li> 
  <li><a href="../../../java/lang/invoke/MethodHandleInfo.html" title="interface in java.lang.invoke"><span class="typeNameLink">下一个</span></a></li> 
 </ul> 
 <ul class="navList"> 
  <li><a href="../../../index.html?java/lang/invoke/MethodHandle.html" target="_top">框架</a></li> 
  <li><a href="MethodHandle.html" target="_top">无框架</a></li> 
 </ul> 
 <ul class="navList" id="allclasses_navbar_top"> 
  <li><a href="../../../allclasses-noframe.html">所有类</a></li> 
 </ul> 
 <div> 
  <script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script> 
 </div> 
 <div> 
  <ul class="subNavList"> 
   <li>概要：</li> 
   <li>嵌套</li> 
   <li>字段</li> 
   <li>构造方法</li> 
   <li><a href="#method.summary">方法</a></li> 
  </ul> 
  <ul class="subNavList"> 
   <li>详细信息：</li> 
   <li>字段</li> 
   <li>构造方法</li> 
   <li><a href="#method.detail">方法</a></li> 
  </ul> 
 </div> 
 <a name="skip.navbar.top"> 
  <!--   --> </a> 
</div> 
<!-- ========= END OF TOP NAVBAR ========= --> 
<!-- ======== START OF CLASS DATA ======== --> 
<div class="header"> 
 <div class="subTitle">
   compact1, compact2, compact3 
 </div> 
 <div class="subTitle">
   java.lang.invoke 
 </div> 
 <h2 title="Class MethodHandle" class="title">Class MethodHandle</h2> 
</div> 
<div class="contentContainer"> 
 <ul class="inheritance"> 
  <li><a href="../../../java/lang/Object.html" title="class in java.lang">java.lang.Object</a></li> 
  <li> 
   <ul class="inheritance"> 
    <li>java.lang.invoke.MethodHandle</li> 
   </ul> </li> 
 </ul> 
 <div class="description"> 
  <ul class="blockList"> 
   <li class="blockList"> 
    <hr> <br> <pre>public abstract class <span class="typeNameLabel">MethodHandle</span>
extends <a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></pre> 
    <div class="block" data-fanyi="1">
      方法句柄是一个类型化的，直接可执行的引用到一个基本的方法、构造函数、字段或类似的低级操作，具有可选的参数或返回值的转换。这些转变是相当普遍的，并包括 
     <a href="../../../java/lang/invoke/MethodHandle.html#asType-java.lang.invoke.MethodType-">conversion</a>， 
     <a href="../../../java/lang/invoke/MethodHandle.html#bindTo-java.lang.Object-">insertion</a>， 
     <a href="../../../java/lang/invoke/MethodHandles.html#dropArguments-java.lang.invoke.MethodHandle-int-java.util.List-">deletion</a>这样的模式，和 
     <a href="../../../java/lang/invoke/MethodHandles.html#filterArguments-java.lang.invoke.MethodHandle-int-java.lang.invoke.MethodHandle...-">substitution</a>。 
     <h1 data-fanyi="1">处理内容的方法</h1>方法处理动态的强类型根据其参数和返回类型。它们不是由它们的基本方法的名称或定义类区别的。一种方法处理必须使用符号类型说明符匹配的方法处理自己的 
     <a href="../../../java/lang/invoke/MethodHandle.html#type">type descriptor</a>调用。 
     <p data-fanyi="1">每一种方法处理报告类型说明符通过<a href="../../../java/lang/invoke/MethodHandle.html#type"><code>type</code></a>访问。这种类型的描述符是一个<a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke"><code>MethodType</code></a>对象，其结构是一系列课程，其中一个方法的返回类型（或<code>void.class</code>如果没有）。</p> 
     <p data-fanyi="1">一种方法处理的类型的控件调用它接受的类型，和转换，适用于它的种类。</p> 
     <p data-fanyi="1">一种方法处理包含一对特殊的调用方法称为<a href="../../../java/lang/invoke/MethodHandle.html#invokeExact-java.lang.Object...-"><code>invokeExact</code></a>和<a href="../../../java/lang/invoke/MethodHandle.html#invoke-java.lang.Object...-"><code>invoke</code></a>。这两个调用方法提供直接访问的方法处理的基本方法、构造函数、字段，或其他操作，如修改转换参数和返回值。这两个调用接受完全匹配的方法处理自己的类型调用。平原，不精确的调用也接受一系列其他呼叫类型。</p> 
     <p data-fanyi="1">方法句柄是不可变的，并且没有可见的状态。当然，它们可以绑定到显示状态的基本方法或数据。关于java内存模型，任何方法处理表现得仿佛所有的（内部）领域的最终变量。这意味着，任何方法处理的应用程序的可见光将永远是完全形成的。这是真的，即使方法处理是通过数据竞争中的共享变量发布的。</p> 
     <p data-fanyi="1">方法处理不能由用户定义。实现可能（或不可能）创造<code>MethodHandle</code>可通过操作内部的子类<a href="../../../java/lang/Object.html#getClass--"><code>Object.getClass</code></a>可见。程序员不应该从它的特定类的方法处理的结论，作为方法处理类层次结构（如果有的话）可能会改变，从时间到时间或在不同的供应商的实现。</p> 
     <h1 data-fanyi="1">方法处理编译</h1> java方法调用命名 
     <code>invokeExact</code>或 
     <code>invoke</code>可以调用方法处理java源code。从源代码的角度来看，这些方法可以采取任何参数，它们的结果可以被转换为任何返回类型。正式这是给调用方法的返回类型和变量的数量 
     <code>Object</code> 
     <code>Object</code>参数来完成的，但他们有一个额外的质量称为签名多态连接自由直接调用JVM执行堆栈。 
     <p data-fanyi="1">通常是与虚拟方法，源代码级的调用<code>invokeExact</code>和<code>invoke</code>编译到一个<code>invokevirtual</code>指令。更不寻常的是，编译器必须记录实际的参数类型，并可能不在参数上执行方法调用转换。相反，它必须在堆栈的根据自己的未转化的类型。方法句柄对象本身在参数之前被推到堆栈上。然后，编译器调用一个描述参数和返回类型的符号类型描述符的方法句柄。</p> 
     <p data-fanyi="1">要发出一个完整的符号类型描述符，编译器还必须确定返回类型。这是基于方法调用表达式转换，如果有一个，否则<code>Object</code>如果调用一个表达式或其他<code>void</code>如果调用语句。演员可能是原始类型（但不是<code>void</code>）。</p> 
     <p data-fanyi="1">作为一个角落的情况下，一个uncasted <code>null</code>给出的说法是一个象征性的<code>java.lang.Void</code>类型说明符。同型<code>Void</code>歧义是无害的，因为没有引用类型<code>Void</code>除了空引用。</p> 
     <h1 data-fanyi="1">方法处理调用</h1>第一次 
     <code>invokevirtual</code>指令执行是相连的，通过象征性地解决名称在指导和验证方法的调用是静态的法律。这是电话 
     <code>invokeExact</code>和 
     <code>invoke</code>真实。在这种情况下，编译器发出的符号类型描述符检查正确的语法和它包含的名称是否被解决。因此，一个 
     <code>invokevirtual</code>指令调用一个方法处理将始终链接，只要符号类型说明符是合乎语法和类型存在。在典型的程序 
     <p data-fanyi="1">当<code>invokevirtual</code>后进行连接，接收方法处理的类型是第一次检查由JVM保证匹配的符号类型说明符。如果类型匹配失败，则意味着调用方调用的方法不在调用被调用的单个方法句柄上存在。</p> 
     <p data-fanyi="1">在<code>invokeExact</code>的情况下，调用的类型说明符（解析符号类型名称后）必须接收方法处理方法类型完全匹配。在平原，如此精确<code>invoke</code>，解决类型说明符必须是一个接收器的<a href="../../../java/lang/invoke/MethodHandle.html#asType-java.lang.invoke.MethodType-"><code>asType</code></a>方法有效性的争论。因此，平原<code>invoke</code>比<code>invokeExact</code>更加宽容。</p> 
     <p data-fanyi="1">经过配型，一个叫<code>invokeExact</code>直接调用的方法处理的基本方法（或其他行为，视情况而定）。</p> 
     <p data-fanyi="1">一个叫平<code>invoke</code>作品视为<code>invokeExact</code>相同，如果符号类型说明符调用者指定的方法处理自己的类型完全匹配。如果类型不匹配，<code>invoke</code>试图调整接收方法处理的类型，如电话<a href="../../../java/lang/invoke/MethodHandle.html#asType-java.lang.invoke.MethodType-"><code>asType</code></a>，获得准确的调用方法处理<code>M2</code>。这允许一个更强大的谈判方法的调用者和被调用者之间。</p> 
     <p data-fanyi="1">（注：调整的方法处理<code>M2</code>是不能直接观察的，因此不需要实现兑现。）</p> 
     <h1 data-fanyi="1">调用检查</h1>方法处理，类型匹配通常会成功。但是，如果匹配失败，JVM将 
     <a href="../../../java/lang/invoke/WrongMethodTypeException.html" title="class in java.lang.invoke"><code>WrongMethodTypeException</code></a>，要么直接（在 
     <code>invokeExact</code>的情况）或间接通过电话 
     <code>asType</code>失败（在 
     <code>invoke</code>案例）。 
     <p data-fanyi="1">因此，一个方法的类型不匹配，也可能表现为在一个静态类型的程序联动误差可以表现为一个动态<code>WrongMethodTypeException</code>程序中采用的方法处理。</p> 
     <p data-fanyi="1">因为方法类型包含“活”<code>类</code>对象、方法类型匹配，考虑到这两种类型的名称和类装载器。因此，即使一个方法处理<code>M</code>是一类装载器<code>L1</code>创造使用的另一<code>L2</code>，处理方法调用是类型安全的，因为调用者的符号类型描述，为解决<code>L2</code>，是对原有方法的调用者符号类型说明符匹配，为解决<code>L1</code>。在<code>L1</code>决议时发生的<code>M</code>创建及其类型的分配，而在<code>L2</code>决议时发生的<code>invokevirtual</code>指令链接。</p> 
     <p data-fanyi="1">除了检查类型描述符，一个方法处理的调用它的基本方法的能力是不受限制的。如果一个方法处理是由一个类，有访问该方法，非公开的方法，得到的处理可以使用在任何地方的任何人收到一个参考它。</p> 
     <p data-fanyi="1">与核心反射API，在访问检查，每一次反射的方法被调用时，处理方法是进行访问检查<a href="MethodHandles.Lookup.html#access">when the method handle is created</a>。在<code>ldc</code>案例（见下文），访问检查作为连接常量池入口的基本常数的方法部分进行处理。</p> 
     <p data-fanyi="1">因此，处理非公开的方法，或在非公开课的方法，一般应保密。他们不应该通过不受信任的代码使用，除非他们来自不受信任的代码都是无害的。</p> 
     <h1 data-fanyi="1">创作方法处理</h1> java代码可以创建一个方法处理直接访问任何方法，构造函数，或场，这些代码访问。这是通过一个反射，基于能力的API调用 
     <a href="../../../java/lang/invoke/MethodHandles.Lookup.html" title="class in java.lang.invoke"><code>MethodHandles.Lookup</code></a>例如，静态方法处理可以从 
     <a href="../../../java/lang/invoke/MethodHandles.Lookup.html#findStatic-java.lang.Class-java.lang.String-java.lang.invoke.MethodType-"><code>Lookup.findStatic</code></a>。也有从核心反射API对象转换方法，如 
     <a href="../../../java/lang/invoke/MethodHandles.Lookup.html#unreflect-java.lang.reflect.Method-"><code>Lookup.unreflect</code></a>。 
     <p data-fanyi="1">如类和方法处理字符串，对应的可访问的字段，方法和构造函数也可以直接表示在类文件中的常量池常数被<code>ldc</code>字节码加载。一种新的常量池入口，<code>CONSTANT_MethodHandle</code>型，指的是直接相关的<code>CONSTANT_Methodref</code>，<code>CONSTANT_InterfaceMethodref</code>，或<code>CONSTANT_Fieldref</code>常量池入口。（全部细节的方法处理常数，见第4.4.8和5.4.3.5的java虚拟机的规范。）</p> 
     <p data-fanyi="1">方法处理的方法或构造函数的变量数量修改位查找或恒载产生的（<code>0x0080</code>）有一个相应的变量的数量，如果他们与<a href="../../../java/lang/invoke/MethodHandle.html#asVarargsCollector-java.lang.Class-"><code>asVarargsCollector</code></a>帮助定义。</p> 
     <p data-fanyi="1">一种方法引用可以参考静态或非静态方法。在非静态的情况下，该方法处理类型包括显式接收机的说法，加上之前的任何其他参数。在方法句柄的类型中，初始接收参数根据初始请求的类类型进行类型化。（例如，如果一个非静态方法处理是通过<code>ldc</code>，接收器的类型是类中的常量池入口。命名）</p> 
     <p data-fanyi="1">方法处理常数是相同的链接访问检查相应的字节码指令，和<code>ldc</code>指令将相应的联动误差如果字节码的行为会把这样的错误。</p> 
     <p data-fanyi="1">作为这一推论，访问受保护的成员仅限于访问类的接收器，或它的子类之一，而访问类必须是保护成员的定义类的一个子类（或包的兄弟姐妹）。如果方法引用是指在当前包外的一个类的受保护的非静态方法或字段，则接收参数将被缩小到访问类的类型。</p> 
     <p data-fanyi="1">当调用一个方法处理虚拟方法时，该方法总是在接收端（即第一个参数）被查到。</p> 
     <p data-fanyi="1">也可以创建一个非虚拟方法句柄到一个特定的虚拟方法实现。这些不执行基于接收器类型的虚拟查找。这种方法处理模拟的方法<code>invokespecial</code>教学效果。</p> 
     <h1 data-fanyi="1">使用的例子</h1>这里有一些例子： 
     <blockquote> 
      <pre><code>
Object x, y; String s; int i;
MethodType mt; MethodHandle mh;
MethodHandles.Lookup lookup = MethodHandles.lookup();
// mt is (char,char)String
mt = MethodType.methodType(String.class, char.class, char.class);
mh = lookup.findVirtual(String.class, "replace", mt);
s = (String) mh.invokeExact("daddy",'d','n');
// invokeExact(Ljava/lang/String;CC)Ljava/lang/String;
assertEquals(s, "nanny");
// weakly typed invocation (using MHs.invoke)
s = (String) mh.invokeWithArguments("sappy", 'p', 'v');
assertEquals(s, "savvy");
// mt is (Object[])List
mt = MethodType.methodType(java.util.List.class, Object[].class);
mh = lookup.findStatic(java.util.Arrays.class, "asList", mt);
assert(mh.isVarargsCollector());
x = mh.invoke("one", "two");
// invoke(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/Object;
assertEquals(x, java.util.Arrays.asList("one","two"));
// mt is (Object,Object,Object)Object
mt = MethodType.genericMethodType(3);
mh = mh.asType(mt);
x = mh.invokeExact((Object)1, (Object)2, (Object)3);
// invokeExact(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;
assertEquals(x, java.util.Arrays.asList(1,2,3));
// mt is ()int
mt = MethodType.methodType(int.class);
mh = lookup.findVirtual(java.util.List.class, "size", mt);
i = (int) mh.invokeExact(java.util.Arrays.asList(1,2,3));
// invokeExact(Ljava/util/List;)I
assert(i == 3);
mt = MethodType.methodType(void.class, String.class);
mh = lookup.findVirtual(java.io.PrintStream.class, "println", mt);
mh.invokeExact(System.out, "Hello, world.");
// invokeExact(Ljava/io/PrintStream;Ljava/lang/String;)V
 </code></pre> 
     </blockquote>上述要求 
     <code>invokeExact</code>或平原 
     <code>invoke</code>生成的符号类型说明符单虚调用指令在下面评论表示。在这些例子中，辅助方法 
     <code>assertEquals</code>被假定为一个方法调用 
     <a href="../../../java/util/Objects.html#equals-java.lang.Object-java.lang.Object-"><code>Objects.equals</code></a>其论点，并断言的结果是真的。 
     <h1 data-fanyi="1">例外</h1>方法 
     <code>invokeExact</code>和 
     <code>invoke</code>宣布把 
     <a href="../../../java/lang/Throwable.html" title="class in java.lang"><code>Throwable</code></a>，即无什么限制方法处理可以把。由于JVM不区分检查和未检查的异常（其他比他们班的，当然），没有特别的效果，对字节码的形状将检查异常处理方法调用。但在java源代码，执行方法中处理呼叫的方法必须明确把 
     <code>Throwable</code>，否则必须抓住所有throwables局部，积极只有那些法律在这样的背景下，包裹的是非法的。 
     <h1 data-fanyi="1"><a name="sigpoly"></a>signature多态性</h1>不同寻常的编制和 
     <code>invokeExact</code>平原 
     <code>invoke</code>联动行为是由术语签名多态引用。在java语言规范的定义，一个签名的多态性的方法，是一种能操作各种调用签名和返回类型。 
     <p data-fanyi="1">在源代码中，调用一个签名多态方法将编译，无论所请求的符号类型描述符。像往常一样，java编译器会发出与给定的符号类型描述与命名方法<code>invokevirtual</code>指令。不寻常的部分是，符号类型的描述符是来自实际的参数和返回类型，而不是从方法声明。</p> 
     <p data-fanyi="1">当JVM进程中包含签名多态调用的字节码，它将成功地连接任何这样的电话，不管它的符号类型说明符。（为了保留类型安全，JVM会保护这样的调用合适的动态类型检查，如所描述的地方。）</p> 
     <p data-fanyi="1">字节码发生器，包括编译器的后端，需要发出未转化的象征型描述这些方法。工具确定符号联动需要接受这样的未描述，没有报告链接错误。</p> 
     <h1 data-fanyi="1">互操作方法处理和核心反射API</h1>使用工厂方法在 
     <a href="../../../java/lang/invoke/MethodHandles.Lookup.html" title="class in java.lang.invoke"><code>Lookup</code></a> API，任何类成员的核心反射API对象表示可以转换为等效的方法处理行为。例如，一个反射 
     <a href="../../../java/lang/reflect/Method.html" title="class in java.lang.reflect"><code>方法</code></a>可以转换为使用 
     <a href="../../../java/lang/invoke/MethodHandles.Lookup.html#unreflect-java.lang.reflect.Method-"><code>Lookup.unreflect</code></a>方法处理。由此产生的方法处理一般提供更直接和有效的访问底层类成员。 
     <p data-fanyi="1">作为一种特殊情况，当核心反射API用于这类视图签名多态方法<code>invokeExact</code>或平原<code>invoke</code>，它们的出现为普通非多态性的方法。反思的样子，看<a href="../../../java/lang/Class.html#getDeclaredMethod-java.lang.String-java.lang.Class...-"><code>Class.getDeclaredMethod</code></a>，是由其特殊地位的影响在这个API。例如，<a href="../../../java/lang/reflect/Method.html#getModifiers--"><code>Method.getModifiers</code></a>将报告正是这些改性剂位同样宣布方法要求，包括在这种情况下<code>native</code>和<code>varargs</code>位。</p> 
     <p data-fanyi="1">正如任何反射的方法，这些方法（当反射）可以调用通过<a href="../../../java/lang/reflect/Method.html#invoke-java.lang.Object-java.lang.Object...-"><code>java.lang.reflect.Method.invoke</code></a>。然而，这种反射称不会导致处理调用的方法。这样的电话，如果通过所要求的参数（一个单一的，<code>Object[]</code>型），将忽略参数并将抛出一个<code>UnsupportedOperationException</code>。</p> 
     <p data-fanyi="1">因为<code>invokevirtual</code>指令来调用方法处理任何符号类型说明符，这反映论的冲突与这些方法的正常表现通过字节码。因此，这两个本地方法，当被<code>Class.getDeclaredMethod</code>沉思，可以作为占位符只有。</p> 
     <p data-fanyi="1">为了获得一个特定类型的描述符，一个调用方法使用<a href="../../../java/lang/invoke/MethodHandles.html#exactInvoker-java.lang.invoke.MethodType-"><code>MethodHandles.exactInvoker</code></a>，或<a href="../../../java/lang/invoke/MethodHandles.html#invoker-java.lang.invoke.MethodType-"><code>MethodHandles.invoker</code></a>。的<a href="../../../java/lang/invoke/MethodHandles.Lookup.html#findVirtual-java.lang.Class-java.lang.String-java.lang.invoke.MethodType-"><code>Lookup.findVirtual</code></a> API也能返回一个句柄调用方法<code>invokeExact</code>或平原<code>invoke</code>，对于任何指定类型说明符。</p> 
     <h1 data-fanyi="1">java泛型方法处理和互操作</h1>方法处理可以获得方法，构造函数，或是java的泛型类型声明。与核心反射的接口一样，方法句柄的类型将由源级类型的擦除构造来构建。当调用一个方法句柄时，其参数的类型或返回值类型可能是泛型类型或类型实例。如果发生这种情况，编译器将取代那些类型的擦除时构建的 
     <code>invokevirtual</code>指示符号类型说明符。 
     <p data-fanyi="1">方法处理不代表他们的功能就像在java参数类型（通用）类型，因为有三个错配的功能类型和参数化类型的java。</p> 
     <ul data-fanyi="1"> 
      <li data-fanyi="1">方法类型范围内的所有可能的差距，从没有争吵到允许的参数<a href="MethodHandle.html#maxarity">maximum number</a>。泛型是不可变的，所以并不能代表这个。</li> 
      <li data-fanyi="1">方法类型可以指定原始类型参数的泛型类型，java不能范围。</li> 
      <li data-fanyi="1">高阶函数方法处理（组合）往往是通用在很宽的范围内的函数类型，包括多元。这是不可能用java泛型类型参数表示。</li> 
     </ul> 
     <h1 data-fanyi="1"><a name="maxarity"></a>arity限制</h1> JVM对所有方法和任何一种255叠参数绝对极限的构造函数。这个限制可以出现在某些情况下更严格： 
     <ul data-fanyi="1"> 
      <li data-fanyi="1">一个<code>long</code>或<code>double</code>参数计数（对数量限制）两参数插槽。</li> 
      <li data-fanyi="1">非静态方法为调用该方法的对象消耗了一个额外的参数。</li> 
      <li data-fanyi="1">构造函数会消耗一个额外的参数用于正在构建的对象。</li> 
      <li data-fanyi="1">因为一个方法处理的<code>invoke</code>方法（或其他签名多态方法）是非虚拟的，它消耗的方法的一个额外的参数处理本身，除了任何非虚拟接收对象。</li> 
     </ul>这些限制意味着某些方法处理不能创造，仅仅因为JVM堆参数限制。例如，如果一个静态的JVM方法就接受255个参数，一个方法处理不能创造它。试图创建方法处理方法的类型可能导致 
     <a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang"><code>IllegalArgumentException</code></a>。特别是，一个方法处理的类型不能有确切的最高255元。 
    </div> 
    <dl> 
     <dt> 
      <span class="seeLabel">另请参见：</span> 
     </dt> 
     <dd data-fanyi="1"> 
      <a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke"><code>MethodType</code></a>， 
      <a href="../../../java/lang/invoke/MethodHandles.html" title="class in java.lang.invoke"><code>MethodHandles</code></a> 
     </dd> 
    </dl> </li> 
  </ul> 
 </div> 
 <div class="summary"> 
  <ul class="blockList"> 
   <li class="blockList"> 
    <!-- ========== METHOD SUMMARY =========== --> 
    <ul class="blockList"> 
     <li class="blockList"><a name="method.summary"> 
       <!--   --> </a> <h3>方法摘要</h3> 
      <table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation"> 
       <caption> 
        <span id="t0" class="activeTableTab"><span>所有方法</span><span class="tabEnd">&nbsp;</span></span> 
        <span id="t2" class="tableTab"><span><a href="javascript:show(2);">接口方法</a></span><span class="tabEnd">&nbsp;</span></span> 
        <span id="t4" class="tableTab"><span><a href="javascript:show(8);">具体的方法</a></span><span class="tabEnd">&nbsp;</span></span> 
       </caption> 
       <tbody> 
        <tr> 
         <th class="colFirst" scope="col">Modifier and Type</th> 
         <th class="colLast" scope="col">Method and Description</th> 
        </tr> 
        <tr id="i0" class="altColor"> 
         <td class="colFirst"><code><a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandle.html#asCollector-java.lang.Class-int-">asCollector</a></span>(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;arrayType, int&nbsp;arrayLength)</code> 
          <div class="block" data-fanyi="1">
            一个数组集合方法处理，它接受一个给定数量的尾随位置参数，并将它们收集到一个数组参数中。 
          </div> </td> 
        </tr> 
        <tr id="i1" class="rowColor"> 
         <td class="colFirst"><code><a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandle.html#asFixedArity--">asFixedArity</a></span>()</code> 
          <div class="block" data-fanyi="1">
            使一个固定数量的方法处理，否则，相当于现在的处理方法。 
          </div> </td> 
        </tr> 
        <tr id="i2" class="altColor"> 
         <td class="colFirst"><code><a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandle.html#asSpreader-java.lang.Class-int-">asSpreader</a></span>(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;arrayType, int&nbsp;arrayLength)</code> 
          <div class="block" data-fanyi="1">
            做一个数组扩展方法句柄，它接受一个后数组参数，并将其元素作为位置参数展开。 
          </div> </td> 
        </tr> 
        <tr id="i3" class="rowColor"> 
         <td class="colFirst"><code><a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandle.html#asType-java.lang.invoke.MethodType-">asType</a></span>(<a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;newType)</code> 
          <div class="block" data-fanyi="1">
            产生一个适应当前方法句柄类型的适配器方法句柄，以适应一个新类型。 
          </div> </td> 
        </tr> 
        <tr id="i4" class="altColor"> 
         <td class="colFirst"><code><a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandle.html#asVarargsCollector-java.lang.Class-">asVarargsCollector</a></span>(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;arrayType)</code> 
          <div class="block" data-fanyi="1">
            使变arity适配器能够接受任何数量的尾部位置参数和收集到一个数组参数。 
          </div> </td> 
        </tr> 
        <tr id="i5" class="rowColor"> 
         <td class="colFirst"><code><a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandle.html#bindTo-java.lang.Object-">bindTo</a></span>(<a href="../../../java/lang/Object.html" title="class in java.lang">Object</a>&nbsp;x)</code> 
          <div class="block" data-fanyi="1">
            绑定一个值 
           <code>x</code>的处理方法的第一个参数，而不调用它。 
          </div> </td> 
        </tr> 
        <tr id="i6" class="altColor"> 
         <td class="colFirst"><code><a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandle.html#invoke-java.lang.Object...-">invoke</a></span>(<a href="../../../java/lang/Object.html" title="class in java.lang">Object</a>...&nbsp;args)</code> 
          <div class="block" data-fanyi="1">
            调用方法句柄，允许任何调用方类型的描述符，并可以在参数和返回值上进行转换。 
          </div> </td> 
        </tr> 
        <tr id="i7" class="rowColor"> 
         <td class="colFirst"><code><a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandle.html#invokeExact-java.lang.Object...-">invokeExact</a></span>(<a href="../../../java/lang/Object.html" title="class in java.lang">Object</a>...&nbsp;args)</code> 
          <div class="block" data-fanyi="1">
            调用方法句柄，允许任何调用方类型的描述符，但需要一个精确的类型匹配。 
          </div> </td> 
        </tr> 
        <tr id="i8" class="altColor"> 
         <td class="colFirst"><code><a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandle.html#invokeWithArguments-java.util.List-">invokeWithArguments</a></span>(<a href="../../../java/util/List.html" title="interface in java.util">List</a>&lt;?&gt;&nbsp;arguments)</code> 
          <div class="block" data-fanyi="1">
            执行一个可变数量的调用，参数传递在给定的数组的方法处理，如果通过电话的网站，只提到的类型 
           <code>Object</code>不精确的 
           <a href="../../../java/lang/invoke/MethodHandle.html#invoke-java.lang.Object...-"><code>invoke</code></a>，其数量是参数数组的长度。 
          </div> </td> 
        </tr> 
        <tr id="i9" class="rowColor"> 
         <td class="colFirst"><code><a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandle.html#invokeWithArguments-java.lang.Object...-">invokeWithArguments</a></span>(<a href="../../../java/lang/Object.html" title="class in java.lang">Object</a>...&nbsp;arguments)</code> 
          <div class="block" data-fanyi="1">
            执行一个可变数量的调用，参数传递在给定列表中的方法处理，如果通过电话的网站，只提到的类型 
           <code>Object</code>不精确的 
           <a href="../../../java/lang/invoke/MethodHandle.html#invoke-java.lang.Object...-"><code>invoke</code></a>，其数量是参数列表的长度。 
          </div> </td> 
        </tr> 
        <tr id="i10" class="altColor"> 
         <td class="colFirst"><code>boolean</code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandle.html#isVarargsCollector--">isVarargsCollector</a></span>()</code> 
          <div class="block" data-fanyi="1">
            决定如果这方法处理 
           <a href="../../../java/lang/invoke/MethodHandle.html#asVarargsCollector-java.lang.Class-">variable arity</a>电话支持。 
          </div> </td> 
        </tr> 
        <tr id="i11" class="rowColor"> 
         <td class="colFirst"><code><a href="../../../java/lang/String.html" title="class in java.lang">String</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandle.html#toString--">toString</a></span>()</code> 
          <div class="block" data-fanyi="1">
            返回一个字符串表示的方法处理，从字符串 
           <code>"MethodHandle"</code>和结束与处理方法的类型的字符串表示形式。 
          </div> </td> 
        </tr> 
        <tr id="i12" class="altColor"> 
         <td class="colFirst"><code><a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke">MethodType</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandle.html#type--">type</a></span>()</code> 
          <div class="block" data-fanyi="1">
            报告该方法句柄的类型。 
          </div> </td> 
        </tr> 
       </tbody> 
      </table> 
      <ul class="blockList"> 
       <li class="blockList"><a name="methods.inherited.from.class.java.lang.Object"> 
         <!--   --> </a> <h3>Methods inherited from class&nbsp;java.lang.<a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></h3> <code><a href="../../../java/lang/Object.html#clone--">clone</a>, <a href="../../../java/lang/Object.html#equals-java.lang.Object-">equals</a>, <a href="../../../java/lang/Object.html#finalize--">finalize</a>, <a href="../../../java/lang/Object.html#getClass--">getClass</a>, <a href="../../../java/lang/Object.html#hashCode--">hashCode</a>, <a href="../../../java/lang/Object.html#notify--">notify</a>, <a href="../../../java/lang/Object.html#notifyAll--">notifyAll</a>, <a href="../../../java/lang/Object.html#wait--">wait</a>, <a href="../../../java/lang/Object.html#wait-long-">wait</a>, <a href="../../../java/lang/Object.html#wait-long-int-">wait</a></code></li> 
      </ul> </li> 
    </ul> </li> 
  </ul> 
 </div> 
 <div class="details"> 
  <ul class="blockList"> 
   <li class="blockList"> 
    <!-- ============ METHOD DETAIL ========== --> 
    <ul class="blockList"> 
     <li class="blockList"><a name="method.detail"> 
       <!--   --> </a> <h3>方法详细信息</h3> <a name="type--"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>type</h4> <pre>public&nbsp;<a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;type()</pre> 
        <div class="block" data-fanyi="1">
          报告该方法句柄的类型。每次调用此方法处理通过 
         <code>invokeExact</code>必须匹配这种类型是。 
        </div> 
        <dl> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           方法处理类型 
         </dd> 
        </dl> </li> 
      </ul> <a name="invokeExact-java.lang.Object...-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>invokeExact</h4> <pre>public final&nbsp;<a href="../../../java/lang/Object.html" title="class in java.lang">Object</a>&nbsp;invokeExact(<a href="../../../java/lang/Object.html" title="class in java.lang">Object</a>...&nbsp;args)
                         throws <a href="../../../java/lang/Throwable.html" title="class in java.lang">Throwable</a></pre> 
        <div class="block" data-fanyi="1">
          调用方法句柄，允许任何调用方类型的描述符，但需要一个精确的类型匹配。在 
         <code>invokeExact</code>调用点符号类型说明符必须符合本法处理的 
         <a href="../../../java/lang/invoke/MethodHandle.html#type"><code>type</code></a>准确。没有转换参数或返回值允许在。 
         <p data-fanyi="1">当这个方法通过核心反射的接口被观察时，它将显示为一个单一的原生方法，以一个对象数组和返回一个对象。如果这个本地方法调用直接通过<a href="../../../java/lang/reflect/Method.html#invoke-java.lang.Object-java.lang.Object...-"><code>java.lang.reflect.Method.invoke</code></a>，通过JNI，或间接通过<a href="../../../java/lang/invoke/MethodHandles.Lookup.html#unreflect-java.lang.reflect.Method-"><code>Lookup.unreflect</code></a>，它将抛出一个<code>UnsupportedOperationException</code>。</p> 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>args</code> -签名多态参数列表，静代表使用varargs 
         </dd> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           签名的静态多态性结果，代表使用 
          <code>Object</code> 
         </dd> 
         <dt> 
          <span class="throwsLabel">异常</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/invoke/WrongMethodTypeException.html" title="class in java.lang.invoke">WrongMethodTypeException</a></code> -如果目标的类型不相同来电者的符号类型说明符 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/Throwable.html" title="class in java.lang">Throwable</a></code> -任何基本的方法被传播不变的呼叫处理方法 
         </dd> 
        </dl> </li> 
      </ul> <a name="invoke-java.lang.Object...-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>invoke</h4> <pre>public final&nbsp;<a href="../../../java/lang/Object.html" title="class in java.lang">Object</a>&nbsp;invoke(<a href="../../../java/lang/Object.html" title="class in java.lang">Object</a>...&nbsp;args)
                    throws <a href="../../../java/lang/Throwable.html" title="class in java.lang">Throwable</a></pre> 
        <div class="block" data-fanyi="1">
          调用方法句柄，允许任何调用方类型的描述符，并可以在参数和返回值上进行转换。 
         <p data-fanyi="1">如果调用网站的符号类型描述该方法处理的<a href="../../../java/lang/invoke/MethodHandle.html#type"><code>type</code></a>完全匹配，电话收益如<a href="../../../java/lang/invoke/MethodHandle.html#invokeExact-java.lang.Object...-"><code>invokeExact</code></a>。</p> 
         <p data-fanyi="1">否则，如果该方法调用进行处理首先是通过调用<a href="../../../java/lang/invoke/MethodHandle.html#asType-java.lang.invoke.MethodType-"><code>asType</code></a>调整调整方法处理所需的类型，然后调用过程如<a href="../../../java/lang/invoke/MethodHandle.html#invokeExact-java.lang.Object...-"><code>invokeExact</code></a>对调整的方法处理。</p> 
         <p data-fanyi="1">没有保证，<code>asType</code>电话实际上是由。如果JVM可以预测进行调用的结果，它可以适应直接调用者的参数，并根据自己的确切类型调用目标方法处理。</p> 
         <p data-fanyi="1">解决类型说明符在<code>invoke</code>呼叫网站必须有一个接收器<code>asType</code>方法有效性的争论。特别是，调用者必须指定相同的参数数量是被调用者的类型，如果调用者不<a href="../../../java/lang/invoke/MethodHandle.html#asVarargsCollector-java.lang.Class-">variable arity collector</a>。</p> 
         <p data-fanyi="1">当这个方法通过核心反射的接口被观察时，它将显示为一个单一的原生方法，以一个对象数组和返回一个对象。如果这个本地方法调用直接通过<a href="../../../java/lang/reflect/Method.html#invoke-java.lang.Object-java.lang.Object...-"><code>java.lang.reflect.Method.invoke</code></a>，通过JNI，或间接通过<a href="../../../java/lang/invoke/MethodHandles.Lookup.html#unreflect-java.lang.reflect.Method-"><code>Lookup.unreflect</code></a>，它将抛出一个<code>UnsupportedOperationException</code>。</p> 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>args</code> -签名多态参数列表，静代表使用varargs 
         </dd> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           签名的静态多态性结果，代表使用 
          <code>Object</code> 
         </dd> 
         <dt> 
          <span class="throwsLabel">异常</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/invoke/WrongMethodTypeException.html" title="class in java.lang.invoke">WrongMethodTypeException</a></code> -如果目标类型无法调整到调用者的符号类型说明符 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/ClassCastException.html" title="class in java.lang">ClassCastException</a></code> -如果目标类型可以调整来电，但引用转换失败 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/Throwable.html" title="class in java.lang">Throwable</a></code> -任何基本的方法被传播不变的呼叫处理方法 
         </dd> 
        </dl> </li> 
      </ul> <a name="invokeWithArguments-java.lang.Object...-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>invokeWithArguments</h4> <pre>public&nbsp;<a href="../../../java/lang/Object.html" title="class in java.lang">Object</a>&nbsp;invokeWithArguments(<a href="../../../java/lang/Object.html" title="class in java.lang">Object</a>...&nbsp;arguments)
                           throws <a href="../../../java/lang/Throwable.html" title="class in java.lang">Throwable</a></pre> 
        <div class="block" data-fanyi="1">
          执行一个可变数量的调用，参数传递在给定列表中的方法处理，如果通过电话的网站，只提到的类型 
         <code>Object</code>不精确的 
         <a href="../../../java/lang/invoke/MethodHandle.html#invoke-java.lang.Object...-"><code>invoke</code></a>，其数量是参数列表的长度。 
         <p data-fanyi="1">具体来说，继续执行，如下面的步骤，虽然方法不保证是如果JVM可以预测他们的影响。</p> 
         <ul data-fanyi="1"> 
          <li data-fanyi="1">确定的参数数组作为<code>N</code>长度为空引用，<code>N=0</code>。</li> 
          <li data-fanyi="1">确定<code>N</code>参数的通用型<code>TN</code>作为<code>TN=MethodType.genericMethodType(N)</code>。</li> 
          <li data-fanyi="1">力的原始目标的方法处理<code>MH0</code>所需要的类型，如<code>MH1 = MH0.asType(TN)</code>。</li> 
          <li data-fanyi="1">把数组<code>N</code>单独的参数<code>A0, ...</code>。</li> 
          <li data-fanyi="1">调用类型调整方法处理分离参数：1。invokeexact（A0，…）。</li> 
          <li data-fanyi="1">把返回值作为一个<code>Object</code>参考。</li> 
         </ul> 
         <p data-fanyi="1">由于该<code>asType</code>步动作，以下说法转换的应用是必要的：</p> 
         <ul data-fanyi="1"> 
          <li data-fanyi="1">参考铸造</li> 
          <li data-fanyi="1">拆箱</li> 
          <li data-fanyi="1">放宽基本转换</li> 
         </ul> 
         <p data-fanyi="1">调用调用返回的结果是装箱，如果它是一个原始的，或被迫为空，如果返回类型是无效的。</p> 
         <p data-fanyi="1">此调用相当于下面的代码：</p> 
         <blockquote> 
          <pre><code>
 MethodHandle invoker = MethodHandles.spreadInvoker(this.type(), 0);
 Object result = invoker.invokeExact(this, arguments);
 </code></pre> 
         </blockquote> 
         <p data-fanyi="1">不像签名多态方法<code>invokeExact</code>和<code>invoke</code>，<code>invokeWithArguments</code>可以正常通过核心反射API和JNI访问。因此，它可以被用作本地或反射代码和方法处理之间的桥梁。</p> 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>arguments</code> -到目标参数 
         </dd> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           目标返回的结果 
         </dd> 
         <dt> 
          <span class="throwsLabel">异常</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/ClassCastException.html" title="class in java.lang">ClassCastException</a></code>如果争论不能铸造转换参考 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/invoke/WrongMethodTypeException.html" title="class in java.lang.invoke">WrongMethodTypeException</a></code> -如果目标类型无法调整以给定的参数个数 
          <code>Object</code> 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/Throwable.html" title="class in java.lang">Throwable</a></code>任何由目标方法调用抛出 
         </dd> 
         <dt> 
          <span class="seeLabel">另请参见：</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <a href="../../../java/lang/invoke/MethodHandles.html#spreadInvoker-java.lang.invoke.MethodType-int-"><code>MethodHandles.spreadInvoker(java.lang.invoke.MethodType, int)</code></a> 
         </dd> 
        </dl> </li> 
      </ul> <a name="invokeWithArguments-java.util.List-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>invokeWithArguments</h4> <pre>public&nbsp;<a href="../../../java/lang/Object.html" title="class in java.lang">Object</a>&nbsp;invokeWithArguments(<a href="../../../java/util/List.html" title="interface in java.util">List</a>&lt;?&gt;&nbsp;arguments)
                           throws <a href="../../../java/lang/Throwable.html" title="class in java.lang">Throwable</a></pre> 
        <div class="block" data-fanyi="1">
          执行一个可变数量的调用，参数传递在给定的数组的方法处理，如果通过电话的网站，只提到的类型 
         <code>Object</code>不精确的 
         <a href="../../../java/lang/invoke/MethodHandle.html#invoke-java.lang.Object...-"><code>invoke</code></a>，其数量是参数数组的长度。 
         <p data-fanyi="1">此方法也相当于下面的代码：</p> 
         <blockquote> 
          <pre><code>
   invokeWithArguments(arguments.toArray()
 </code></pre> 
         </blockquote> 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>arguments</code> -到目标参数 
         </dd> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           目标返回的结果 
         </dd> 
         <dt> 
          <span class="throwsLabel">异常</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> -如果 
          <code>arguments</code>是空引用 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/ClassCastException.html" title="class in java.lang">ClassCastException</a></code>如果争论不能铸造转换参考 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/invoke/WrongMethodTypeException.html" title="class in java.lang.invoke">WrongMethodTypeException</a></code> -如果目标类型无法调整以给定的参数个数 
          <code>Object</code> 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/Throwable.html" title="class in java.lang">Throwable</a></code>任何由目标方法调用抛出 
         </dd> 
        </dl> </li> 
      </ul> <a name="asType-java.lang.invoke.MethodType-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>asType</h4> <pre>public&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;asType(<a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;newType)</pre> 
        <div class="block" data-fanyi="1">
          产生一个适应当前方法句柄类型的适配器方法句柄，以适应一个新类型。由此产生的方法处理保证报告一个类型，这是等于所需的新类型。 
         <p data-fanyi="1">如果原始型和新型相等，返回<code>this</code>。</p> 
         <p data-fanyi="1">当调用的新方法处理时，将执行以下步骤：</p> 
         <ul data-fanyi="1"> 
          <li data-fanyi="1">将传入的参数列表转换为匹配原方法句柄的参数列表。</li> 
          <li data-fanyi="1">调用转换后的参数列表中的原始方法句柄。</li> 
          <li data-fanyi="1">将由原始方法处理返回的任何结果转换为新方法句柄的返回类型。</li> 
         </ul> 
         <p data-fanyi="1">这种方法提供了<a href="../../../java/lang/invoke/MethodHandle.html#invokeExact-java.lang.Object...-"><code>invokeExact</code></a>和平原之间的行为差异，关键不<a href="../../../java/lang/invoke/MethodHandle.html#invoke-java.lang.Object...-"><code>invoke</code></a>。两方法执行相同的步骤时，来电者的类型说明符是M、被叫方的，但类型不同，平原<a href="../../../java/lang/invoke/MethodHandle.html#invoke-java.lang.Object...-"><code>invoke</code></a>也称<code>asType</code>（或一些内部等效）为配合呼叫者和被叫方的类型。</p> 
         <p data-fanyi="1">如果当前方法的可变数量的方法处理的参数列表转换可能涉及的几个参数为数组的转换和采集，为<a href="../../../java/lang/invoke/MethodHandle.html#asVarargsCollector-java.lang.Class-">described elsewhere</a>。在每一个其他情况下，所有的转换都是成对的，这意味着每个参数或返回值被转换为一个参数或返回值（或不返回值）。通过咨询旧的和新的方法句柄类型的相应的组件类型来定义所应用的转换。</p> 
         <p data-fanyi="1">让T0和T1是相应的新的和旧的参数类型，或旧的和新的返回类型。具体来说，对于一些有效的指标<code>i</code>，让t0<code>=newType.parameterType(i)</code>和t1<code>=this.type().parameterType(i)</code>。否则，将返回值的其他方式，让t0<code>=this.type().returnType()</code>和t1<code>=newType.returnType()</code>。如果类型是相同的，新方法处理将不会更改相应的参数或返回值（如果有的话）。否则，如果可能的话，应用以下的一个转换：</p> 
         <ul data-fanyi="1"> 
          <li data-fanyi="1">如果T0和T1是引用，然后投到T1的应用。（这些类型不需要以任何特定的方式进行相关。这是因为一个空的动态值可以转换为任何参考类型。</li> 
          <li data-fanyi="1">如果T0和T1是原语，然后一个java方法调用转换（JLS 5.3）应用，如果存在。（具体到必须转换为T1的扩大，原始的转换。）</li> 
          <li data-fanyi="1">如果T0和T1是一种原始的参考，一个java铸造转换（JLS 5.5）如果存在的应用。（具体的值是从T0盒装的包装类，然后扩大需要T1。）</li> 
          <li data-fanyi="1">如果T0是参考和T1原始的拆箱转换将被应用在运行时，可能随后java方法调用转换（JLS 5.3）的原始值。（这些都是原始的扩大转换。）t0必须包装类或超类的一个。（在T0是对象，这些都是允许的<a href="../../../java/lang/reflect/Method.html#invoke-java.lang.Object-java.lang.Object...-"><code>java.lang.reflect.Method.invoke</code></a>。转换）拆箱转换必须有一个成功的可能性，这意味着如果T0本身不是一个包装类，必须存在至少一个包装类TW是T0型和原始值的办法可以加宽T1。</li> 
          <li data-fanyi="1">如果返回类型T1被标记为无效，任何返回值被丢弃</li> 
          <li data-fanyi="1">如果返回类型是void T0和T1的参考，介绍了空值。</li> 
          <li data-fanyi="1">如果返回类型是void，T0 T1原始，介绍了一零值。</li> 
         </ul>（注：T0和T1可以看作是静态类型，因为没有对应具体的任何实际的参数或返回值。 
         <p data-fanyi="1">如果无法作出所需的成对转换的任何一个，将无法进行方法处理转换。</p> 
         <p data-fanyi="1">在运行时，应用到参考参数或返回值的转换可能需要额外的运行时检查，它可以失败。拆箱的操作可能会失败，因为原来的参考是无效的，造成<a href="../../../java/lang/NullPointerException.html" title="class in java.lang"><code>NullPointerException</code></a>。拆箱操作或参投的也可以在参考一个错误类型的对象失败，造成<a href="../../../java/lang/ClassCastException.html" title="class in java.lang"><code>ClassCastException</code></a>。虽然拆箱操作可以接受各种包装，如果没有，一个<code>ClassCastException</code>将抛出。</p>动态型） 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>newType</code> --新方法处理预期的类型 
         </dd> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           一种方法处理，代表 
          <code>this</code>执行任何必要的参数转换后，并安排必要的返回值的转换 
         </dd> 
         <dt> 
          <span class="throwsLabel">异常</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> -如果 
          <code>newType</code>是空引用 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/invoke/WrongMethodTypeException.html" title="class in java.lang.invoke">WrongMethodTypeException</a></code> -如果转换不能 
         </dd> 
         <dt> 
          <span class="seeLabel">另请参见：</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <a href="../../../java/lang/invoke/MethodHandles.html#explicitCastArguments-java.lang.invoke.MethodHandle-java.lang.invoke.MethodType-"><code>MethodHandles.explicitCastArguments(java.lang.invoke.MethodHandle, java.lang.invoke.MethodType)</code></a> 
         </dd> 
        </dl> </li> 
      </ul> <a name="asSpreader-java.lang.Class-int-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>asSpreader</h4> <pre>public&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;asSpreader(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;arrayType,
                               int&nbsp;arrayLength)</pre> 
        <div class="block" data-fanyi="1">
          做一个数组扩展方法句柄，它接受一个后数组参数，并将其元素作为位置参数展开。新的方法处理相适应，为空目标，目前的处理方法。该适配器的类型将被作为目标的类型相同，除了对目标类型的最终 
         <code>arrayLength</code>参数由单一型 
         <code>arrayType</code>数组参数替换。 
         <p data-fanyi="1">如果数组元素的类型不同于任何在原目标对应的参数类型，最初的目标是适应以数组元素直接，如果被调用的<a href="../../../java/lang/invoke/MethodHandle.html#asType-java.lang.invoke.MethodType-"><code>asType</code></a>。</p> 
         <p data-fanyi="1">当调用时，适配器将数组元素的一个数组元素替换为一个数组参数，每个数组都作为它自己的参数到目标。（论据的顺序是一样的。）他们是通过铸造和/或拆箱的尾随参数目标的类型间转换。最后的目标被称为。目标最终返回的是由适配器保持不变的。</p> 
         <p data-fanyi="1">在调用目标之前，适配器验证数组中包含了足够多的元素，以提供正确的参数计数到目标方法句柄。（当需要零元素时，数组也可以是空的。）</p> 
         <p data-fanyi="1">如果，当是所谓的适配器，提供的数组参数没有元素的正确的数字，该适配器将抛出一个<a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang"><code>IllegalArgumentException</code></a>代替调用目标。</p> 
         <p data-fanyi="1">下面是一些简单的数组扩展方法的例子：</p> 
         <blockquote> 
          <pre><code>
MethodHandle equals = publicLookup()
  .findVirtual(String.class, "equals", methodType(boolean.class, Object.class));
assert( (boolean) equals.invokeExact("me", (Object)"me"));
assert(!(boolean) equals.invokeExact("me", (Object)"thee"));
// spread both arguments from a 2-array:
MethodHandle eq2 = equals.asSpreader(Object[].class, 2);
assert( (boolean) eq2.invokeExact(new Object[]{ "me", "me" }));
assert(!(boolean) eq2.invokeExact(new Object[]{ "me", "thee" }));
// try to spread from anything but a 2-array:
for (int n = 0; n &lt;= 10; n++) {
  Object[] badArityArgs = (n == 2 ? null : new Object[n]);
  try { assert((boolean) eq2.invokeExact(badArityArgs) &amp;&amp; false); }
  catch (IllegalArgumentException ex) { } // OK
}
// spread both arguments from a String array:
MethodHandle eq2s = equals.asSpreader(String[].class, 2);
assert( (boolean) eq2s.invokeExact(new String[]{ "me", "me" }));
assert(!(boolean) eq2s.invokeExact(new String[]{ "me", "thee" }));
// spread second arguments from a 1-array:
MethodHandle eq1 = equals.asSpreader(Object[].class, 1);
assert( (boolean) eq1.invokeExact("me", new Object[]{ "me" }));
assert(!(boolean) eq1.invokeExact("me", new Object[]{ "thee" }));
// spread no arguments from a 0-array or null:
MethodHandle eq0 = equals.asSpreader(Object[].class, 0);
assert( (boolean) eq0.invokeExact("me", (Object)"me", new Object[0]));
assert(!(boolean) eq0.invokeExact("me", (Object)"thee", (Object[])null));
// asSpreader and asCollector are approximate inverses:
for (int n = 0; n &lt;= 2; n++) {
    for (Class&lt;?&gt; a : new Class&lt;?&gt;[]{Object[].class, String[].class, CharSequence[].class}) {
        MethodHandle equals2 = equals.asSpreader(a, n).asCollector(a, n);
        assert( (boolean) equals2.invokeWithArguments("me", "me"));
        assert(!(boolean) equals2.invokeWithArguments("me", "thee"));
    }
}
MethodHandle caToString = publicLookup()
  .findStatic(Arrays.class, "toString", methodType(String.class, char[].class));
assertEquals("[A, B, C]", (String) caToString.invokeExact("ABC".toCharArray()));
MethodHandle caString3 = caToString.asCollector(char[].class, 3);
assertEquals("[A, B, C]", (String) caString3.invokeExact('A', 'B', 'C'));
MethodHandle caToString2 = caString3.asSpreader(char[].class, 2);
assertEquals("[A, B, C]", (String) caToString2.invokeExact('A', "BC".toCharArray()));
 </code></pre> 
         </blockquote> 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>arrayType</code>通常 
          <code>Object[]</code>，提取的传播参数的数组参数的类型 
         </dd> 
         <dd data-fanyi="1"> 
          <code>arrayLength</code> -参数个数从一个输入数组参数的传播 
         </dd> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           在调用原始方法句柄之前，一个新的方法处理它传播它的最后一个数组参数 
         </dd> 
         <dt> 
          <span class="throwsLabel">异常</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> -如果 
          <code>arrayType</code>是空引用 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> -如果 
          <code>arrayType</code>不是数组类型，如果目标没有至少 
          <code>arrayLength</code>参数类型，或者如果 
          <code>arrayLength</code>是负的，或者产生的方法处理的类型会 
          <a href="MethodHandle.html#maxarity">too many parameters</a> 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/invoke/WrongMethodTypeException.html" title="class in java.lang.invoke">WrongMethodTypeException</a></code>如果隐含 
          <code>asType</code>调用失败 
         </dd> 
         <dt> 
          <span class="seeLabel">另请参见：</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <a href="../../../java/lang/invoke/MethodHandle.html#asCollector-java.lang.Class-int-"><code>asCollector(java.lang.Class&lt;?&gt;, int)</code></a> 
         </dd> 
        </dl> </li> 
      </ul> <a name="asCollector-java.lang.Class-int-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>asCollector</h4> <pre>public&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;asCollector(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;arrayType,
                                int&nbsp;arrayLength)</pre> 
        <div class="block" data-fanyi="1">
          一个数组集合方法处理，它接受一个给定数量的尾随位置参数，并将它们收集到一个数组参数中。新的方法处理相适应，为空目标，目前的处理方法。该适配器的类型将被作为目标的类型相同，除了一个后缀参数（通常型 
         <code>arrayType</code>）是由 
         <code>arrayLength</code>参数的类型是 
         <code>arrayType</code>元素类型所取代。 
         <p data-fanyi="1">如果数组类型不同于原来的最终目标参数类型，最初的目标是适应直接把数组类型，如电话<a href="../../../java/lang/invoke/MethodHandle.html#asType-java.lang.invoke.MethodType-"><code>asType</code></a>。</p> 
         <p data-fanyi="1">在调用时，适配器通过一个新的阵列式<code>arrayType</code>取代其尾<code>arrayLength</code>争论，其要素包括（按顺序）替换的参数。最后的目标被称为。目标最终返回的是由适配器保持不变的。</p> 
         <p data-fanyi="1">（数组也可以共享一个常数时<code>arrayLength</code>是零。）</p> 
         <p data-fanyi="1">（注：该<code>arrayType</code>经常对原有目标的最后一个参数类型相同。这是一个明确的说法<code>asSpreader</code>对称，并允许目标使用一个简单的<code>Object</code>作为最后一个参数的类型。）</p> 
         <p data-fanyi="1">为了创建一个收集适配器不限于特定数量的采集参数，而不是使用<a href="../../../java/lang/invoke/MethodHandle.html#asVarargsCollector-java.lang.Class-"><code>asVarargsCollector</code></a>。</p> 
         <p data-fanyi="1">这里有一些数组收集方法句柄的例子：</p> 
         <blockquote> 
          <pre><code>
MethodHandle deepToString = publicLookup()
  .findStatic(Arrays.class, "deepToString", methodType(String.class, Object[].class));
assertEquals("[won]",   (String) deepToString.invokeExact(new Object[]{"won"}));
MethodHandle ts1 = deepToString.asCollector(Object[].class, 1);
assertEquals(methodType(String.class, Object.class), ts1.type());
//assertEquals("[won]", (String) ts1.invokeExact(         new Object[]{"won"})); //FAIL
assertEquals("[[won]]", (String) ts1.invokeExact((Object) new Object[]{"won"}));
// arrayType can be a subtype of Object[]
MethodHandle ts2 = deepToString.asCollector(String[].class, 2);
assertEquals(methodType(String.class, String.class, String.class), ts2.type());
assertEquals("[two, too]", (String) ts2.invokeExact("two", "too"));
MethodHandle ts0 = deepToString.asCollector(Object[].class, 0);
assertEquals("[]", (String) ts0.invokeExact());
// collectors can be nested, Lisp-style
MethodHandle ts22 = deepToString.asCollector(Object[].class, 3).asCollector(String[].class, 2);
assertEquals("[A, B, [C, D]]", ((String) ts22.invokeExact((Object)'A', (Object)"B", "C", "D")));
// arrayType can be any primitive array type
MethodHandle bytesToString = publicLookup()
  .findStatic(Arrays.class, "toString", methodType(String.class, byte[].class))
  .asCollector(byte[].class, 3);
assertEquals("[1, 2, 3]", (String) bytesToString.invokeExact((byte)1, (byte)2, (byte)3));
MethodHandle longsToString = publicLookup()
  .findStatic(Arrays.class, "toString", methodType(String.class, long[].class))
  .asCollector(long[].class, 1);
assertEquals("[123]", (String) longsToString.invokeExact((long)123));
 </code></pre> 
         </blockquote> 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>arrayType</code>经常 
          <code>Object[]</code>的数组参数，将收集的参数类型 
         </dd> 
         <dd data-fanyi="1"> 
          <code>arrayLength</code> -参数个数收集到一个新的数组参数 
         </dd> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           在调用原始方法句柄之前，一种新的方法处理，它将一些尾随的参数收集到一个数组中 
         </dd> 
         <dt> 
          <span class="throwsLabel">异常</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> -如果 
          <code>arrayType</code>是空引用 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> -如果 
          <code>arrayType</code>不是数组类型或 
          <code>arrayType</code>不能分配给该方法处理后的参数类型，或 
          <code>arrayLength</code>不是合法的数组大小，或产生的方法处理的类型会 
          <a href="MethodHandle.html#maxarity">too many parameters</a> 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/invoke/WrongMethodTypeException.html" title="class in java.lang.invoke">WrongMethodTypeException</a></code>如果隐含 
          <code>asType</code>调用失败 
         </dd> 
         <dt> 
          <span class="seeLabel">另请参见：</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <a href="../../../java/lang/invoke/MethodHandle.html#asSpreader-java.lang.Class-int-"><code>asSpreader(java.lang.Class&lt;?&gt;, int)</code></a>， 
          <a href="../../../java/lang/invoke/MethodHandle.html#asVarargsCollector-java.lang.Class-"><code>asVarargsCollector(java.lang.Class&lt;?&gt;)</code></a> 
         </dd> 
        </dl> </li> 
      </ul> <a name="asVarargsCollector-java.lang.Class-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>asVarargsCollector</h4> <pre>public&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;asVarargsCollector(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;arrayType)</pre> 
        <div class="block" data-fanyi="1">
          使变arity适配器能够接受任何数量的尾部位置参数和收集到一个数组参数。 
         <p data-fanyi="1">该适配器的类型和行为将作为目标的类型和行为一样，除了一定的<code>invoke</code>和<code>asType</code>请求会导致尾位置参数被收集到目标的跟踪参数。同时，该适配器的最后一个参数类型将<code>arrayType</code>，即使目标有不同的最后一个参数类型。</p> 
         <p data-fanyi="1">这种转变可能返回<code>this</code>如果方法处理已经变元数及其尾随的参数类型是相同的<code>arrayType</code>。</p> 
         <p data-fanyi="1">当使用<a href="../../../java/lang/invoke/MethodHandle.html#invokeExact-java.lang.Object...-"><code>invokeExact</code></a>，适配器调用目标没有参数的变化。（注：此行为不同于<a href="../../../java/lang/invoke/MethodHandle.html#asCollector-java.lang.Class-int-">fixed arity collector</a>，因为它接受了一系列不确定的长度，而不是一个固定数量的参数。）</p> 
         <p data-fanyi="1">当调用<a href="../../../java/lang/invoke/MethodHandle.html#invoke-java.lang.Object...-"><code>invoke</code></a>平原，不精确，如果调用方式为适配器一样，适配器调用的目标与<code>invokeExact</code>。（这是<code>invoke</code>正常时的行为类型相匹配。）</p> 
         <p data-fanyi="1">否则，如果调用者和适配器的数量是相同的，和后面的参数类型的调用是一个或转让给尾随的参数类型的适配器相同的引用类型的参数和返回值被转换成对，如在固定数量的方法处理<a href="../../../java/lang/invoke/MethodHandle.html#asType-java.lang.invoke.MethodType-"><code>asType</code></a>。</p> 
         <p data-fanyi="1">否则，受的不同，或适配器的后缀参数类型不可从相应的呼叫类型。在这种情况下，适配器替换所有尾参数从原始落后的论点的位置开始，以一个新的类型<code>arrayType</code>数组，其元素包括（按顺序）替换的参数。</p> 
         <p data-fanyi="1">调用方类型必须提供足够多的参数，并提供正确的类型，以满足目标对在尾随数组参数之前的位置参数的要求。因此，调用方必须提供，至少，<code>N-1</code>争论，在<code>N</code>是目标的数量。此外，必须存在从传入的参数到目标的参数的转换。与普通<code>invoke</code>其他用途，如果不能满足这些基本的要求，可能会引发一<code>WrongMethodTypeException</code>。</p> 
         <p data-fanyi="1">在所有情况下，目标最终返回的是由适配器保持不变的。</p> 
         <p data-fanyi="1">在最后的情况下，正是因为如果目标方法处理暂时与<a href="../../../java/lang/invoke/MethodHandle.html#asCollector-java.lang.Class-int-">fixed arity collector</a>由调用类型所需的数量相适应。（如<code>asCollector</code>，如果数组的长度是零，一个共享的常数可用来代替一个新的数组。如果<code>asCollector</code>隐含调用会抛出一个<code>IllegalArgumentException</code>或<code>WrongMethodTypeException</code>，调用的变量数量必须把<code>WrongMethodTypeException</code>。）</p> 
         <p data-fanyi="1">对<a href="../../../java/lang/invoke/MethodHandle.html#asType-java.lang.invoke.MethodType-"><code>asType</code></a>行为也专门为变元的适配器，维持不变，平原，不精确的<code>invoke</code>总是相当于一个<code>asType</code>叫调整目标类型，其次是<code>invokeExact</code>。因此，一个变量的数量适配器响应建立一个固定数量的<code>asType</code>收藏家的要求，当且仅当适配器和请求类型的不同在数量或尾随的参数类型。由此产生的固定性收集器类型进一步调整（如有必要）所要求的类型的配对转换，好像被另一个应用程序<code>asType</code>。</p> 
         <p data-fanyi="1">当一个方法处理是通过执行一个<code>CONSTANT_MethodHandle</code>常数的<code>ldc</code>指令得到，和目标的方法标记为可变数量的方法（与改性剂点<code>0x0080</code>），处理方法将接受多个元，如果处理方法常被调用<code>asVarargsCollector</code>意味着创造。</p> 
         <p data-fanyi="1">为了创建一个收集适配器将预定数量的参数，其类型反映了这种预定数量，而不是使用<a href="../../../java/lang/invoke/MethodHandle.html#asCollector-java.lang.Class-int-"><code>asCollector</code></a>。</p> 
         <p data-fanyi="1">没有方法处理转换，产生新的方法处理变量的数量，除非他们有这样。因此，除了<code>asVarargsCollector</code>，在<code>MethodHandle</code>和<code>MethodHandles</code>所有方法将返回一个固定数量的方法处理，除的情况下，他们被指定返回原来的操作（例如，<code>asType</code>的方法处理自己的类型）。</p> 
         <p data-fanyi="1">在一个方法中处理已经变元的电话<code>asVarargsCollector</code>会产生具有相同的类型和行为的处理方法。它可能（或不可能）返回原变量数量的方法处理。</p> 
         <p data-fanyi="1">这里有一个例子，一个单变量数量的方法处理：</p> 
         <blockquote> 
          <pre><code>
MethodHandle deepToString = publicLookup()
  .findStatic(Arrays.class, "deepToString", methodType(String.class, Object[].class));
MethodHandle ts1 = deepToString.asVarargsCollector(Object[].class);
assertEquals("[won]",   (String) ts1.invokeExact(    new Object[]{"won"}));
assertEquals("[won]",   (String) ts1.invoke(         new Object[]{"won"}));
assertEquals("[won]",   (String) ts1.invoke(                      "won" ));
assertEquals("[[won]]", (String) ts1.invoke((Object) new Object[]{"won"}));
// findStatic of Arrays.asList(...) produces a variable arity method handle:
MethodHandle asList = publicLookup()
  .findStatic(Arrays.class, "asList", methodType(List.class, Object[].class));
assertEquals(methodType(List.class, Object[].class), asList.type());
assert(asList.isVarargsCollector());
assertEquals("[]", asList.invoke().toString());
assertEquals("[1]", asList.invoke(1).toString());
assertEquals("[two, too]", asList.invoke("two", "too").toString());
String[] argv = { "three", "thee", "tee" };
assertEquals("[three, thee, tee]", asList.invoke(argv).toString());
assertEquals("[three, thee, tee]", asList.invoke((Object[])argv).toString());
List ls = (List) asList.invoke((Object)argv);
assertEquals(1, ls.size());
assertEquals("[three, thee, tee]", Arrays.toString((Object[])ls.get(0)));
 </code></pre> 
         </blockquote> 
         <p style="font-size:smaller;" data-fanyi="1">讨论：这些规则被设计为一个动态变化的变量数量方法的java规则。在这两种情况下，调用者的变量数量的方法或方法处理可以通过零个或多个位置参数，或者通过预先收集的任何长度的数组。用户应该知道的最后一个参数的特殊作用，和一个类型匹配的效果上的最后一个参数，它决定是否一个单一的尾随参数被解释为一个完整的数组或一个数组的一个单一的元素被收集。请注意，尾随参数的动态类型对这个决定没有影响，只有调用站点的符号类型描述符和方法句柄的类型描述符之间的比较。</p> 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>arrayType</code>经常 
          <code>Object[]</code>的数组参数，将收集的参数类型 
         </dd> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           一种新的方法处理，它可以收集任何数量的尾随参数到一个数组中，在调用原来的方法处理 
         </dd> 
         <dt> 
          <span class="throwsLabel">异常</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> -如果 
          <code>arrayType</code>是空引用 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> -如果 
          <code>arrayType</code>不是数组类型或 
          <code>arrayType</code>不能分配给该方法的参数类型处理后 
         </dd> 
         <dt> 
          <span class="seeLabel">另请参见：</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <a href="../../../java/lang/invoke/MethodHandle.html#asCollector-java.lang.Class-int-"><code>asCollector(java.lang.Class&lt;?&gt;, int)</code></a>， 
          <a href="../../../java/lang/invoke/MethodHandle.html#isVarargsCollector--"><code>isVarargsCollector()</code></a>， 
          <a href="../../../java/lang/invoke/MethodHandle.html#asFixedArity--"><code>asFixedArity()</code></a> 
         </dd> 
        </dl> </li> 
      </ul> <a name="isVarargsCollector--"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>isVarargsCollector</h4> <pre>public&nbsp;boolean&nbsp;isVarargsCollector()</pre> 
        <div class="block" data-fanyi="1">
          决定如果这方法处理 
         <a href="../../../java/lang/invoke/MethodHandle.html#asVarargsCollector-java.lang.Class-">variable arity</a>电话支持。这种方法处理来自以下来源： 
         <ul data-fanyi="1"> 
          <li data-fanyi="1">一个叫<a href="../../../java/lang/invoke/MethodHandle.html#asVarargsCollector-java.lang.Class-">asVarargsCollector</a></li> 
          <li data-fanyi="1">打电话给<a href="../../../java/lang/invoke/MethodHandles.Lookup.html" title="class in java.lang.invoke">lookup method</a>解决一个变量数量java方法或构造函数</li> 
          <li data-fanyi="1">一个<code>CONSTANT_MethodHandle</code>解决一个变量数量java的方法或构造函数的<code>ldc</code>指令</li> 
         </ul> 
        </div> 
        <dl> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           如果此方法处理接受超过一个数量的平原如此，不精确的 
          <code>invoke</code>电话 
         </dd> 
         <dt> 
          <span class="seeLabel">另请参见：</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <a href="../../../java/lang/invoke/MethodHandle.html#asVarargsCollector-java.lang.Class-"><code>asVarargsCollector(java.lang.Class&lt;?&gt;)</code></a>， 
          <a href="../../../java/lang/invoke/MethodHandle.html#asFixedArity--"><code>asFixedArity()</code></a> 
         </dd> 
        </dl> </li> 
      </ul> <a name="asFixedArity--"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>asFixedArity</h4> <pre>public&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;asFixedArity()</pre> 
        <div class="block" data-fanyi="1">
          使一个固定数量的方法处理，否则，相当于现在的处理方法。 
         <p data-fanyi="1">如果当前方法处理不<a href="../../../java/lang/invoke/MethodHandle.html#asVarargsCollector-java.lang.Class-">variable arity</a>，当前方法的句柄返回。即使目前的处理方法不能有效的输入，这是真的<code>asVarargsCollector</code>。</p> 
         <p data-fanyi="1">否则，由此产生的固定性的方法处理当前的方法处理相同的类型和行为，除了<a href="../../../java/lang/invoke/MethodHandle.html#isVarargsCollector--"><code>isVarargsCollector</code></a>将假。固定数量的方法处理可能（或不可能）是以前的说法<code>asVarargsCollector</code>。</p> 
         <p data-fanyi="1">这里有一个例子，一个单变量数量的方法处理：</p> 
         <blockquote> 
          <pre><code>
MethodHandle asListVar = publicLookup()
  .findStatic(Arrays.class, "asList", methodType(List.class, Object[].class))
  .asVarargsCollector(Object[].class);
MethodHandle asListFix = asListVar.asFixedArity();
assertEquals("[1]", asListVar.invoke(1).toString());
Exception caught = null;
try { asListFix.invoke((Object)1); }
catch (Exception ex) { caught = ex; }
assert(caught instanceof ClassCastException);
assertEquals("[two, too]", asListVar.invoke("two", "too").toString());
try { asListFix.invoke("two", "too"); }
catch (Exception ex) { caught = ex; }
assert(caught instanceof WrongMethodTypeException);
Object[] argv = { "three", "thee", "tee" };
assertEquals("[three, thee, tee]", asListVar.invoke(argv).toString());
assertEquals("[three, thee, tee]", asListFix.invoke(argv).toString());
assertEquals(1, ((List) asListVar.invoke((Object)argv)).size());
assertEquals("[three, thee, tee]", asListFix.invoke((Object)argv).toString());
 </code></pre> 
         </blockquote> 
        </div> 
        <dl> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           只接受固定数量的参数的一种新方法处理 
         </dd> 
         <dt> 
          <span class="seeLabel">另请参见：</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <a href="../../../java/lang/invoke/MethodHandle.html#asVarargsCollector-java.lang.Class-"><code>asVarargsCollector(java.lang.Class&lt;?&gt;)</code></a>， 
          <a href="../../../java/lang/invoke/MethodHandle.html#isVarargsCollector--"><code>isVarargsCollector()</code></a> 
         </dd> 
        </dl> </li> 
      </ul> <a name="bindTo-java.lang.Object-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>bindTo</h4> <pre>public&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;bindTo(<a href="../../../java/lang/Object.html" title="class in java.lang">Object</a>&nbsp;x)</pre> 
        <div class="block" data-fanyi="1">
          绑定一个值 
         <code>x</code>的处理方法的第一个参数，而不调用它。新的方法处理相适应，为空目标，目前的方法处理绑定到给定的参数。绑定句柄的类型将与目标的类型相同，只不过将省略一个前导引用参数。 
         <p data-fanyi="1">在调用时，绑定的手柄插入给定值<code>x</code>作为一种新的主要论点的目标。其他参数也传递不变。目标最终返回的是由绑定句柄保持不变的。</p> 
         <p data-fanyi="1">参考<code>x</code>必须转换为目标的第一个参数的类型。</p> 
         <p data-fanyi="1">（注：因为方法句柄是不可变的，目标方法句柄保留了它的原始类型和行为。）</p> 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>x</code> -绑定到目标函数的第一个参数的值 
         </dd> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           一种新的方法处理预先准备的给定值传入的参数列表，调用原方法处理前 
         </dd> 
         <dt> 
          <span class="throwsLabel">异常</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> -如果目标没有一个领先的参数类型是引用类型 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/ClassCastException.html" title="class in java.lang">ClassCastException</a></code> -如果 
          <code>x</code>不能转换为目标类型的主要参数 
         </dd> 
         <dt> 
          <span class="seeLabel">另请参见：</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <a href="../../../java/lang/invoke/MethodHandles.html#insertArguments-java.lang.invoke.MethodHandle-int-java.lang.Object...-"><code>MethodHandles.insertArguments(java.lang.invoke.MethodHandle, int, java.lang.Object...)</code></a> 
         </dd> 
        </dl> </li> 
      </ul> <a name="toString--"> 
       <!--   --> </a> 
      <ul class="blockListLast"> 
       <li class="blockList"> <h4>toString</h4> <pre>public&nbsp;<a href="../../../java/lang/String.html" title="class in java.lang">String</a>&nbsp;toString()</pre> 
        <div class="block" data-fanyi="1">
          返回一个字符串表示的方法处理，从字符串 
         <code>"MethodHandle"</code>和结束与处理方法的类型的字符串表示形式。换句话说，这个方法返回一个字符串相等的价值： 
         <blockquote> 
          <pre><code>
 "MethodHandle" + type().toString()
 </code></pre> 
         </blockquote> 
         <p data-fanyi="1">（注：此版本的未来版本可能会向字符串表示形式添加更多的信息。因此，现在的语法不应该被应用程序解析。</p> 
        </div> 
        <dl> 
         <dt> 
          <span class="overrideSpecifyLabel">重写：</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/Object.html#toString--">toString</a></code>&nbsp;方法重写，继承类&nbsp; 
          <code><a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></code> 
         </dd> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           方法句柄的字符串表示形式 
         </dd> 
        </dl> </li> 
      </ul> </li> 
    </ul> </li> 
  </ul> 
 </div> 
</div> 
<!-- ========= END OF CLASS DATA ========= --> 
<!-- ======= START OF BOTTOM NAVBAR ====== --> 
<div class="bottomNav"> 
 <a name="navbar.bottom"> 
  <!--   --> </a> 
 <div class="skipNav"> 
  <a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a> 
 </div> 
 <a name="navbar.bottom.firstrow"> 
  <!--   --> </a> 
 <ul class="navList" title="Navigation"> 
  <li><a href="../../../overview-summary.html">概述</a></li> 
  <li><a href="package-summary.html">软件包</a></li> 
  <li class="navBarCell1Rev">类</li> 
  <li><a href="class-use/MethodHandle.html">使用</a></li> 
  <li><a href="package-tree.html">树</a></li> 
  <li><a href="../../../deprecated-list.html">已过时的</a></li> 
  <li><a href="../../../index-files/index-1.html">索引</a></li> 
  <li><a href="../../../help-doc.html">帮助</a></li> 
 </ul> 
 <div class="aboutLanguage"> 
  <strong>Java™&nbsp;Platform<br>Standard&nbsp;Ed.&nbsp;8</strong> 
 </div> 
</div> 
<div class="subNav"> 
 <ul class="navList"> 
  <li><a href="../../../java/lang/invoke/LambdaMetafactory.html" title="class in java.lang.invoke"><span class="typeNameLink">上一个</span></a></li> 
  <li><a href="../../../java/lang/invoke/MethodHandleInfo.html" title="interface in java.lang.invoke"><span class="typeNameLink">下一个</span></a></li> 
 </ul> 
 <ul class="navList"> 
  <li><a href="../../../index.html?java/lang/invoke/MethodHandle.html" target="_top">框架</a></li> 
  <li><a href="MethodHandle.html" target="_top">无框架</a></li> 
 </ul> 
 <ul class="navList" id="allclasses_navbar_bottom"> 
  <li><a href="../../../allclasses-noframe.html">所有类</a></li> 
 </ul> 
 <div> 
  <script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script> 
 </div> 
 <div> 
  <ul class="subNavList"> 
   <li>概要：</li> 
   <li>嵌套</li> 
   <li>字段</li> 
   <li>构造方法</li> 
   <li><a href="#method.summary">方法</a></li> 
  </ul> 
  <ul class="subNavList"> 
   <li>详细信息：</li> 
   <li>字段</li> 
   <li>构造方法</li> 
   <li><a href="#method.detail">方法</a></li> 
  </ul> 
 </div> 
 <a name="skip.navbar.bottom"> 
  <!--   --> </a> 
</div> 
<!-- ======== END OF BOTTOM NAVBAR ======= --> 
<p class="legalCopy"><small><font size="-1"> <a href="http://bugreport.sun.com/bugreport/">Submit a bug or feature</a> <br>For further API reference and developer documentation, see <a href="http://download.oracle.com/javase/8/docs/index.html" target="_blank">Java SE Documentation</a>. That documentation contains more detailed, developer-targeted descriptions, with conceptual overviews, definitions of terms, workarounds, and working code examples.<br> Copyright © 1993, 2014, Oracle and/or its affiliates. All rights reserved. </font></small> </p> 
<div id="adDiv"> 


 <div></div> 
</div> 
<p></p>