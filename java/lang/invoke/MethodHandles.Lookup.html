<!-- NewPage -->   
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<!-- Generated by javadoc (1.8.0) on Tue Mar 04 03:12:46 PST 2014 --> 
<title>MethodHandles.Lookup (Java Platform SE 8 )</title> 
<meta name="date" content="2014-03-04"> 
<meta name="keywords" content="java.lang.invoke.MethodHandles.Lookup class"> 
<meta name="keywords" content="PUBLIC"> 
<meta name="keywords" content="PRIVATE"> 
<meta name="keywords" content="PROTECTED"> 
<meta name="keywords" content="PACKAGE"> 
<meta name="keywords" content="lookupClass()"> 
<meta name="keywords" content="lookupModes()"> 
<meta name="keywords" content="in()"> 
<meta name="keywords" content="toString()"> 
<meta name="keywords" content="findStatic()"> 
<meta name="keywords" content="findVirtual()"> 
<meta name="keywords" content="findConstructor()"> 
<meta name="keywords" content="findSpecial()"> 
<meta name="keywords" content="findGetter()"> 
<meta name="keywords" content="findSetter()"> 
<meta name="keywords" content="findStaticGetter()"> 
<meta name="keywords" content="findStaticSetter()"> 
<meta name="keywords" content="bind()"> 
<meta name="keywords" content="unreflect()"> 
<meta name="keywords" content="unreflectSpecial()"> 
<meta name="keywords" content="unreflectConstructor()"> 
<meta name="keywords" content="unreflectGetter()"> 
<meta name="keywords" content="unreflectSetter()"> 
<meta name="keywords" content="revealDirect()"> 
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style"> 
<script type="text/javascript" src="../../../script.js"></script> 
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="MethodHandles.Lookup (Java Platform SE 8 )";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":10,"i1":10,"i2":10,"i3":10,"i4":10,"i5":10,"i6":10,"i7":10,"i8":10,"i9":10,"i10":10,"i11":10,"i12":10,"i13":10,"i14":10,"i15":10,"i16":10,"i17":10,"i18":10};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script> 
<noscript>
  &lt;div&gt; JavaScript is disabled on your browser. 
</noscript> 
<!-- ========= START OF TOP NAVBAR ======= -->   
<div class="topNav"> 
 <a name="navbar.top"> 
  <!--   --> </a> 
 <div class="skipNav"> 
  <a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a> 
 </div> 
 <a name="navbar.top.firstrow"> 
  <!--   --> </a> 
 <ul class="navList" title="Navigation"> 
  <li><a href="../../../overview-summary.html">概述</a></li> 
  <li><a href="package-summary.html">软件包</a></li> 
  <li class="navBarCell1Rev">类</li> 
  <li><a href="class-use/MethodHandles.Lookup.html">使用</a></li> 
  <li><a href="package-tree.html">树</a></li> 
  <li><a href="../../../deprecated-list.html">已过时的</a></li> 
  <li><a href="../../../index-files/index-1.html">索引</a></li> 
  <li><a href="../../../help-doc.html">帮助</a></li> 
 </ul> 
 <div class="aboutLanguage"> 
  <strong>Java™&nbsp;Platform<br>Standard&nbsp;Ed.&nbsp;8</strong> 
 </div> 
</div> 
<div class="subNav"> 
 <ul class="navList"> 
  <li><a href="../../../java/lang/invoke/MethodHandles.html" title="class in java.lang.invoke"><span class="typeNameLink">上一个</span></a></li> 
  <li><a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke"><span class="typeNameLink">下一个</span></a></li> 
 </ul> 
 <ul class="navList"> 
  <li><a href="../../../index.html?java/lang/invoke/MethodHandles.Lookup.html" target="_top">框架</a></li> 
  <li><a href="MethodHandles.Lookup.html" target="_top">无框架</a></li> 
 </ul> 
 <ul class="navList" id="allclasses_navbar_top"> 
  <li><a href="../../../allclasses-noframe.html">所有类</a></li> 
 </ul> 
 <div> 
  <script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script> 
 </div> 
 <div> 
  <ul class="subNavList"> 
   <li>概要：</li> 
   <li>嵌套</li> 
   <li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li> 
   <li>构造方法</li> 
   <li><a href="#method.summary">方法</a></li> 
  </ul> 
  <ul class="subNavList"> 
   <li>详细信息：</li> 
   <li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li> 
   <li>构造方法</li> 
   <li><a href="#method.detail">方法</a></li> 
  </ul> 
 </div> 
 <a name="skip.navbar.top"> 
  <!--   --> </a> 
</div> 
<!-- ========= END OF TOP NAVBAR ========= --> 
<!-- ======== START OF CLASS DATA ======== --> 
<div class="header"> 
 <div class="subTitle">
   compact1, compact2, compact3 
 </div> 
 <div class="subTitle">
   java.lang.invoke 
 </div> 
 <h2 title="Class MethodHandles.Lookup" class="title">Class MethodHandles.Lookup</h2> 
</div> 
<div class="contentContainer"> 
 <ul class="inheritance"> 
  <li><a href="../../../java/lang/Object.html" title="class in java.lang">java.lang.Object</a></li> 
  <li> 
   <ul class="inheritance"> 
    <li>java.lang.invoke.MethodHandles.Lookup</li> 
   </ul> </li> 
 </ul> 
 <div class="description"> 
  <ul class="blockList"> 
   <li class="blockList"> 
    <dl> 
     <dt>
       Enclosing class: 
     </dt> 
     <dd data-fanyi="1"> 
      <a href="../../../java/lang/invoke/MethodHandles.html" title="class in java.lang.invoke">MethodHandles</a> 
     </dd> 
    </dl> 
    <hr> <br> <pre>public static final class <span class="typeNameLabel">MethodHandles.Lookup</span>
extends <a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></pre> 
    <div class="block" data-fanyi="1">
      查找对象是一个用于创建方法句柄的工厂，当创建需要访问检查时。方法句柄在被调用时不执行访问检查，而是在创建它们时。因此，当创建方法句柄时，必须执行方法处理访问限制的方法。打电话的人类对这些限制的执行被称为 
     <a href="../../../java/lang/invoke/MethodHandles.Lookup.html#lookupClass">lookup class</a>。 
     <p data-fanyi="1">查找类，需要创建方法处理会<a href="../../../java/lang/invoke/MethodHandles.html#lookup--"><code>MethodHandles.lookup</code></a>为自己创建一个工厂。当<code>Lookup</code>工厂对象创建时，查找类的身份被确定，并安全地存储在<code>Lookup</code>对象。查找类（或其代表）可以使用在<code>Lookup</code>对象的工厂方法来创建访问检查成员方法处理。这包括允许查找类的所有方法、构造函数和字段，甚至是私有的。</p> 
     <h1 data-fanyi="1"><a name="lookups"></a>lookup工厂方法</h1>在 
     <code>Lookup</code>对象对应于所有主要的用例方法，构造函数工厂方法和字段。每种方法处理工厂方法创建的是一个特定的字节码的功能等价的行为。（字节码的行为都是在java虚拟机规范。第5.4.3.5描述）这里是这些工厂方法以及由此方法处理行为之间的对应关系的总结： 
     <table border="1" cellpadding="5" summary="lookup method behaviors"> 
      <tbody> 
       <tr> 
        <th><a name="equiv"></a>lookup expression</th> 
        <th>member</th> 
        <th>bytecode behavior</th> 
       </tr> 
       <tr> 
        <td><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#findGetter-java.lang.Class-java.lang.String-java.lang.Class-"><code>lookup.findGetter(C.class,"f",FT.class)</code></a></td> 
        <td><code>FT f;</code></td> 
        <td><code>(T) this.f;</code></td> 
       </tr> 
       <tr> 
        <td><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#findStaticGetter-java.lang.Class-java.lang.String-java.lang.Class-"><code>lookup.findStaticGetter(C.class,"f",FT.class)</code></a></td> 
        <td><code>static</code><br><code>FT f;</code></td> 
        <td><code>(T) C.f;</code></td> 
       </tr> 
       <tr> 
        <td><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#findSetter-java.lang.Class-java.lang.String-java.lang.Class-"><code>lookup.findSetter(C.class,"f",FT.class)</code></a></td> 
        <td><code>FT f;</code></td> 
        <td><code>this.f = x;</code></td> 
       </tr> 
       <tr> 
        <td><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#findStaticSetter-java.lang.Class-java.lang.String-java.lang.Class-"><code>lookup.findStaticSetter(C.class,"f",FT.class)</code></a></td> 
        <td><code>static</code><br><code>FT f;</code></td> 
        <td><code>C.f = arg;</code></td> 
       </tr> 
       <tr> 
        <td><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#findVirtual-java.lang.Class-java.lang.String-java.lang.invoke.MethodType-"><code>lookup.findVirtual(C.class,"m",MT)</code></a></td> 
        <td><code>T m(A*);</code></td> 
        <td><code>(T) this.m(arg*);</code></td> 
       </tr> 
       <tr> 
        <td><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#findStatic-java.lang.Class-java.lang.String-java.lang.invoke.MethodType-"><code>lookup.findStatic(C.class,"m",MT)</code></a></td> 
        <td><code>static</code><br><code>T m(A*);</code></td> 
        <td><code>(T) C.m(arg*);</code></td> 
       </tr> 
       <tr> 
        <td><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#findSpecial-java.lang.Class-java.lang.String-java.lang.invoke.MethodType-java.lang.Class-"><code>lookup.findSpecial(C.class,"m",MT,this.class)</code></a></td> 
        <td><code>T m(A*);</code></td> 
        <td><code>(T) super.m(arg*);</code></td> 
       </tr> 
       <tr> 
        <td><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#findConstructor-java.lang.Class-java.lang.invoke.MethodType-"><code>lookup.findConstructor(C.class,MT)</code></a></td> 
        <td><code>C(A*);</code></td> 
        <td><code>new C(arg*);</code></td> 
       </tr> 
       <tr> 
        <td><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#unreflectGetter-java.lang.reflect.Field-"><code>lookup.unreflectGetter(aField)</code></a></td> 
        <td>(<code>static</code>)?<br><code>FT f;</code></td> 
        <td><code>(FT) aField.get(thisOrNull);</code></td> 
       </tr> 
       <tr> 
        <td><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#unreflectSetter-java.lang.reflect.Field-"><code>lookup.unreflectSetter(aField)</code></a></td> 
        <td>(<code>static</code>)?<br><code>FT f;</code></td> 
        <td><code>aField.set(thisOrNull, arg);</code></td> 
       </tr> 
       <tr> 
        <td><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#unreflect-java.lang.reflect.Method-"><code>lookup.unreflect(aMethod)</code></a></td> 
        <td>(<code>static</code>)?<br><code>T m(A*);</code></td> 
        <td><code>(T) aMethod.invoke(thisOrNull, arg*);</code></td> 
       </tr> 
       <tr> 
        <td><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#unreflectConstructor-java.lang.reflect.Constructor-"><code>lookup.unreflectConstructor(aConstructor)</code></a></td> 
        <td><code>C(A*);</code></td> 
        <td><code>(C) aConstructor.newInstance(arg*);</code></td> 
       </tr> 
       <tr> 
        <td><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#unreflect-java.lang.reflect.Method-"><code>lookup.unreflect(aMethod)</code></a></td> 
        <td>(<code>static</code>)?<br><code>T m(A*);</code></td> 
        <td><code>(T) aMethod.invoke(thisOrNull, arg*);</code></td> 
       </tr> 
      </tbody> 
     </table>这里，类型 
     <code>C</code>是类或接口被搜索的一员，记录作为一个参数指定 
     <code>refc</code>在查找方法。方法类型 
     <code>MT</code>从返回类型和参数类型 
     <code>T</code> 
     <code>A*</code>序列组成。构造函数也有一系列的参数类型和返回 
     <code>A*</code>视为新创建的对象的类型 
     <code>C</code>。两 
     <code>MT</code>和字段类型 
     <code>FT</code>记录作为一个参数指定 
     <code>type</code>。形式参数 
     <code>this</code>代表 
     <code>C</code>型自参考；如果它是存在的，它总是要处理方法调用的主要论点。（在某些情况下 
     <code>protected</code>成员， 
     <code>this</code>可能限制类型查找类；见下文。）的名字 
     <code>arg</code>代表所有其他方法处理参数。在示例代码为核心的反射API，名字 
     <code>thisOrNull</code>代表空引用，如果访问的方法或字段是静态的，而 
     <code>this</code>否则。名称 
     <code>aMethod</code>， 
     <code>aField</code>反射物体，并给出了相应的成员 
     <code>aConstructor</code>站。 
     <p data-fanyi="1">如果给定的成员是可变的数量（即，方法或构造函数）返回的处理方法也将<a href="../../../java/lang/invoke/MethodHandle.html#asVarargsCollector-java.lang.Class-">variable arity</a>。在所有其他情况下，返回的处理方法将固定数量。</p> 
     <p style="font-size:smaller;" data-fanyi="1">讨论：等价抬头方法处理和底层的类成员和字节码的行为可以打破在几个方面：</p> 
     <ul style="font-size:smaller;" data-fanyi="1"> 
      <li data-fanyi="1">如果<code>C</code>不是象征性地访问从查找类的装载机，查找仍然可以成功，即使没有等效java表达式或bytecoded常数。</li> 
      <li data-fanyi="1">同样的，如果<code>T</code>或<code>MT</code>不是象征性地访问从查找类的装载机，查找仍然可以成功。例如，对于<code>MethodHandle.invokeExact</code>和<code>MethodHandle.invoke</code>查找总会成功的，无论请求类型。</li> 
      <li data-fanyi="1">如果存在安全管理器安装，它可以禁止查找各种理由（<a href="MethodHandles.Lookup.html#secmgr">see below</a>）。相比之下，在<code>CONSTANT_MethodHandle</code>常数的<code>ldc</code>指令不受安全管理检查。</li> 
      <li data-fanyi="1">如果抬头的方法有<a href="MethodHandle.html#maxarity">very large arity</a>创作，处理方法可能会失败，由于有太多的参数的方法处理类型。</li> 
     </ul> 
     <h1 data-fanyi="1"><a name="access"></a>access检查</h1>访问检查应用于 
     <code>Lookup</code>工厂方法，当一个方法创建句柄。这是从核心反射API的一个关键的区别，因为 
     <a href="../../../java/lang/reflect/Method.html#invoke-java.lang.Object-java.lang.Object...-"><code>java.lang.reflect.Method.invoke</code></a>执行访问检查对每一个来电，每一个电话。 
     <p data-fanyi="1">所有的访问检查从<code>Lookup</code>对象出发，比较其记录查找类对所有的请求创建的方法处理。一个<code>Lookup</code>对象可以用来创建任意数量的访问检查的方法处理，所有检查单查找类。</p> 
     <p data-fanyi="1">一个<code>Lookup</code>对象可以与其他受信任的代码共享，如元对象协议。一个共享的<code>Lookup</code>对象代表的创造能力，在查找类的私有成员的处理方法。即使特权代码使用<code>Lookup</code>对象，访问检查局限于原有的查找类的特权。</p> 
     <p data-fanyi="1">查找可能失败，因为包含类无法访问查找类，或者因为所需的类成员丢失，或者因为所需的类成员无法访问到查找类，或者因为查找对象不值得信任访问成员。在这种情况下，一个<code>ReflectiveOperationException</code>将尝试查找扔。确切的类将是以下的一个：</p> 
     <ul data-fanyi="1"> 
      <li data-fanyi="1">如果一个方法调用不存在方法异常请求，但不存在</li> 
      <li data-fanyi="1">如果一场nosuchfieldexception要求但不存在</li> 
      <li data-fanyi="1">非法存取异常-如果成员存在但访问检查失败</li> 
     </ul> 
     <p data-fanyi="1">总的来说，这一方法处理的条件下，可以抬头看了方法<code>M</code>没有限制性比的条件下，查找类可以编译、验证，解决了电话<code>M</code>，JVM会引发异常，像<code>NoSuchMethodError</code>方法处理，查找通常会提高相应的检查异常，如<code>NoSuchMethodException</code>。从查找和调用产生的方法处理效果<a href="MethodHandles.Lookup.html#equiv">exactly equivalent</a>执行编译、验证，解决了电话<code>M</code>。字段和构造函数的相同点是真的。</p> 
     <p style="font-size:smaller;" data-fanyi="1">讨论：访问检查只适用于命名和反射的方法、构造函数和字段。其他方法处理的创作方法，如<a href="../../../java/lang/invoke/MethodHandle.html#asType-java.lang.invoke.MethodType-"><code>MethodHandle.asType</code></a>，不需要任何访问检查，并独立于任何<code>Lookup</code>对象使用。</p> 
     <p data-fanyi="1">如果所需的成员<code>protected</code>，通常JVM规则适用，包括查找类必须是在同一个包所需的成员的要求，或必须继承的成员。（看到java虚拟机的规范，部分4.9.2，5.4.3.5，6.4。）此外，如果所需的成员在不同的包非静态字段或方法，所得到的处理方法可能只适用于查找类或其子类的对象。这一要求是通过缩小领导<code>this</code>参数的类型从<code>C</code>执行（这必然是一个父类的查找类）来查找类本身。</p> 
     <p data-fanyi="1">JVM对类似的要求，<code>invokespecial</code>指令，接收机参数必须匹配的解决方法和当前类。再次，这种要求是通过缩小所得到的方法句柄的主要参数的类型来实现的。（看到java虚拟机的规范，部分4.10.1.9。）</p> 
     <p data-fanyi="1">JVM是构造函数和静态初始化块具有特殊名称的内部方法（<code>"&lt;init&gt;"</code>和<code>"&lt;clinit&gt;"</code>）。调用指令的内部语法允许他们把这样的内部方法，好像他们是正常的方法，但是JVM字节码验证器排斥。查找这样一种内在的方法将产生一个<code>NoSuchMethodException</code>。</p> 
     <p data-fanyi="1">在某些情况下，之间的嵌套类的访问是由java编译器创建访问私人在相同的顶级声明另一个类的方法的一种包装方法得到的。例如，嵌套类可以访问其他相关类<code>C.D</code>内如<code>C</code>，<code>C.D.E</code>，或<code>C.B</code>私有成员，但是java编译器可能需要生成包装方法在那些相关的类。在这种情况下，对<code>C.E</code>一<code>Lookup</code>对象无法那些私有成员。这一限制的解决方法是<a href="../../../java/lang/invoke/MethodHandles.Lookup.html#in-java.lang.Class-"><code>Lookup.in</code></a>方法，可以将查找在<code>C.E</code>成一对其他任何人的课，没有特权特殊的提升。</p> 
     <p data-fanyi="1">访问允许一个给定的查询对象可以是有限的，根据其设定的<a href="../../../java/lang/invoke/MethodHandles.Lookup.html#lookupModes--"><code>lookupModes</code></a>，以正常访问查找类成员的子集。例如，在<a href="../../../java/lang/invoke/MethodHandles.html#publicLookup--"><code>publicLookup</code></a>方法产生一个查找对象只能访问公共类的公共成员。对方敏感的方法<a href="../../../java/lang/invoke/MethodHandles.html#lookup--"><code>lookup</code></a>产生查找对象全能力相对其调用者类，模拟所有支持字节码的行为。同时，该<a href="../../../java/lang/invoke/MethodHandles.Lookup.html#in-java.lang.Class-"><code>Lookup.in</code></a>方法可能会产生一个比原来的查找对象较少的接入方式查找对象。</p> 
     <p style="font-size:smaller;" data-fanyi="1"><a name="privacc"></a>讨论私人访问：我们说一个查找具有私有访问如果<a href="../../../java/lang/invoke/MethodHandles.Lookup.html#lookupModes--">lookup modes</a>包括<code>private</code>成员访问的可能性。在其他相关方法的记录，只有私人访问查找具有以下功能：</p> 
     <ul style="font-size:smaller;" data-fanyi="1"> 
      <li data-fanyi="1">访问查找类的私有字段、方法和构造函数</li> 
      <li data-fanyi="1">创建方法处理调用<a href="MethodHandles.Lookup.html#callsens">caller sensitive</a>方法，如<code>Class.forName</code></li> 
      <li data-fanyi="1">创建方法处理这<a href="../../../java/lang/invoke/MethodHandles.Lookup.html#findSpecial-java.lang.Class-java.lang.String-java.lang.invoke.MethodType-java.lang.Class-"><code>emulate invokespecial</code></a>指令</li> 
      <li data-fanyi="1">避免为查找类访问类<a href="MethodHandles.Lookup.html#secmgr">package access checks</a></li> 
      <li data-fanyi="1">创建具有私有访问其他类在同一包件<a href="../../../java/lang/invoke/MethodHandles.Lookup.html#in-java.lang.Class-"><code>delegated lookup objects</code></a></li> 
     </ul> 
     <p style="font-size:smaller;" data-fanyi="1">这些权限是一个事实，一个私人访问查找对象可以安全地追溯到始发班的后果，其<a href="MethodHandles.Lookup.html#equiv">bytecode behaviors</a>和java语言访问权限可以可靠地确定和模拟的方法处理。</p> 
     <h1 data-fanyi="1"><a name="secmgr"></a>security经理的相互作用</h1>虽然字节码指令只能在一个相关的类装载器的类，这个API可以搜索任何类的方法，只要一提到它的z-5ccc3d57-0bea—4513-8e16-707c2e25c033对象是可用的。这种交叉加载引用也可能与核心反射API，而不可能如 
     <code>invokestatic</code>或 
     <code>getfield</code>字节码指令。有一个 
     <a href="../../../java/lang/SecurityManager.html" title="class in java.lang">security manager API</a>允许应用程序检查装载机等交叉引用。这些检查都适用 
     <code>MethodHandles.Lookup</code> API和核心反射API（如发现 
     <a href="../../../java/lang/Class.html" title="class in java.lang"><code>类</code></a>）。 
     <p data-fanyi="1">如果安全管理器，会员查询受到额外的检查。从一到三个电话都是给安全管理器。这些要求可以通过把一个<a href="../../../java/lang/SecurityException.html" title="class in java.lang"><code>SecurityException</code></a>拒绝访问。定义<code>smgr</code>作为安全经理，<code>lookc</code>作为当前查找对象的查找类，<code>refc</code>为包含类的成员是受到追捧，并<code>defc</code>作为类的成员实际上是定义。价值<code>lookc</code>定义如果当前查找对象没有<a href="MethodHandles.Lookup.html#privacc">private access</a>为不存在。根据以下规则进行调用：</p> 
     <ul data-fanyi="1"> 
      <li data-fanyi="1"><b data-fanyi="1">步骤1：</b>如果<code>lookc</code>不存在，或者它的类装载器是不一样的<code>refc</code>或祖先的类装载器，然后<a href="../../../java/lang/SecurityManager.html#checkPackageAccess-java.lang.String-"><code>smgr.checkPackageAccess(refcPkg)</code></a>称，在<code>refcPkg</code>是<code>refc</code>包。</li> 
      <li data-fanyi="1"><b data-fanyi="1">步骤2：</b>如果检索的成员是不公开的，<code>lookc</code>是不存在的，然后<a href="../../../java/lang/SecurityManager.html#checkPermission-java.security.Permission-"><code>smgr.checkPermission</code></a>与<code>RuntimePermission("accessDeclaredMembers")</code>叫做。</li> 
      <li data-fanyi="1"><b data-fanyi="1">步骤3：</b>如果检索的成员是不公开的，如果<code>lookc</code>是不存在的，如果<code>defc</code>和<code>refc</code>是不同的，那么<a href="../../../java/lang/SecurityManager.html#checkPackageAccess-java.lang.String-"><code>smgr.checkPackageAccess(defcPkg)</code></a>称，在<code>defcPkg</code>是<code>defc</code>包。</li> 
     </ul>安检后通过执行访问检查。因此，上述规则的前提是公众的成员，或者是从查找类，访问成员权访问。 
     <h1 data-fanyi="1"><a name="callsens"></a>caller敏感的方法</h1>少量的java方法有一个特殊的性质称为呼叫者的敏感性。一个调用方的敏感方法可以根据其直接调用方的身份而不同的行为。 
     <p data-fanyi="1">如果请求一个来电敏感的方法处理，对<a href="MethodHandles.Lookup.html#equiv">bytecode behaviors</a>一般规则，但他们把查找类账户，以特殊的方式。由此产生的方法句柄的行为就好像它是从包含在查找类中的指令调用的，所以调用方敏感的方法检测到查找类。（相比之下，这种方法处理的调用是可以忽略的。）因此，在对方敏感的方法的情况下，不同的查找类可能会产生不同的行为方法处理。</p> 
     <p data-fanyi="1">如果查找的对象是<a href="../../../java/lang/invoke/MethodHandles.html#publicLookup--"><code>publicLookup()</code></a>，或其他一些不<a href="MethodHandles.Lookup.html#privacc">private access</a>查找对象，查找类被忽略。在这种情况下，没有Caller-Sensitive方法处理可以创建，访问被禁止，并且查找失败的<code>IllegalAccessException</code>。</p> 
     <p style="font-size:smaller;" data-fanyi="1">讨论：例如，对方敏感的方法<a href="../../../java/lang/Class.html#forName-java.lang.String-"><code>Class.forName(x)</code></a>可以返回不同类或把不同的例外，根据不同的类装载器的类来调用它。一个<code>Class.forName</code>公共查询将失败，因为没有合理的方法来确定它的字节码的行为。</p> 
     <p style="font-size:smaller;" data-fanyi="1">如果一个应用广泛共享高速缓存的方法处理，它应该使用<code>publicLookup()</code>创造它们。如果有一个查找<code>Class.forName</code>，它将失败，并且应用程序必须在这种情况下，采取适当的行动。它可能是一个后来的查找，也许在调用的引导方法，可以结合来电者的具体身份，使方法访问。</p> 
     <p style="font-size:smaller;" data-fanyi="1">功能<code>MethodHandles.lookup</code>外敏感，可以查找一个安全的基础。几乎所有的JSR 292 API依赖查找对象检查访问请求的其他方法。</p> 
    </div> </li> 
  </ul> 
 </div> 
 <div class="summary"> 
  <ul class="blockList"> 
   <li class="blockList"> 
    <!-- =========== FIELD SUMMARY =========== --> 
    <ul class="blockList"> 
     <li class="blockList"><a name="field.summary"> 
       <!--   --> </a> <h3>Field Summary</h3> 
      <table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Field Summary table, listing fields, and an explanation"> 
       <caption> 
        <span>Fields</span> 
        <span class="tabEnd">&nbsp;</span> 
       </caption> 
       <tbody> 
        <tr> 
         <th class="colFirst" scope="col">Modifier and Type</th> 
         <th class="colLast" scope="col">Field and Description</th> 
        </tr> 
        <tr class="altColor"> 
         <td class="colFirst"><code>static int</code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#PACKAGE">PACKAGE</a></span></code> 
          <div class="block" data-fanyi="1">
            一个单一的位掩码表示 
           <code>package</code>访问（默认），这可能有助于 
           <a href="../../../java/lang/invoke/MethodHandles.Lookup.html#lookupModes--"><code>lookupModes</code></a>结果。 
          </div> </td> 
        </tr> 
        <tr class="rowColor"> 
         <td class="colFirst"><code>static int</code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#PRIVATE">PRIVATE</a></span></code> 
          <div class="block" data-fanyi="1">
            一个单一的位掩码表示 
           <code>private</code>访问，这可能有助于 
           <a href="../../../java/lang/invoke/MethodHandles.Lookup.html#lookupModes--"><code>lookupModes</code></a>结果。 
          </div> </td> 
        </tr> 
        <tr class="altColor"> 
         <td class="colFirst"><code>static int</code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#PROTECTED">PROTECTED</a></span></code> 
          <div class="block" data-fanyi="1">
            一个单一的位掩码表示 
           <code>protected</code>访问，这可能有助于 
           <a href="../../../java/lang/invoke/MethodHandles.Lookup.html#lookupModes--"><code>lookupModes</code></a>结果。 
          </div> </td> 
        </tr> 
        <tr class="rowColor"> 
         <td class="colFirst"><code>static int</code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#PUBLIC">PUBLIC</a></span></code> 
          <div class="block" data-fanyi="1">
            一个单一的位掩码表示 
           <code>public</code>访问，这可能有助于 
           <a href="../../../java/lang/invoke/MethodHandles.Lookup.html#lookupModes--"><code>lookupModes</code></a>结果。 
          </div> </td> 
        </tr> 
       </tbody> 
      </table> </li> 
    </ul> 
    <!-- ========== METHOD SUMMARY =========== --> 
    <ul class="blockList"> 
     <li class="blockList"><a name="method.summary"> 
       <!--   --> </a> <h3>方法摘要</h3> 
      <table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation"> 
       <caption> 
        <span id="t0" class="activeTableTab"><span>所有方法</span><span class="tabEnd">&nbsp;</span></span> 
        <span id="t2" class="tableTab"><span><a href="javascript:show(2);">接口方法</a></span><span class="tabEnd">&nbsp;</span></span> 
        <span id="t4" class="tableTab"><span><a href="javascript:show(8);">具体的方法</a></span><span class="tabEnd">&nbsp;</span></span> 
       </caption> 
       <tbody> 
        <tr> 
         <th class="colFirst" scope="col">Modifier and Type</th> 
         <th class="colLast" scope="col">Method and Description</th> 
        </tr> 
        <tr id="i0" class="altColor"> 
         <td class="colFirst"><code><a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#bind-java.lang.Object-java.lang.String-java.lang.invoke.MethodType-">bind</a></span>(<a href="../../../java/lang/Object.html" title="class in java.lang">Object</a>&nbsp;receiver, <a href="../../../java/lang/String.html" title="class in java.lang">String</a>&nbsp;name, <a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;type)</code> 
          <div class="block" data-fanyi="1">
            用于非静态方法的早期绑定方法句柄。 
          </div> </td> 
        </tr> 
        <tr id="i1" class="rowColor"> 
         <td class="colFirst"><code><a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#findConstructor-java.lang.Class-java.lang.invoke.MethodType-">findConstructor</a></span>(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;refc, <a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;type)</code> 
          <div class="block" data-fanyi="1">
            产生的方法处理，创建一个对象并将它初始化，使用指定类型的构造函数。 
          </div> </td> 
        </tr> 
        <tr id="i2" class="altColor"> 
         <td class="colFirst"><code><a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#findGetter-java.lang.Class-java.lang.String-java.lang.Class-">findGetter</a></span>(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;refc, <a href="../../../java/lang/String.html" title="class in java.lang">String</a>&nbsp;name, <a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;type)</code> 
          <div class="block" data-fanyi="1">
            产生一个方法来处理对一个非静态字段的读取访问。 
          </div> </td> 
        </tr> 
        <tr id="i3" class="rowColor"> 
         <td class="colFirst"><code><a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#findSetter-java.lang.Class-java.lang.String-java.lang.Class-">findSetter</a></span>(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;refc, <a href="../../../java/lang/String.html" title="class in java.lang">String</a>&nbsp;name, <a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;type)</code> 
          <div class="block" data-fanyi="1">
            产生一个处理给非静态字段的写访问的方法。 
          </div> </td> 
        </tr> 
        <tr id="i4" class="altColor"> 
         <td class="colFirst"><code><a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#findSpecial-java.lang.Class-java.lang.String-java.lang.invoke.MethodType-java.lang.Class-">findSpecial</a></span>(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;refc, <a href="../../../java/lang/String.html" title="class in java.lang">String</a>&nbsp;name, <a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;type, <a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;specialCaller)</code> 
          <div class="block" data-fanyi="1">
            为一个虚拟方法产生早期绑定的方法句柄。 
          </div> </td> 
        </tr> 
        <tr id="i5" class="rowColor"> 
         <td class="colFirst"><code><a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#findStatic-java.lang.Class-java.lang.String-java.lang.invoke.MethodType-">findStatic</a></span>(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;refc, <a href="../../../java/lang/String.html" title="class in java.lang">String</a>&nbsp;name, <a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;type)</code> 
          <div class="block" data-fanyi="1">
            用于静态方法的方法处理。 
          </div> </td> 
        </tr> 
        <tr id="i6" class="altColor"> 
         <td class="colFirst"><code><a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#findStaticGetter-java.lang.Class-java.lang.String-java.lang.Class-">findStaticGetter</a></span>(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;refc, <a href="../../../java/lang/String.html" title="class in java.lang">String</a>&nbsp;name, <a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;type)</code> 
          <div class="block" data-fanyi="1">
            产生一个方法来处理静态字段的读取访问。 
          </div> </td> 
        </tr> 
        <tr id="i7" class="rowColor"> 
         <td class="colFirst"><code><a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#findStaticSetter-java.lang.Class-java.lang.String-java.lang.Class-">findStaticSetter</a></span>(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;refc, <a href="../../../java/lang/String.html" title="class in java.lang">String</a>&nbsp;name, <a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;type)</code> 
          <div class="block" data-fanyi="1">
            产生一个处理给静态字段的写访问的方法。 
          </div> </td> 
        </tr> 
        <tr id="i8" class="altColor"> 
         <td class="colFirst"><code><a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#findVirtual-java.lang.Class-java.lang.String-java.lang.invoke.MethodType-">findVirtual</a></span>(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;refc, <a href="../../../java/lang/String.html" title="class in java.lang">String</a>&nbsp;name, <a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;type)</code> 
          <div class="block" data-fanyi="1">
            产生一个虚拟方法的方法句柄。 
          </div> </td> 
        </tr> 
        <tr id="i9" class="rowColor"> 
         <td class="colFirst"><code><a href="../../../java/lang/invoke/MethodHandles.Lookup.html" title="class in java.lang.invoke">MethodHandles.Lookup</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#in-java.lang.Class-">in</a></span>(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;requestedLookupClass)</code> 
          <div class="block" data-fanyi="1">
            在指定的新查找类上创建一个查找。 
          </div> </td> 
        </tr> 
        <tr id="i10" class="altColor"> 
         <td class="colFirst"><code><a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;</code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#lookupClass--">lookupClass</a></span>()</code> 
          <div class="block" data-fanyi="1">
            告诉哪个类执行查找。 
          </div> </td> 
        </tr> 
        <tr id="i11" class="rowColor"> 
         <td class="colFirst"><code>int</code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#lookupModes--">lookupModes</a></span>()</code> 
          <div class="block" data-fanyi="1">
            告诉该查找对象可以生产的成员的访问保护类。 
          </div> </td> 
        </tr> 
        <tr id="i12" class="altColor"> 
         <td class="colFirst"><code><a href="../../../java/lang/invoke/MethodHandleInfo.html" title="interface in java.lang.invoke">MethodHandleInfo</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#revealDirect-java.lang.invoke.MethodHandle-">revealDirect</a></span>(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target)</code> 
          <div class="block" data-fanyi="1">
            裂纹 
           <a href="MethodHandleInfo.html#directmh">direct method handle</a>通过查找对象或类似的一个创造。 
          </div> </td> 
        </tr> 
        <tr id="i13" class="rowColor"> 
         <td class="colFirst"><code><a href="../../../java/lang/String.html" title="class in java.lang">String</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#toString--">toString</a></span>()</code> 
          <div class="block" data-fanyi="1">
            显示的名称来查找要做。 
          </div> </td> 
        </tr> 
        <tr id="i14" class="altColor"> 
         <td class="colFirst"><code><a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#unreflect-java.lang.reflect.Method-">unreflect</a></span>(<a href="../../../java/lang/reflect/Method.html" title="class in java.lang.reflect">方法</a>&nbsp;m)</code> 
          <div class="block" data-fanyi="1">
            让 
           <a href="MethodHandleInfo.html#directmh">direct method handle</a>到nullm，如果查找类许可。 
          </div> </td> 
        </tr> 
        <tr id="i15" class="rowColor"> 
         <td class="colFirst"><code><a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#unreflectConstructor-java.lang.reflect.Constructor-">unreflectConstructor</a></span>(<a href="../../../java/lang/reflect/Constructor.html" title="class in java.lang.reflect">Constructor</a>&lt;?&gt;&nbsp;c)</code> 
          <div class="block" data-fanyi="1">
            为反射的构造函数生成方法句柄。 
          </div> </td> 
        </tr> 
        <tr id="i16" class="altColor"> 
         <td class="colFirst"><code><a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#unreflectGetter-java.lang.reflect.Field-">unreflectGetter</a></span>(<a href="../../../java/lang/reflect/Field.html" title="class in java.lang.reflect">Field</a>&nbsp;f)</code> 
          <div class="block" data-fanyi="1">
            产生一个方法来处理对一个反射字段的读取访问。 
          </div> </td> 
        </tr> 
        <tr id="i17" class="rowColor"> 
         <td class="colFirst"><code><a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#unreflectSetter-java.lang.reflect.Field-">unreflectSetter</a></span>(<a href="../../../java/lang/reflect/Field.html" title="class in java.lang.reflect">Field</a>&nbsp;f)</code> 
          <div class="block" data-fanyi="1">
            产生一个处理对一个反射字段的写访问的方法。 
          </div> </td> 
        </tr> 
        <tr id="i18" class="altColor"> 
         <td class="colFirst"><code><a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../java/lang/invoke/MethodHandles.Lookup.html#unreflectSpecial-java.lang.reflect.Method-java.lang.Class-">unreflectSpecial</a></span>(<a href="../../../java/lang/reflect/Method.html" title="class in java.lang.reflect">方法</a>&nbsp;m, <a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;specialCaller)</code> 
          <div class="block" data-fanyi="1">
            用于反射方法的方法处理。 
          </div> </td> 
        </tr> 
       </tbody> 
      </table> 
      <ul class="blockList"> 
       <li class="blockList"><a name="methods.inherited.from.class.java.lang.Object"> 
         <!--   --> </a> <h3>Methods inherited from class&nbsp;java.lang.<a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></h3> <code><a href="../../../java/lang/Object.html#clone--">clone</a>, <a href="../../../java/lang/Object.html#equals-java.lang.Object-">equals</a>, <a href="../../../java/lang/Object.html#finalize--">finalize</a>, <a href="../../../java/lang/Object.html#getClass--">getClass</a>, <a href="../../../java/lang/Object.html#hashCode--">hashCode</a>, <a href="../../../java/lang/Object.html#notify--">notify</a>, <a href="../../../java/lang/Object.html#notifyAll--">notifyAll</a>, <a href="../../../java/lang/Object.html#wait--">wait</a>, <a href="../../../java/lang/Object.html#wait-long-">wait</a>, <a href="../../../java/lang/Object.html#wait-long-int-">wait</a></code></li> 
      </ul> </li> 
    </ul> </li> 
  </ul> 
 </div> 
 <div class="details"> 
  <ul class="blockList"> 
   <li class="blockList"> 
    <!-- ============ FIELD DETAIL =========== --> 
    <ul class="blockList"> 
     <li class="blockList"><a name="field.detail"> 
       <!--   --> </a> <h3>Field Detail</h3> <a name="PUBLIC"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>PUBLIC</h4> <pre>public static final&nbsp;int PUBLIC</pre> 
        <div class="block" data-fanyi="1">
          一个单一的位掩码表示 
         <code>public</code>访问，这可能有助于 
         <a href="../../../java/lang/invoke/MethodHandles.Lookup.html#lookupModes--"><code>lookupModes</code></a>结果。的价值， 
         <code>0x01</code>，恰好是在 
         <code>public</code> 
         <a href="../../../java/lang/reflect/Modifier.html#PUBLIC">modifier bit</a>值相同。 
        </div> 
        <dl> 
         <dt> 
          <span class="seeLabel">另请参见：</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <a href="../../../constant-values.html#java.lang.invoke.MethodHandles.Lookup.PUBLIC">Constant Field Values</a> 
         </dd> 
        </dl> </li> 
      </ul> <a name="PRIVATE"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>PRIVATE</h4> <pre>public static final&nbsp;int PRIVATE</pre> 
        <div class="block" data-fanyi="1">
          一个单一的位掩码表示 
         <code>private</code>访问，这可能有助于 
         <a href="../../../java/lang/invoke/MethodHandles.Lookup.html#lookupModes--"><code>lookupModes</code></a>结果。价值， 
         <code>0x02</code>，恰好是在 
         <code>private</code> 
         <a href="../../../java/lang/reflect/Modifier.html#PRIVATE">modifier bit</a>值相同。 
        </div> 
        <dl> 
         <dt> 
          <span class="seeLabel">另请参见：</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <a href="../../../constant-values.html#java.lang.invoke.MethodHandles.Lookup.PRIVATE">Constant Field Values</a> 
         </dd> 
        </dl> </li> 
      </ul> <a name="PROTECTED"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>PROTECTED</h4> <pre>public static final&nbsp;int PROTECTED</pre> 
        <div class="block" data-fanyi="1">
          一个单一的位掩码表示 
         <code>protected</code>访问，这可能有助于 
         <a href="../../../java/lang/invoke/MethodHandles.Lookup.html#lookupModes--"><code>lookupModes</code></a>结果。价值， 
         <code>0x04</code>，恰好是在 
         <code>protected</code> 
         <a href="../../../java/lang/reflect/Modifier.html#PROTECTED">modifier bit</a>值相同。 
        </div> 
        <dl> 
         <dt> 
          <span class="seeLabel">另请参见：</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <a href="../../../constant-values.html#java.lang.invoke.MethodHandles.Lookup.PROTECTED">Constant Field Values</a> 
         </dd> 
        </dl> </li> 
      </ul> <a name="PACKAGE"> 
       <!--   --> </a> 
      <ul class="blockListLast"> 
       <li class="blockList"> <h4>PACKAGE</h4> <pre>public static final&nbsp;int PACKAGE</pre> 
        <div class="block" data-fanyi="1">
          一个单一的位掩码表示 
         <code>package</code>访问（默认），这可能有助于 
         <a href="../../../java/lang/invoke/MethodHandles.Lookup.html#lookupModes--"><code>lookupModes</code></a>结果。价值是 
         <code>0x08</code>，这不符合任何特定的 
         <a href="../../../java/lang/reflect/Modifier.html" title="class in java.lang.reflect">modifier bit</a>意味深长。 
        </div> 
        <dl> 
         <dt> 
          <span class="seeLabel">另请参见：</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <a href="../../../constant-values.html#java.lang.invoke.MethodHandles.Lookup.PACKAGE">Constant Field Values</a> 
         </dd> 
        </dl> </li> 
      </ul> </li> 
    </ul> 
    <!-- ============ METHOD DETAIL ========== --> 
    <ul class="blockList"> 
     <li class="blockList"><a name="method.detail"> 
       <!--   --> </a> <h3>方法详细信息</h3> <a name="lookupClass--"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>lookupClass</h4> <pre>public&nbsp;<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;lookupClass()</pre> 
        <div class="block" data-fanyi="1">
          告诉哪个类执行查找。正是这一类对可见性和访问权限进行检查的类。 
         <p data-fanyi="1">这类意味着访问权限的最高水平，但权限可以另外有限的位掩码<a href="../../../java/lang/invoke/MethodHandles.Lookup.html#lookupModes--"><code>lookupModes</code></a>，控制是否公开的成员可以访问。</p> 
        </div> 
        <dl> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           查找对象的查询类，在此查找对象查找成员 
         </dd> 
        </dl> </li> 
      </ul> <a name="lookupModes--"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>lookupModes</h4> <pre>public&nbsp;int&nbsp;lookupModes()</pre> 
        <div class="block" data-fanyi="1">
          告诉该查找对象可以生产的成员的访问保护类。其结果是一位 
         <a href="../../../java/lang/invoke/MethodHandles.Lookup.html#PUBLIC">PUBLIC (0x01)</a>， 
         <a href="../../../java/lang/invoke/MethodHandles.Lookup.html#PRIVATE">PRIVATE (0x02)</a>， 
         <a href="../../../java/lang/invoke/MethodHandles.Lookup.html#PROTECTED">PROTECTED (0x04)</a>位掩码，并 
         <a href="../../../java/lang/invoke/MethodHandles.Lookup.html#PACKAGE">PACKAGE (0x08)</a>。 
         <p data-fanyi="1">刚创建的查找对象在<a href="../../../java/lang/invoke/MethodHandles.html#lookup--">caller's class</a>有所有可能的位设置，因为调用者类可以访问自己的所有成员。在一个新的查找类<a href="../../../java/lang/invoke/MethodHandles.Lookup.html#in-java.lang.Class-">created from a previous lookup object</a>查找对象可能有一些模式位设置为零。这的目的是通过新的查找对象来限制访问，以便它只能访问原始查找对象所能达到的名称，也可以访问新的查找类。</p> 
        </div> 
        <dl> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           查找模式，从而限制由该查找对象执行的访问的种类 
         </dd> 
        </dl> </li> 
      </ul> <a name="in-java.lang.Class-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>in</h4> <pre>public&nbsp;<a href="../../../java/lang/invoke/MethodHandles.Lookup.html" title="class in java.lang.invoke">MethodHandles.Lookup</a>&nbsp;in(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;requestedLookupClass)</pre> 
        <div class="block" data-fanyi="1">
          在指定的新查找类上创建一个查找。生成的对象将报告指定的类作为自己的 
         <a href="../../../java/lang/invoke/MethodHandles.Lookup.html#lookupClass"><code>lookupClass</code></a>。 
         <p data-fanyi="1">然而，由此产生的<code>Lookup</code>对象确保没有更多的接入能力比原。特别是，访问能力可以丢失如下：</p> 
         <ul data-fanyi="1"> 
          <li data-fanyi="1">如果新的查找类与旧的查找类不同，受保护的成员将无法通过继承而访问。（受保护的成员可能会继续被访问，因为包共享。）</li> 
          <li data-fanyi="1">如果新的查找类处于一个不同的包中，而不是旧的，受保护的和默认的（包）成员将无法访问。</li> 
          <li data-fanyi="1">如果新的查找类不在同一个包成员内，则将无法访问私有成员。</li> 
          <li data-fanyi="1">如果新的查找类无法访问旧的查找类，则没有成员，甚至没有公共成员，将访问。（在所有其他情况下，公共成员将继续是可访问的。）</li> 
         </ul> 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>requestedLookupClass</code> -新的查找对象所需的查找类 
         </dd> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           报告所需的查找类的查找对象 
         </dd> 
         <dt> 
          <span class="throwsLabel">异常</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> -如果参数为空 
         </dd> 
        </dl> </li> 
      </ul> <a name="toString--"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>toString</h4> <pre>public&nbsp;<a href="../../../java/lang/String.html" title="class in java.lang">String</a>&nbsp;toString()</pre> 
        <div class="block" data-fanyi="1">
          显示的名称来查找要做。（这个名字是一个报告的 
         <a href="../../../java/lang/Class.html#getName--"><code>Class.getName</code></a>。）如果在访问允许这种查询的限制，这是通过添加一个后缀类名表示，由斜线和关键字。关键词是最大允许访问，和选择如下： 
         <ul data-fanyi="1"> 
          <li data-fanyi="1">如果不允许接入，后缀是“访问”。</li> 
          <li data-fanyi="1">如果只有公共访问是允许的，后缀是“/公共”。</li> 
          <li data-fanyi="1">如果只允许公共和包访问被允许，后缀是“/包”。</li> 
          <li data-fanyi="1">如果只公开，包和私有访问是允许的，后缀是“/私人”。</li> 
         </ul>如果上述情况适用，在这种情况下，完全访问（公共，私人，封装，允许和保护）。在这种情况下，没有添加后缀。这是真正的唯一的一个对象获得来自 
         <a href="../../../java/lang/invoke/MethodHandles.html#lookup--"><code>MethodHandles.lookup</code></a>。由 
         <a href="../../../java/lang/invoke/MethodHandles.Lookup.html#in-java.lang.Class-"><code>Lookup.in</code></a>对象总是有限制的访问，并将显示一个后缀。 
         <p data-fanyi="1">（似乎奇怪的是，受保护的访问应该比私人访问更强大。独立包装的访问来看，访问是输了，因为它需要调用者和被调用者之间的直接子类关系。）</p> 
        </div> 
        <dl> 
         <dt> 
          <span class="overrideSpecifyLabel">重写：</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/Object.html#toString--">toString</a></code>&nbsp;方法重写，继承类&nbsp; 
          <code><a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></code> 
         </dd> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           对象的字符串表示形式。 
         </dd> 
         <dt> 
          <span class="seeLabel">另请参见：</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <a href="../../../java/lang/invoke/MethodHandles.Lookup.html#in-java.lang.Class-"><code>in(java.lang.Class&lt;?&gt;)</code></a> 
         </dd> 
        </dl> </li> 
      </ul> <a name="findStatic-java.lang.Class-java.lang.String-java.lang.invoke.MethodType-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>findStatic</h4> <pre>public&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;findStatic(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;refc,
                               <a href="../../../java/lang/String.html" title="class in java.lang">String</a>&nbsp;name,
                               <a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;type)
                        throws <a href="../../../java/lang/NoSuchMethodException.html" title="class in java.lang">NoSuchMethodException</a>,
                               <a href="../../../java/lang/IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></pre> 
        <div class="block" data-fanyi="1">
          用于静态方法的方法处理。方法句柄的类型将是该方法的一种方法。（因为静态方法不需要接收器，没有额外的接收器参数插入法处理类型，因为会有 
         <a href="../../../java/lang/invoke/MethodHandles.Lookup.html#findVirtual-java.lang.Class-java.lang.String-java.lang.invoke.MethodType-"><code>findVirtual</code></a>或 
         <a href="../../../java/lang/invoke/MethodHandles.Lookup.html#findSpecial-java.lang.Class-java.lang.String-java.lang.invoke.MethodType-java.lang.Class-"><code>findSpecial</code></a>。）的方法和它的所有参数类型必须要查找对象的访问。 
         <p data-fanyi="1">返回的方法处理会有<a href="../../../java/lang/invoke/MethodHandle.html#asVarargsCollector-java.lang.Class-">variable arity</a>若方法的变量数量修改位（<code>0x0080</code>）设置。</p> 
         <p data-fanyi="1">如果调用返回的方法句柄，则该方法的类将被初始化，如果它还没有被初始化。</p> 
         <p data-fanyi="1"><b data-fanyi="1">例子:</b></p> 
         <blockquote> 
          <pre><code>
import static java.lang.invoke.MethodHandles.*;
import static java.lang.invoke.MethodType.*;
...
MethodHandle MH_asList = publicLookup().findStatic(Arrays.class,
  "asList", methodType(List.class, Object[].class));
assertEquals("[x, y]", MH_asList.invoke("x", "y").toString());
 </code></pre> 
         </blockquote> 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>refc</code> -类的方法访问 
         </dd> 
         <dd data-fanyi="1"> 
          <code>name</code> -名称的方法 
         </dd> 
         <dd data-fanyi="1"> 
          <code>type</code> -方法的类型 
         </dd> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           所需的方法处理 
         </dd> 
         <dt> 
          <span class="throwsLabel">异常</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/NoSuchMethodException.html" title="class in java.lang">NoSuchMethodException</a></code>如果方法不存在 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></code>如果访问检查失败，或如果方法不 
          <code>static</code>，或者方法的变性剂位设置和 
          <code>asVarargsCollector</code>失败 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> -如果一个安全管理是目前这 
          <a href="MethodHandles.Lookup.html#secmgr">refuses access</a> 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> -如果任一参数为空 
         </dd> 
        </dl> </li> 
      </ul> <a name="findVirtual-java.lang.Class-java.lang.String-java.lang.invoke.MethodType-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>findVirtual</h4> <pre>public&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;findVirtual(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;refc,
                                <a href="../../../java/lang/String.html" title="class in java.lang">String</a>&nbsp;name,
                                <a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;type)
                         throws <a href="../../../java/lang/NoSuchMethodException.html" title="class in java.lang">NoSuchMethodException</a>,
                                <a href="../../../java/lang/IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></pre> 
        <div class="block" data-fanyi="1">
          产生一个虚拟方法的方法句柄。该方法处理的类型将是该方法与接收机类型（通常 
         <code>refc</code>）值。该方法和它的所有参数类型必须是可访问的查找对象。 
         <p data-fanyi="1">当调用时，句柄将把第一个参数视为一个接收器，并在接收器的类型上发送，以确定哪些方法实现输入。（调度作用，通过<code>invokevirtual</code>或<code>invokeinterface</code>指令。执行相同）</p> 
         <p data-fanyi="1">第一个参数是类型<code>refc</code>如果查找类具有完全的权限访问的成员。否则，成员必须<code>protected</code>和第一个参数将被限制在类型查找类。</p> 
         <p data-fanyi="1">返回的方法处理会有<a href="../../../java/lang/invoke/MethodHandle.html#asVarargsCollector-java.lang.Class-">variable arity</a>若方法的变量数量修改位（<code>0x0080</code>）设置。</p> 
         <p data-fanyi="1">因为<code>invokevirtual</code>指令和方法处理产生的<code>findVirtual</code>之间的一般<a href="MethodHandles.Lookup.html#equiv">equivalence</a>，如果类是<code>MethodHandle</code>和名称的字符串是<code>invokeExact</code>或<code>invoke</code>，产生的方法处理相当于一个<a href="../../../java/lang/invoke/MethodHandles.html#exactInvoker-java.lang.invoke.MethodType-"><code>MethodHandles.exactInvoker</code></a>或<a href="../../../java/lang/invoke/MethodHandles.html#invoker-java.lang.invoke.MethodType-"><code>MethodHandles.invoker</code></a>同<code>type</code>争论而产生。<b data-fanyi="1">例子:</b></p> 
         <blockquote> 
          <pre><code>
import static java.lang.invoke.MethodHandles.*;
import static java.lang.invoke.MethodType.*;
...
MethodHandle MH_concat = publicLookup().findVirtual(String.class,
  "concat", methodType(String.class, String.class));
MethodHandle MH_hashCode = publicLookup().findVirtual(Object.class,
  "hashCode", methodType(int.class));
MethodHandle MH_hashCode_String = publicLookup().findVirtual(String.class,
  "hashCode", methodType(int.class));
assertEquals("xy", (String) MH_concat.invokeExact("x", "y"));
assertEquals("xy".hashCode(), (int) MH_hashCode.invokeExact((Object)"xy"));
assertEquals("xy".hashCode(), (int) MH_hashCode_String.invokeExact("xy"));
// interface method:
MethodHandle MH_subSequence = publicLookup().findVirtual(CharSequence.class,
  "subSequence", methodType(CharSequence.class, int.class, int.class));
assertEquals("def", MH_subSequence.invoke("abcdefghi", 3, 6).toString());
// constructor "internal method" must be accessed differently:
MethodType MT_newString = methodType(void.class); //()V for new String()
try { assertEquals("impossible", lookup()
        .findVirtual(String.class, "&lt;init&gt;", MT_newString));
 } catch (NoSuchMethodException ex) { } // OK
MethodHandle MH_newString = publicLookup()
  .findConstructor(String.class, MT_newString);
assertEquals("", (String) MH_newString.invokeExact());
 </code></pre> 
         </blockquote> 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>refc</code>的类或接口的方法访问 
         </dd> 
         <dd data-fanyi="1"> 
          <code>name</code> -名称的方法 
         </dd> 
         <dd data-fanyi="1"> 
          <code>type</code> -方法的类型，与接收机参数省略 
         </dd> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           所需的方法处理 
         </dd> 
         <dt> 
          <span class="throwsLabel">异常</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/NoSuchMethodException.html" title="class in java.lang">NoSuchMethodException</a></code>如果方法不存在 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></code>如果访问检查失败，或如果方法 
          <code>static</code>或者方法的变性剂位设置和 
          <code>asVarargsCollector</code>失败 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> -如果一个安全管理是目前这 
          <a href="MethodHandles.Lookup.html#secmgr">refuses access</a> 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> -如果任一参数为空 
         </dd> 
        </dl> </li> 
      </ul> <a name="findConstructor-java.lang.Class-java.lang.invoke.MethodType-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>findConstructor</h4> <pre>public&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;findConstructor(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;refc,
                                    <a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;type)
                             throws <a href="../../../java/lang/NoSuchMethodException.html" title="class in java.lang">NoSuchMethodException</a>,
                                    <a href="../../../java/lang/IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></pre> 
        <div class="block" data-fanyi="1">
          产生的方法处理，创建一个对象并将它初始化，使用指定类型的构造函数。方法句柄的参数类型将是那些构造函数的参数类型，而返回类型将是对构造函数类的引用。构造函数和它的所有参数类型必须是查找对象的访问。 
         <p data-fanyi="1">请求的类型必须有一个<code>void</code>返回类型。（这是与JVM的处理构造函数的类型描述符。一致）</p> 
         <p data-fanyi="1">返回的方法处理会有<a href="../../../java/lang/invoke/MethodHandle.html#asVarargsCollector-java.lang.Class-">variable arity</a>如果构造函数的变量数量修改位（<code>0x0080</code>）设置。</p> 
         <p data-fanyi="1">如果调用返回的方法句柄，则构造函数的类将被初始化，如果它还没有被初始化。</p> 
         <p data-fanyi="1"><b data-fanyi="1">例子:</b></p> 
         <blockquote> 
          <pre><code>
import static java.lang.invoke.MethodHandles.*;
import static java.lang.invoke.MethodType.*;
...
MethodHandle MH_newArrayList = publicLookup().findConstructor(
  ArrayList.class, methodType(void.class, Collection.class));
Collection orig = Arrays.asList("x", "y");
Collection copy = (ArrayList) MH_newArrayList.invokeExact(orig);
assert(orig != copy);
assertEquals(orig, copy);
// a variable-arity constructor:
MethodHandle MH_newProcessBuilder = publicLookup().findConstructor(
  ProcessBuilder.class, methodType(void.class, String[].class));
ProcessBuilder pb = (ProcessBuilder)
  MH_newProcessBuilder.invoke("x", "y", "z");
assertEquals("[x, y, z]", pb.command().toString());
 </code></pre> 
         </blockquote> 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>refc</code>的类或接口的方法访问 
         </dd> 
         <dd data-fanyi="1"> 
          <code>type</code> -方法的类型，与接收机参数省略，和void返回类型 
         </dd> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           所需的方法处理 
         </dd> 
         <dt> 
          <span class="throwsLabel">异常</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/NoSuchMethodException.html" title="class in java.lang">NoSuchMethodException</a></code> -如果构造函数不存在 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></code>如果访问检查失败或如果方法的变性剂位设置和 
          <code>asVarargsCollector</code>失败 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> -如果一个安全管理是目前这 
          <a href="MethodHandles.Lookup.html#secmgr">refuses access</a> 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> -如果任一参数为空 
         </dd> 
        </dl> </li> 
      </ul> <a name="findSpecial-java.lang.Class-java.lang.String-java.lang.invoke.MethodType-java.lang.Class-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>findSpecial</h4> <pre>public&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;findSpecial(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;refc,
                                <a href="../../../java/lang/String.html" title="class in java.lang">String</a>&nbsp;name,
                                <a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;type,
                                <a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;specialCaller)
                         throws <a href="../../../java/lang/NoSuchMethodException.html" title="class in java.lang">NoSuchMethodException</a>,
                                <a href="../../../java/lang/IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></pre> 
        <div class="block" data-fanyi="1">
          为一个虚拟方法产生早期绑定的方法句柄。它将绕过检查重写方法的接收器， 
         <a href="MethodHandles.Lookup.html#equiv">as if called</a>从 
         <code>invokespecial</code>指令在明确指定 
         <code>specialCaller</code>，处理方法的类型将是该方法与适当限制接收机类型前缀。（接收器类型将 
         <code>specialCaller</code>或亚型）的方法和它的所有参数类型必须要查找对象的访问。 
         <p data-fanyi="1">以前的方法解决，如果明确指定调用类是不相同的查找类，或者如果该查询对象没有<a href="MethodHandles.Lookup.html#privacc">private access</a>权限，访问失败。</p> 
         <p data-fanyi="1">返回的方法处理会有<a href="../../../java/lang/invoke/MethodHandle.html#asVarargsCollector-java.lang.Class-">variable arity</a>若方法的变量数量修改位（<code>0x0080</code>）设置。</p> 
         <p style="font-size:smaller;" data-fanyi="1">（注：JVM内部方法命名为“ 
          <初始化>
            ”是不可见的这个API，即使invokespecial指示可以参考它们在特殊情况下。使用findconstructor访问在一个安全的方式实例初始化方法。） 
          </初始化></p> 
         <p data-fanyi="1"><b data-fanyi="1">例子:</b></p> 
         <blockquote> 
          <pre><code>
import static java.lang.invoke.MethodHandles.*;
import static java.lang.invoke.MethodType.*;
...
static class Listie extends ArrayList {
  public String toString() { return "[wee Listie]"; }
  static Lookup lookup() { return MethodHandles.lookup(); }
}
...
// no access to constructor via invokeSpecial:
MethodHandle MH_newListie = Listie.lookup()
  .findConstructor(Listie.class, methodType(void.class));
Listie l = (Listie) MH_newListie.invokeExact();
try { assertEquals("impossible", Listie.lookup().findSpecial(
        Listie.class, "&lt;init&gt;", methodType(void.class), Listie.class));
 } catch (NoSuchMethodException ex) { } // OK
// access to super and self methods via invokeSpecial:
MethodHandle MH_super = Listie.lookup().findSpecial(
  ArrayList.class, "toString" , methodType(String.class), Listie.class);
MethodHandle MH_this = Listie.lookup().findSpecial(
  Listie.class, "toString" , methodType(String.class), Listie.class);
MethodHandle MH_duper = Listie.lookup().findSpecial(
  Object.class, "toString" , methodType(String.class), Listie.class);
assertEquals("[]", (String) MH_super.invokeExact(l));
assertEquals(""+l, (String) MH_this.invokeExact(l));
assertEquals("[]", (String) MH_duper.invokeExact(l)); // ArrayList method
try { assertEquals("inaccessible", Listie.lookup().findSpecial(
        String.class, "toString", methodType(String.class), Listie.class));
 } catch (IllegalAccessException ex) { } // OK
Listie subl = new Listie() { public String toString() { return "[subclass]"; } };
assertEquals(""+l, (String) MH_this.invokeExact(subl)); // Listie method
 </code></pre> 
         </blockquote> 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>refc</code>的类或接口的方法访问 
         </dd> 
         <dd data-fanyi="1"> 
          <code>name</code> -的方法的名称（不可“ 
          <初始化>
            ”） 
          </初始化> 
         </dd> 
         <dd data-fanyi="1"> 
          <code>type</code> -方法的类型，与接收机参数省略 
         </dd> 
         <dd data-fanyi="1"> 
          <code>specialCaller</code> -该调用的类进行 
          <code>invokespecial</code> 
         </dd> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           所需的方法处理 
         </dd> 
         <dt> 
          <span class="throwsLabel">异常</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/NoSuchMethodException.html" title="class in java.lang">NoSuchMethodException</a></code>如果方法不存在 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></code>如果访问检查失败或如果方法的变性剂位设置和 
          <code>asVarargsCollector</code>失败 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> -如果一个安全管理是目前这 
          <a href="MethodHandles.Lookup.html#secmgr">refuses access</a> 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> -如果任一参数为空 
         </dd> 
        </dl> </li> 
      </ul> <a name="findGetter-java.lang.Class-java.lang.String-java.lang.Class-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>findGetter</h4> <pre>public&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;findGetter(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;refc,
                               <a href="../../../java/lang/String.html" title="class in java.lang">String</a>&nbsp;name,
                               <a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;type)
                        throws <a href="../../../java/lang/NoSuchFieldException.html" title="class in java.lang">NoSuchFieldException</a>,
                               <a href="../../../java/lang/IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></pre> 
        <div class="block" data-fanyi="1">
          产生一个方法来处理对一个非静态字段的读取访问。方法句柄的类型将有字段的值类型的返回类型。方法句柄的单个参数将是包含字段的实例。访问检查立即执行代表查找类。 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>refc</code>的类或接口的方法访问 
         </dd> 
         <dd data-fanyi="1"> 
          <code>name</code> -字段的名称 
         </dd> 
         <dd data-fanyi="1"> 
          <code>type</code> -该字段的类型 
         </dd> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           可以从字段中加载值的方法句柄 
         </dd> 
         <dt> 
          <span class="throwsLabel">异常</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/NoSuchFieldException.html" title="class in java.lang">NoSuchFieldException</a></code>如果字段不存在 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></code>如果访问检查失败，或如果该字段是 
          <code>static</code> 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> -如果一个安全管理是目前这 
          <a href="MethodHandles.Lookup.html#secmgr">refuses access</a> 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> -如果任一参数为空 
         </dd> 
        </dl> </li> 
      </ul> <a name="findSetter-java.lang.Class-java.lang.String-java.lang.Class-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>findSetter</h4> <pre>public&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;findSetter(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;refc,
                               <a href="../../../java/lang/String.html" title="class in java.lang">String</a>&nbsp;name,
                               <a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;type)
                        throws <a href="../../../java/lang/NoSuchFieldException.html" title="class in java.lang">NoSuchFieldException</a>,
                               <a href="../../../java/lang/IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></pre> 
        <div class="block" data-fanyi="1">
          产生一个处理给非静态字段的写访问的方法。方法句柄的类型将有一个无效的返回类型。该方法处理将需要两个参数，包含字段的实例，以及存储的值。第二个参数将是字段的值类型。访问检查立即执行代表查找类。 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>refc</code>的类或接口的方法访问 
         </dd> 
         <dd data-fanyi="1"> 
          <code>name</code> -字段的名称 
         </dd> 
         <dd data-fanyi="1"> 
          <code>type</code> -该字段的类型 
         </dd> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           可以将值存储到字段的方法处理 
         </dd> 
         <dt> 
          <span class="throwsLabel">异常</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/NoSuchFieldException.html" title="class in java.lang">NoSuchFieldException</a></code>如果字段不存在 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></code>如果访问检查失败，或如果该字段是 
          <code>static</code> 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> -如果一个安全管理是目前这 
          <a href="MethodHandles.Lookup.html#secmgr">refuses access</a> 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> -如果任一参数为空 
         </dd> 
        </dl> </li> 
      </ul> <a name="findStaticGetter-java.lang.Class-java.lang.String-java.lang.Class-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>findStaticGetter</h4> <pre>public&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;findStaticGetter(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;refc,
                                     <a href="../../../java/lang/String.html" title="class in java.lang">String</a>&nbsp;name,
                                     <a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;type)
                              throws <a href="../../../java/lang/NoSuchFieldException.html" title="class in java.lang">NoSuchFieldException</a>,
                                     <a href="../../../java/lang/IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></pre> 
        <div class="block" data-fanyi="1">
          产生一个方法来处理静态字段的读取访问。方法句柄的类型将有字段的值类型的返回类型。该方法句柄将不需要参数。访问检查立即执行代表查找类。 
         <p data-fanyi="1">如果调用返回的方法句柄，则该字段的类将被初始化，如果它没有被初始化。</p> 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>refc</code>的类或接口的方法访问 
         </dd> 
         <dd data-fanyi="1"> 
          <code>name</code> -字段的名称 
         </dd> 
         <dd data-fanyi="1"> 
          <code>type</code> -该字段的类型 
         </dd> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           可以从字段中加载值的方法句柄 
         </dd> 
         <dt> 
          <span class="throwsLabel">异常</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/NoSuchFieldException.html" title="class in java.lang">NoSuchFieldException</a></code>如果字段不存在 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></code>如果访问检查失败，或如果该字段是不 
          <code>static</code> 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> -如果一个安全管理是目前这 
          <a href="MethodHandles.Lookup.html#secmgr">refuses access</a> 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> -如果任一参数为空 
         </dd> 
        </dl> </li> 
      </ul> <a name="findStaticSetter-java.lang.Class-java.lang.String-java.lang.Class-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>findStaticSetter</h4> <pre>public&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;findStaticSetter(<a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;refc,
                                     <a href="../../../java/lang/String.html" title="class in java.lang">String</a>&nbsp;name,
                                     <a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;type)
                              throws <a href="../../../java/lang/NoSuchFieldException.html" title="class in java.lang">NoSuchFieldException</a>,
                                     <a href="../../../java/lang/IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></pre> 
        <div class="block" data-fanyi="1">
          产生一个处理给静态字段的写访问的方法。方法句柄的类型将有一个无效的返回类型。该方法处理将采取一个单一的参数，字段的值类型，要存储的值。访问检查立即执行代表查找类。 
         <p data-fanyi="1">如果调用返回的方法句柄，则该字段的类将被初始化，如果它没有被初始化。</p> 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>refc</code>的类或接口的方法访问 
         </dd> 
         <dd data-fanyi="1"> 
          <code>name</code> -字段的名称 
         </dd> 
         <dd data-fanyi="1"> 
          <code>type</code> -该字段的类型 
         </dd> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           可以将值存储到字段的方法处理 
         </dd> 
         <dt> 
          <span class="throwsLabel">异常</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/NoSuchFieldException.html" title="class in java.lang">NoSuchFieldException</a></code>如果字段不存在 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></code>如果访问检查失败，或如果该字段是不 
          <code>static</code> 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> -如果一个安全管理是目前这 
          <a href="MethodHandles.Lookup.html#secmgr">refuses access</a> 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> -如果任一参数为空 
         </dd> 
        </dl> </li> 
      </ul> <a name="bind-java.lang.Object-java.lang.String-java.lang.invoke.MethodType-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>bind</h4> <pre>public&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;bind(<a href="../../../java/lang/Object.html" title="class in java.lang">Object</a>&nbsp;receiver,
                         <a href="../../../java/lang/String.html" title="class in java.lang">String</a>&nbsp;name,
                         <a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke">MethodType</a>&nbsp;type)
                  throws <a href="../../../java/lang/NoSuchMethodException.html" title="class in java.lang">NoSuchMethodException</a>,
                         <a href="../../../java/lang/IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></pre> 
        <div class="block" data-fanyi="1">
          用于非静态方法的早期绑定方法句柄。接收器必须有一个父类 
         <code>defc</code>其中一个给定的名称和类型的方法来查找类可访问。该方法和它的所有参数类型必须是可访问的查找对象。该方法的类型的处理将是该方法，没有任何插入一个额外的接收器参数。给定的接收器将被绑定到方法处理中，因此，方法句柄的每一个调用都将在给定的接收器上调用请求的方法。 
         <p data-fanyi="1">返回的方法处理会有<a href="../../../java/lang/invoke/MethodHandle.html#asVarargsCollector-java.lang.Class-">variable arity</a>若方法的变量数量修改位（<code>0x0080</code>）是集和尾数组参数不是唯一的争论。（如果后面的数组参数是唯一的参数，给定的接收器值将被绑定到它。）</p> 
         <p data-fanyi="1">这相当于下面的代码：</p> 
         <blockquote> 
          <pre><code>
import static java.lang.invoke.MethodHandles.*;
import static java.lang.invoke.MethodType.*;
...
MethodHandle mh0 = lookup().findVirtual(defc, name, type);
MethodHandle mh1 = mh0.bindTo(receiver);
MethodType mt1 = mh1.type();
if (mh0.isVarargsCollector())
  mh1 = mh1.asVarargsCollector(mt1.parameterType(mt1.parameterCount()-1));
return mh1;
 </code></pre> 
         </blockquote>哪里 
         <code>defc</code>是 
         <code>receiver.getClass()</code>或超类型，类，其中请求的方法是查找类可访问。（注意， 
         <code>bindTo</code>不保留变量的情况。） 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>receiver</code> -对象的方法访问 
         </dd> 
         <dd data-fanyi="1"> 
          <code>name</code> -名称的方法 
         </dd> 
         <dd data-fanyi="1"> 
          <code>type</code> -方法的类型，与接收机参数省略 
         </dd> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           所需的方法处理 
         </dd> 
         <dt> 
          <span class="throwsLabel">异常</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/NoSuchMethodException.html" title="class in java.lang">NoSuchMethodException</a></code>如果方法不存在 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></code>如果访问检查失败或如果方法的变性剂位设置和 
          <code>asVarargsCollector</code>失败 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> -如果一个安全管理是目前这 
          <a href="MethodHandles.Lookup.html#secmgr">refuses access</a> 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> -如果任一参数为空 
         </dd> 
         <dt> 
          <span class="seeLabel">另请参见：</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <a href="../../../java/lang/invoke/MethodHandle.html#bindTo-java.lang.Object-"><code>MethodHandle.bindTo(java.lang.Object)</code></a>， 
          <a href="../../../java/lang/invoke/MethodHandles.Lookup.html#findVirtual-java.lang.Class-java.lang.String-java.lang.invoke.MethodType-"><code>findVirtual(java.lang.Class&lt;?&gt;, java.lang.String, java.lang.invoke.MethodType)</code></a> 
         </dd> 
        </dl> </li> 
      </ul> <a name="unreflect-java.lang.reflect.Method-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>unreflect</h4> <pre>public&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;unreflect(<a href="../../../java/lang/reflect/Method.html" title="class in java.lang.reflect">方法</a>&nbsp;m)
                       throws <a href="../../../java/lang/IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></pre> 
        <div class="block" data-fanyi="1">
          让 
         <a href="MethodHandleInfo.html#directmh">direct method handle</a>到nullm，如果查找类许可。如果nullm是非静态的，接收机参数作为初始参数。如果nullm是虚拟的，最重要的是尊重每一个电话。与核心反射接口不同，异常不被包裹。该方法处理的类型将是该方法与接收机类型值（但必须是非静态的）。如果没有设置方法的 
         <code>accessible</code>标志，访问检查立即执行，对查课代表。如果nullm不公开，不与不受信任的各方分享由此产生的处理。 
         <p data-fanyi="1">返回的方法处理会有<a href="../../../java/lang/invoke/MethodHandle.html#asVarargsCollector-java.lang.Class-">variable arity</a>若方法的变量数量修改位（<code>0x0080</code>）设置。</p> 
         <p data-fanyi="1">如果nullm是静态的，如果返回的处理方法被调用时，该方法的类将被初始化，如果它还没有被初始化。</p> 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>m</code> -反射法 
         </dd> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           一种可以调用反射方法的方法句柄 
         </dd> 
         <dt> 
          <span class="throwsLabel">异常</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></code>如果访问检查失败或如果方法的变性剂位设置和 
          <code>asVarargsCollector</code>失败 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> -如果参数为空 
         </dd> 
        </dl> </li> 
      </ul> <a name="unreflectSpecial-java.lang.reflect.Method-java.lang.Class-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>unreflectSpecial</h4> <pre>public&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;unreflectSpecial(<a href="../../../java/lang/reflect/Method.html" title="class in java.lang.reflect">方法</a>&nbsp;m,
                                     <a href="../../../java/lang/Class.html" title="class in java.lang">类</a>&lt;?&gt;&nbsp;specialCaller)
                              throws <a href="../../../java/lang/IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></pre> 
        <div class="block" data-fanyi="1">
          用于反射方法的方法处理。它将绕过检查重写方法的接收器， 
         <a href="MethodHandles.Lookup.html#equiv">as if called</a>从 
         <code>invokespecial</code>指令在明确指定 
         <code>specialCaller</code>。该方法处理的类型将是该方法与适当限制接收机类型前缀。（接收器类型将 
         <code>specialCaller</code>或亚型。）如果没有设置方法的 
         <code>accessible</code>标志，访问检查立即执行的查找类的代表，如果 
         <code>invokespecial</code>指令被链接。 
         <p data-fanyi="1">以前的方法解决，如果明确指定调用类是不相同的查找类，或者如果该查询对象没有<a href="MethodHandles.Lookup.html#privacc">private access</a>权限，访问失败。</p> 
         <p data-fanyi="1">返回的方法处理会有<a href="../../../java/lang/invoke/MethodHandle.html#asVarargsCollector-java.lang.Class-">variable arity</a>若方法的变量数量修改位（<code>0x0080</code>）设置。</p> 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>m</code> -反射法 
         </dd> 
         <dd data-fanyi="1"> 
          <code>specialCaller</code>名义上的类调用方法 
         </dd> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           一种可以调用反射方法的方法句柄 
         </dd> 
         <dt> 
          <span class="throwsLabel">异常</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></code>如果访问检查失败或如果方法的变性剂位设置和 
          <code>asVarargsCollector</code>失败 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> -如果任一参数为空 
         </dd> 
        </dl> </li> 
      </ul> <a name="unreflectConstructor-java.lang.reflect.Constructor-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>unreflectConstructor</h4> <pre>public&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;unreflectConstructor(<a href="../../../java/lang/reflect/Constructor.html" title="class in java.lang.reflect">Constructor</a>&lt;?&gt;&nbsp;c)
                                  throws <a href="../../../java/lang/IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></pre> 
        <div class="block" data-fanyi="1">
          为反射的构造函数生成方法句柄。方法句柄的类型将是构造函数的类型，返回类型更改为声明类。处理方法将执行 
         <code>newInstance</code>操作，创建传递给方法的参数处理的一个新的实例构造函数的类。 
         <p data-fanyi="1">如果没有设置构造函数的<code>accessible</code>标志，访问检查立即执行，对查课代表。</p> 
         <p data-fanyi="1">返回的方法处理会有<a href="../../../java/lang/invoke/MethodHandle.html#asVarargsCollector-java.lang.Class-">variable arity</a>如果构造函数的变量数量修改位（<code>0x0080</code>）设置。</p> 
         <p data-fanyi="1">如果调用返回的方法句柄，则构造函数的类将被初始化，如果它还没有被初始化。</p> 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>c</code> -反射的构造函数 
         </dd> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           可以调用反射构造函数的方法句柄 
         </dd> 
         <dt> 
          <span class="throwsLabel">异常</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></code>如果访问检查失败或如果方法的变性剂位设置和 
          <code>asVarargsCollector</code>失败 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> -如果参数为空 
         </dd> 
        </dl> </li> 
      </ul> <a name="unreflectGetter-java.lang.reflect.Field-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>unreflectGetter</h4> <pre>public&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;unreflectGetter(<a href="../../../java/lang/reflect/Field.html" title="class in java.lang.reflect">Field</a>&nbsp;f)
                             throws <a href="../../../java/lang/IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></pre> 
        <div class="block" data-fanyi="1">
          产生一个方法来处理对一个反射字段的读取访问。方法句柄的类型将有字段的值类型的返回类型。如果字段是静态的，方法句柄将不需要参数。否则，它的单个参数将是包含字段的实例。如果没有设置该字段的 
         <code>accessible</code>标志，访问检查立即执行，对查课代表。 
         <p data-fanyi="1">如果字段是静态的，如果调用返回的方法句柄，则字段的类将被初始化，如果它没有被初始化。</p> 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>f</code> -反射场 
         </dd> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           可以从反射字段加载值的方法句柄 
         </dd> 
         <dt> 
          <span class="throwsLabel">异常</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></code>如果访问检查失败 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> -如果参数为空 
         </dd> 
        </dl> </li> 
      </ul> <a name="unreflectSetter-java.lang.reflect.Field-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>unreflectSetter</h4> <pre>public&nbsp;<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;unreflectSetter(<a href="../../../java/lang/reflect/Field.html" title="class in java.lang.reflect">Field</a>&nbsp;f)
                             throws <a href="../../../java/lang/IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></pre> 
        <div class="block" data-fanyi="1">
          产生一个处理对一个反射字段的写访问的方法。方法句柄的类型将有一个无效的返回类型。如果字段是静态的，方法句柄将采取一个单一的参数，字段的值类型，存储的值。否则，这两个参数将是包含字段的实例，以及存储的值。如果没有设置该字段的 
         <code>accessible</code>标志，访问检查立即执行，对查课代表。 
         <p data-fanyi="1">如果字段是静态的，如果调用返回的方法句柄，则字段的类将被初始化，如果它没有被初始化。</p> 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>f</code> -反射场 
         </dd> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           可以将值存储到所反映字段的方法处理 
         </dd> 
         <dt> 
          <span class="throwsLabel">异常</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/IllegalAccessException.html" title="class in java.lang">IllegalAccessException</a></code>如果访问检查失败 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> -如果参数为空 
         </dd> 
        </dl> </li> 
      </ul> <a name="revealDirect-java.lang.invoke.MethodHandle-"> 
       <!--   --> </a> 
      <ul class="blockListLast"> 
       <li class="blockList"> <h4>revealDirect</h4> <pre>public&nbsp;<a href="../../../java/lang/invoke/MethodHandleInfo.html" title="interface in java.lang.invoke">MethodHandleInfo</a>&nbsp;revealDirect(<a href="../../../java/lang/invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target)</pre> 
        <div class="block" data-fanyi="1">
          裂纹 
         <a href="MethodHandleInfo.html#directmh">direct method handle</a>通过查找对象或类似的一个创造。执行安全性和访问检查以确保该查找对象能够再现目标方法句柄。这意味着，破解可能会失败，如果目标是一个直接的方法处理，但创建了一个不相关的查找对象。如果这可以处理方法是 
         <a href="MethodHandles.Lookup.html#callsens">caller sensitive</a>被不同的类查找对象创建的发生。 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>target</code> -一个直接的方法处理裂缝为符号参考组件 
         </dd> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           可以用于从该查找对象重建此方法句柄的符号引用 
         </dd> 
         <dt> 
          <span class="throwsLabel">异常</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/SecurityException.html" title="class in java.lang">SecurityException</a></code> -如果一个安全管理是目前这 
          <a href="MethodHandles.Lookup.html#secmgr">refuses access</a> 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> -如果目标不是一个直接的方法处理或者访问检查失败 
         </dd> 
         <dd data-fanyi="1">
           如果目标是 
          <code>null</code> 
          <code><a href="../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> 
         </dd> 
         <dt> 
          <span class="simpleTagLabel">从以下版本开始：</span> 
         </dt> 
         <dd data-fanyi="1">
           一点八 
         </dd> 
         <dt> 
          <span class="seeLabel">另请参见：</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <a href="../../../java/lang/invoke/MethodHandleInfo.html" title="interface in java.lang.invoke"><code>MethodHandleInfo</code></a> 
         </dd> 
        </dl> </li> 
      </ul> </li> 
    </ul> </li> 
  </ul> 
 </div> 
</div> 
<!-- ========= END OF CLASS DATA ========= --> 
<!-- ======= START OF BOTTOM NAVBAR ====== --> 
<div class="bottomNav"> 
 <a name="navbar.bottom"> 
  <!--   --> </a> 
 <div class="skipNav"> 
  <a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a> 
 </div> 
 <a name="navbar.bottom.firstrow"> 
  <!--   --> </a> 
 <ul class="navList" title="Navigation"> 
  <li><a href="../../../overview-summary.html">概述</a></li> 
  <li><a href="package-summary.html">软件包</a></li> 
  <li class="navBarCell1Rev">类</li> 
  <li><a href="class-use/MethodHandles.Lookup.html">使用</a></li> 
  <li><a href="package-tree.html">树</a></li> 
  <li><a href="../../../deprecated-list.html">已过时的</a></li> 
  <li><a href="../../../index-files/index-1.html">索引</a></li> 
  <li><a href="../../../help-doc.html">帮助</a></li> 
 </ul> 
 <div class="aboutLanguage"> 
  <strong>Java™&nbsp;Platform<br>Standard&nbsp;Ed.&nbsp;8</strong> 
 </div> 
</div> 
<div class="subNav"> 
 <ul class="navList"> 
  <li><a href="../../../java/lang/invoke/MethodHandles.html" title="class in java.lang.invoke"><span class="typeNameLink">上一个</span></a></li> 
  <li><a href="../../../java/lang/invoke/MethodType.html" title="class in java.lang.invoke"><span class="typeNameLink">下一个</span></a></li> 
 </ul> 
 <ul class="navList"> 
  <li><a href="../../../index.html?java/lang/invoke/MethodHandles.Lookup.html" target="_top">框架</a></li> 
  <li><a href="MethodHandles.Lookup.html" target="_top">无框架</a></li> 
 </ul> 
 <ul class="navList" id="allclasses_navbar_bottom"> 
  <li><a href="../../../allclasses-noframe.html">所有类</a></li> 
 </ul> 
 <div> 
  <script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script> 
 </div> 
 <div> 
  <ul class="subNavList"> 
   <li>概要：</li> 
   <li>嵌套</li> 
   <li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li> 
   <li>构造方法</li> 
   <li><a href="#method.summary">方法</a></li> 
  </ul> 
  <ul class="subNavList"> 
   <li>详细信息：</li> 
   <li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li> 
   <li>构造方法</li> 
   <li><a href="#method.detail">方法</a></li> 
  </ul> 
 </div> 
 <a name="skip.navbar.bottom"> 
  <!--   --> </a> 
</div> 
<!-- ======== END OF BOTTOM NAVBAR ======= --> 
<p class="legalCopy"><small><font size="-1"> <a href="http://bugreport.sun.com/bugreport/">Submit a bug or feature</a> <br>For further API reference and developer documentation, see <a href="http://download.oracle.com/javase/8/docs/index.html" target="_blank">Java SE Documentation</a>. That documentation contains more detailed, developer-targeted descriptions, with conceptual overviews, definitions of terms, workarounds, and working code examples.<br> Copyright © 1993, 2014, Oracle and/or its affiliates. All rights reserved. </font></small> </p> 
<div id="adDiv"> 


 <div></div> 
</div> 
<p></p>