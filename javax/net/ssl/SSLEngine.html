<!-- NewPage -->   
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<!-- Generated by javadoc (1.8.0) on Tue Mar 04 03:12:54 PST 2014 --> 
<title>SSLEngine (Java Platform SE 8 )</title> 
<meta name="date" content="2014-03-04"> 
<meta name="keywords" content="javax.net.ssl.SSLEngine class"> 
<meta name="keywords" content="getPeerHost()"> 
<meta name="keywords" content="getPeerPort()"> 
<meta name="keywords" content="wrap()"> 
<meta name="keywords" content="unwrap()"> 
<meta name="keywords" content="getDelegatedTask()"> 
<meta name="keywords" content="closeInbound()"> 
<meta name="keywords" content="isInboundDone()"> 
<meta name="keywords" content="closeOutbound()"> 
<meta name="keywords" content="isOutboundDone()"> 
<meta name="keywords" content="getSupportedCipherSuites()"> 
<meta name="keywords" content="getEnabledCipherSuites()"> 
<meta name="keywords" content="setEnabledCipherSuites()"> 
<meta name="keywords" content="getSupportedProtocols()"> 
<meta name="keywords" content="getEnabledProtocols()"> 
<meta name="keywords" content="setEnabledProtocols()"> 
<meta name="keywords" content="getSession()"> 
<meta name="keywords" content="getHandshakeSession()"> 
<meta name="keywords" content="beginHandshake()"> 
<meta name="keywords" content="getHandshakeStatus()"> 
<meta name="keywords" content="setUseClientMode()"> 
<meta name="keywords" content="getUseClientMode()"> 
<meta name="keywords" content="setNeedClientAuth()"> 
<meta name="keywords" content="getNeedClientAuth()"> 
<meta name="keywords" content="setWantClientAuth()"> 
<meta name="keywords" content="getWantClientAuth()"> 
<meta name="keywords" content="setEnableSessionCreation()"> 
<meta name="keywords" content="getEnableSessionCreation()"> 
<meta name="keywords" content="getSSLParameters()"> 
<meta name="keywords" content="setSSLParameters()"> 
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style"> 
<script type="text/javascript" src="../../../script.js"></script> 
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="SSLEngine (Java Platform SE 8 )";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":6,"i1":6,"i2":6,"i3":6,"i4":6,"i5":6,"i6":6,"i7":10,"i8":6,"i9":6,"i10":10,"i11":10,"i12":6,"i13":10,"i14":6,"i15":6,"i16":6,"i17":6,"i18":6,"i19":6,"i20":6,"i21":6,"i22":6,"i23":6,"i24":10,"i25":6,"i26":6,"i27":10,"i28":10,"i29":6,"i30":10,"i31":6,"i32":10};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],4:["t3","Abstract Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script> 
<noscript>
  &lt;div&gt; JavaScript is disabled on your browser. 
</noscript> 
<!-- ========= START OF TOP NAVBAR ======= -->   
<div class="topNav"> 
 <a name="navbar.top"> 
  <!--   --> </a> 
 <div class="skipNav"> 
  <a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a> 
 </div> 
 <a name="navbar.top.firstrow"> 
  <!--   --> </a> 
 <ul class="navList" title="Navigation"> 
  <li><a href="../../../overview-summary.html">概述</a></li> 
  <li><a href="package-summary.html">软件包</a></li> 
  <li class="navBarCell1Rev">类</li> 
  <li><a href="class-use/SSLEngine.html">使用</a></li> 
  <li><a href="package-tree.html">树</a></li> 
  <li><a href="../../../deprecated-list.html">已过时的</a></li> 
  <li><a href="../../../index-files/index-1.html">索引</a></li> 
  <li><a href="../../../help-doc.html">帮助</a></li> 
 </ul> 
 <div class="aboutLanguage"> 
  <strong>Java™&nbsp;Platform<br>Standard&nbsp;Ed.&nbsp;8</strong> 
 </div> 
</div> 
<div class="subNav"> 
 <ul class="navList"> 
  <li><a href="../../../javax/net/ssl/SSLContextSpi.html" title="class in javax.net.ssl"><span class="typeNameLink">上一个</span></a></li> 
  <li><a href="../../../javax/net/ssl/SSLEngineResult.html" title="class in javax.net.ssl"><span class="typeNameLink">下一个</span></a></li> 
 </ul> 
 <ul class="navList"> 
  <li><a href="../../../index.html?javax/net/ssl/SSLEngine.html" target="_top">框架</a></li> 
  <li><a href="SSLEngine.html" target="_top">无框架</a></li> 
 </ul> 
 <ul class="navList" id="allclasses_navbar_top"> 
  <li><a href="../../../allclasses-noframe.html">所有类</a></li> 
 </ul> 
 <div> 
  <script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script> 
 </div> 
 <div> 
  <ul class="subNavList"> 
   <li>概要：</li> 
   <li>嵌套</li> 
   <li>字段</li> 
   <li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li> 
   <li><a href="#method.summary">方法</a></li> 
  </ul> 
  <ul class="subNavList"> 
   <li>详细信息：</li> 
   <li>字段</li> 
   <li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li> 
   <li><a href="#method.detail">方法</a></li> 
  </ul> 
 </div> 
 <a name="skip.navbar.top"> 
  <!--   --> </a> 
</div> 
<!-- ========= END OF TOP NAVBAR ========= --> 
<!-- ======== START OF CLASS DATA ======== --> 
<div class="header"> 
 <div class="subTitle">
   compact1, compact2, compact3 
 </div> 
 <div class="subTitle">
   javax.net.ssl 
 </div> 
 <h2 title="Class SSLEngine" class="title">Class SSLEngine</h2> 
</div> 
<div class="contentContainer"> 
 <ul class="inheritance"> 
  <li><a href="../../../java/lang/Object.html" title="class in java.lang">java.lang.Object</a></li> 
  <li> 
   <ul class="inheritance"> 
    <li>javax.net.ssl.SSLEngine</li> 
   </ul> </li> 
 </ul> 
 <div class="description"> 
  <ul class="blockList"> 
   <li class="blockList"> 
    <hr> <br> <pre>public abstract class <span class="typeNameLabel">SSLEngine</span>
extends <a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></pre> 
    <div class="block" data-fanyi="1">
      一个类可以使用协议，如安全套接字层（SSL）安全通信或 
     <a href="http://www.ietf.org/rfc/rfc2246.txt"> IETF RFC 2246 "Transport Layer Security" (TLS) </a>协议，但运输独立。 
     <p data-fanyi="1">安全通信模式包括：</p> 
     <ul data-fanyi="1"> 
      <li data-fanyi="1">完整性保护。SSL / TLS保护修改消息由一个活跃的窃听器。</li> 
      <li data-fanyi="1">认证。在大多数模式，SSL / TLS提供对等的认证。服务器通常是经过身份验证的，而客户端可以通过服务器的请求进行身份验证。</li> 
      <li data-fanyi="1">保密（隐私保护）。在大多数模式，SSL / TLS加密的客户端和服务器之间发送的数据。这可以保护数据的机密性，所以被动窃听不会看到敏感数据，如财务信息、各种个人信息。</li> 
     </ul>这种保护是由一个“密码套件”的规定，这是一个由一个给定的SSL连接使用的加密算法。在协商过程中，两个端点必须在两个环境中可用的密码套件上达成一致。如果在一般没有这样的套房，没有SSL连接可以建立，也可以交换数据。 
     <p data-fanyi="1">使用的加密套件是建立了一种协商的过程称为“握手”。这个过程的目标是创建或加入一个“会话”，这可能会让许多连接时间。握手完成后，您可以通过使用<a href="../../../javax/net/ssl/SSLEngine.html#getSession--"><code>getSession()</code></a>方法访问会话属性。</p> 
     <p data-fanyi="1">的<code>SSLSocket</code>类提供了许多相同的安全功能，但所有的入站和出站数据自动传输使用基础<a href="../../../java/net/Socket.html" title="class in java.net"><code>Socket</code></a>，通过设计采用分块模型。虽然这是适当的许多应用程序，该模型不提供大型服务器所需的可扩展性。</p> 
     <p data-fanyi="1">一个<code>SSLEngine</code>的主要区别是它在入境和出境的字节流，独立的运输机制。是的<code>SSLEngine</code>用户责任安排可靠的I/O传输到对等。从I/O传输机制分离的SSL / TLS的<code>SSLEngine</code>抽象，可用于各种各样的I / O型，如<a href="../../../java/nio/channels/spi/AbstractSelectableChannel.html#configureBlocking-boolean-"><code>non-blocking I/O (polling)</code></a>，<a href="../../../java/nio/channels/Selector.html" title="class in java.nio.channels"><code>selectable non-blocking I/O</code></a>，<a href="../../../java/net/Socket.html" title="class in java.net"><code>Socket</code></a>和传统输入/ OutputStreams，当地<a href="../../../java/nio/ByteBuffer.html" title="class in java.nio"><code>ByteBuffers</code></a>或字节数组，<a href="http://www.jcp.org/en/jsr/detail?id=203"> future asynchronous I/O models </a>，等等。</p> 
     <p data-fanyi="1">在一个较高的水平，出现这样的<code>SSLEngine</code>：</p> 
     <pre data-fanyi="1">应用程序数据| ^| | |V | |+——+ ----- | ----- +——+| | || SSL |发动机|wrap() | | | unwrap()|出境入境| || | |+——+ ----- | ----- +——+| | ^| | |V |NET数据</pre>应用数据（也被称为明文或明文）是产生或消耗由一个应用程序的数据。其对应的是网络数据，其中包括无论是握手和/或密文（加密）的数据，并注定要通过I/O机制运。入站数据是已从对等体接收的数据，和出站数据是注定的对等体的。 
     <p data-fanyi="1">（在一个<code>SSLEngine</code>，语境下的“握手”数据是指任何数据交换的建立和控制一个安全连接。握手数据包括SSL / TLS消息“警报”，“change_cipher_spec，”和“握手”。）</p> 
     <p data-fanyi="1">有一个<code>SSLEngine</code>明显的五个阶段。</p> 
     <ol data-fanyi="1"> 
      <li data-fanyi="1">创作的<code>SSLEngine</code>已经创建并初始化，但尚未使用。在这个阶段，应用程序可以设置任何<code>SSLEngine</code>-specific设置（启用密码套件，是否<code>SSLEngine</code>应该在客户端或服务器模式、握手等）。一次握手开始，但是，任何新的设置（除了客户端/服务器模式，见下文）将用于下一次握手。</li> 
      <li data-fanyi="1">第一次握手的第一次握手是一个过程，通过这两个同行交换通信参数，直到sslsession建立。在这个阶段中不能发送应用程序数据。</li> 
      <li data-fanyi="1">应用数据一旦通信参数，并建立了握手完成后，通过<code>SSLEngine</code>可以应用数据。出站应用程序消息进行加密和完整性保护，并将入站消息反向过程。</li> 
      <li data-fanyi="1">rehandshaking两边可以要求重新协商会话的应用程序在任何时候数据阶段。新的握手数据可以混合应用程序之间的数据。在开始rehandshake阶段，应用程序可能会重置SSL / TLS通信参数，如启用密码套件列表和是否使用客户端身份验证，但不能客户端/服务器模式之间的变化。像以前一样，一次握手开始，任何新的<code>SSLEngine</code>配置设置将不会被使用到下一次握手。</li> 
      <li data-fanyi="1">关闭连接时不再需要，应用程序应该关闭<code>SSLEngine</code>应该发送/接收任何剩余的消息给同伴在底层传输机制关闭。当发动机关闭时，它是不可重用：一个新的<code>SSLEngine</code>必须创建。</li> 
     </ol>一 
     <code>SSLEngine</code>是由一个初始化的 
     <code>SSLContext</code>调用 
     <a href="../../../javax/net/ssl/SSLContext.html#createSSLEngine--"><code>SSLContext.createSSLEngine()</code></a>创建。任何配置参数被设置在 
     <code>wrap()</code>， 
     <code>unwrap()</code>制作的第一个电话，或 
     <code>beginHandshake()</code>。这些方法都触发初始握手。 
     <p data-fanyi="1">数据通过引擎通过调用<a href="../../../javax/net/ssl/SSLEngine.html#wrap-java.nio.ByteBuffer-java.nio.ByteBuffer-"><code>wrap()</code></a>或<a href="../../../javax/net/ssl/SSLEngine.html#unwrap-java.nio.ByteBuffer-java.nio.ByteBuffer-"><code>unwrap()</code></a>出境或入境数据，分别。根据不同的<code>SSLEngine</code>状态，一<code>wrap()</code>呼叫可以使用应用程序数据源和目标缓冲区缓冲区可能产生网络数据。出站数据可能包含应用程序和/或握手数据。一个叫<code>unwrap()</code>将检查源缓冲区和可能提前握手如果数据握手信息，或将应用程序数据在目的地缓冲如果数据中的应用。国家的底层SSL / TLS算法确定数据时，消费和生产。</p> 
     <p data-fanyi="1">电话<code>wrap()</code>和<code>unwrap()</code>返回一个<code>SSLEngineResult</code>显示操作的状态，和（可选的）如何与引擎交互进步。</p> 
     <p data-fanyi="1">的<code>SSLEngine</code>生产/消费的完整的SSL / TLS数据包，而不在内部调用之间<code>wrap()/unwrap()</code>存储应用程序数据。因此，输入和输出<code>ByteBuffer</code>s尺寸必须适当，可以产生的最大记录。电话<a href="../../../javax/net/ssl/SSLSession.html#getPacketBufferSize--"><code>SSLSession.getPacketBufferSize()</code></a>和<a href="../../../javax/net/ssl/SSLSession.html#getApplicationBufferSize--"><code>SSLSession.getApplicationBufferSize()</code></a>应该用来确定适当的缓冲区大小。出站应用程序数据缓冲区的大小一般不重要。如果缓冲区的条件不允许对数据的正确消费/生产，应用程序必须确定（通过<a href="../../../javax/net/ssl/SSLEngineResult.html" title="class in javax.net.ssl"><code>SSLEngineResult</code></a>）和纠正问题，然后尝试再次打电话。</p> 
     <p data-fanyi="1">例如，如果<code>unwrap()</code>发动机决定了没有足够的可用空间<a href="../../../javax/net/ssl/SSLEngineResult.Status.html#BUFFER_OVERFLOW"><code>SSLEngineResult.Status.BUFFER_OVERFLOW</code></a>目标缓冲区返回一个结果。应用程序应该调用<a href="../../../javax/net/ssl/SSLSession.html#getApplicationBufferSize--"><code>SSLSession.getApplicationBufferSize()</code></a>和比较值与目标缓冲区的可用空间，如果有必要扩大缓冲区。同样，如果<code>unwrap()</code>都返回一个<a href="../../../javax/net/ssl/SSLEngineResult.Status.html#BUFFER_UNDERFLOW"><code>SSLEngineResult.Status.BUFFER_UNDERFLOW</code></a>，应用程序应该调用<a href="../../../javax/net/ssl/SSLSession.html#getPacketBufferSize--"><code>SSLSession.getPacketBufferSize()</code></a>确保源缓冲区有足够的空间容纳一个记录（如果有必要的话，再扩大）获得更多的入站数据。</p> 
     <pre data-fanyi="1"><code>
   SSLEngineResult r = engine.unwrap(src, dst);
   switch (r.getStatus()) {
   BUFFER_OVERFLOW:
       // Could attempt to drain the dst buffer of any already obtained
       // data, but we'll just increase it to the size needed.
       int appSize = engine.getSession().getApplicationBufferSize();
       ByteBuffer b = ByteBuffer.allocate(appSize + dst.position());
       dst.flip();
       b.put(dst);
       dst = b;
       // retry the operation.
       break;
   BUFFER_UNDERFLOW:
       int netSize = engine.getSession().getPacketBufferSize();
       // Resize buffer if needed.
       if (netSize &gt; dst.capacity()) {
           ByteBuffer b = ByteBuffer.allocate(netSize);
           src.flip();
           b.put(src);
           src = b;
       }
       // Obtain more inbound network data for src,
       // then retry the operation.
       break;
   // other cases: CLOSED, OK.
   }
 </code></pre> 
     <p data-fanyi="1">不像<code>SSLSocket</code>，所有的方法都是非阻塞的sslengine。<code>SSLEngine</code>实现可能需要完成的任务，可以采取长时间的结果，甚至可能阻碍。例如，一个trustmanager可能需要连接到一个远程的证书验证服务，或keymanager可能需要提示用户确定要使用的证书作为客户端认证的一部分。此外，创建加密签名和验证它们可以是缓慢的，似乎是阻塞的。</p> 
     <p data-fanyi="1">这可能有潜在的<code>SSLEngine</code>块操作，将创建一个<a href="../../../java/lang/Runnable.html" title="interface in java.lang"><code>Runnable</code></a>委派的任务。当<code>SSLEngineResult</code>表明委托任务的结果是必要的，应用程序必须调用<a href="../../../javax/net/ssl/SSLEngine.html#getDelegatedTask--"><code>getDelegatedTask()</code></a>获得杰出的委派的任务并调用它的<a href="../../../java/lang/Runnable.html#run--"><code>run()</code></a>方法（可能使用一个不同的线程根据计算策略）。应用程序应该继续获得委派的任务，直到不存在，然后再试一次原始操作。</p> 
     <p data-fanyi="1">在通信会话结束时，应用程序应该正确关闭SSL / TLS链接。SSL / TLS协议关闭握手消息，这些消息要传达给同伴之前释放<code>SSLEngine</code>和底层传输机制关闭。一个亲密的可以由一个开始：一个sslexception，入站关闭握手消息，或一个封闭的方法。在所有的情况下，关闭握手消息由发动机产生的，和<code>wrap()</code>应反复直到产生<code>SSLEngineResult</code>的返回状态“封闭”，或<a href="../../../javax/net/ssl/SSLEngine.html#isOutboundDone--"><code>isOutboundDone()</code></a>返回true。所有获得的数据从<code>wrap()</code>方法应送交同行。</p> 
     <p data-fanyi="1"><a href="../../../javax/net/ssl/SSLEngine.html#closeOutbound--"><code>closeOutbound()</code></a>用于信号的引擎，应用程序不会发送任何数据。</p> 
     <p data-fanyi="1">一个对等体将通过发送自己关闭的握手消息来表示其关闭的意图。该消息后已收到并由当地<code>SSLEngine</code>的<code>unwrap()</code>呼叫处理，应用程序可以通过调用<code>unwrap()</code>和寻找一个<code>SSLEngineResult</code>状态为“关闭”检测关闭，或者如果<a href="../../../javax/net/ssl/SSLEngine.html#isInboundDone--"><code>isInboundDone()</code></a>返回true。如果由于某种原因，同行关闭通信链路没有发送正确的SSL / TLS关闭消息，应用程序可以检测流端和信号通过<a href="../../../javax/net/ssl/SSLEngine.html#closeInbound--"><code>closeInbound()</code></a>发动机，将没有更多的入站消息的处理。一些应用程序可能会选择需要一个对等的有序关闭消息，在这种情况下，他们可以检查关闭是由一个握手消息产生，而不是由流条件的结束。</p> 
     <p data-fanyi="1">有两组密码套件，你需要知道什么时候管理密码套件：</p> 
     <ul data-fanyi="1"> 
      <li data-fanyi="1">支持密码套件：所有的套房酒店都是由SSL实现支持。这个列表是使用<a href="../../../javax/net/ssl/SSLEngine.html#getSupportedCipherSuites--"><code>getSupportedCipherSuites()</code></a>。</li> 
      <li data-fanyi="1">启用的密码套件，它可能比全套支持的套房少。本组采用<a href="../../../javax/net/ssl/SSLEngine.html#setEnabledCipherSuites-java.lang.String:A-"><code>setEnabledCipherSuites(String [])</code></a>方法，并利用<a href="../../../javax/net/ssl/SSLEngine.html#getEnabledCipherSuites--"><code>getEnabledCipherSuites()</code></a>方法查询。最初，一个默认的密码组设置将启用一个新的引擎，表示最低建议配置。</li> 
     </ul>实施违约要求只有密码套件认证服务器和提供保密性被默认启用。只有双方明确同意认证和/或非私人（未加密）通信将这样的密码套件选择。 
     <p data-fanyi="1">每个SSL / TLS连接必须有一个客户端和一个服务器，因此每个端点必须决定哪些角色承担。这个选择决定谁开始的握手过程以及哪些类型的消息应该由每一方发送。方法<a href="../../../javax/net/ssl/SSLEngine.html#setUseClientMode-boolean-"><code>setUseClientMode(boolean)</code></a>配置模式。一旦最初的握手开始，一个<code>SSLEngine</code>不能客户端和服务器模式之间切换，即便进行重新谈判。</p> 
     <p data-fanyi="1">应用程序可能选择在不同线程中处理委派的任务。当一个<code>SSLEngine</code>创建，保存当前<a href="../../../java/security/AccessControlContext.html" title="class in java.security"><code>AccessControlContext</code></a>。所有未来的委派任务将使用这种情况下处理：即，所有的访问控制决策将使用在引擎创建捕获的上下文。</p> 
     <hr data-fanyi="1"> 
     <b data-fanyi="1">并发的笔记</b>：有意识到两并发问题： 
     <ol data-fanyi="1"> 
      <li data-fanyi="1">的<code>wrap()</code>和<code>unwrap()</code>方法可以并发执行的彼此。</li> 
      <li data-fanyi="1">SSL / TLS协议采用命令包。应用程序必须小心，以确保生成的数据包在序列中被传递。如果数据包到达的顺序，意想不到的或致命的结果可能会发生。<p data-fanyi="1">例如:</p><pre data-fanyi="1">同步（outboundlock）{sslengine。包（src，dst）；outboundqueue放（DST）；}</pre>作为一个推论，两个线程不能尝试调用相同的方法（无论是<code>wrap()</code>或<code>unwrap()</code>）同时，因为没有办法保证最终的分组排序。</li> 
     </ol> 
    </div> 
    <dl> 
     <dt> 
      <span class="simpleTagLabel">从以下版本开始：</span> 
     </dt> 
     <dd data-fanyi="1">
       一点五 
     </dd> 
     <dt> 
      <span class="seeLabel">另请参见：</span> 
     </dt> 
     <dd data-fanyi="1"> 
      <a href="../../../javax/net/ssl/SSLContext.html" title="class in javax.net.ssl"><code>SSLContext</code></a>， 
      <a href="../../../javax/net/ssl/SSLSocket.html" title="class in javax.net.ssl"><code>SSLSocket</code></a>， 
      <a href="../../../javax/net/ssl/SSLServerSocket.html" title="class in javax.net.ssl"><code>SSLServerSocket</code></a>， 
      <a href="../../../javax/net/ssl/SSLSession.html" title="interface in javax.net.ssl"><code>SSLSession</code></a>， 
      <a href="../../../java/net/Socket.html" title="class in java.net"><code>Socket</code></a> 
     </dd> 
    </dl> </li> 
  </ul> 
 </div> 
 <div class="summary"> 
  <ul class="blockList"> 
   <li class="blockList"> 
    <!-- ======== CONSTRUCTOR SUMMARY ======== --> 
    <ul class="blockList"> 
     <li class="blockList"><a name="constructor.summary"> 
       <!--   --> </a> <h3>构造方法摘要</h3> 
      <table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation"> 
       <caption> 
        <span>构造方法</span> 
        <span class="tabEnd">&nbsp;</span> 
       </caption> 
       <tbody> 
        <tr> 
         <th class="colFirst" scope="col">Modifier</th> 
         <th class="colLast" scope="col">Constructor and Description</th> 
        </tr> 
        <tr class="altColor"> 
         <td class="colFirst"><code>protected </code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/net/ssl/SSLEngine.html#SSLEngine--">SSLEngine</a></span>()</code> 
          <div class="block" data-fanyi="1">
            一个 
           <code>SSLEngine</code>用于内部会话重用策略提供任何暗示的构造函数。 
          </div> </td> 
        </tr> 
        <tr class="rowColor"> 
         <td class="colFirst"><code>protected </code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/net/ssl/SSLEngine.html#SSLEngine-java.lang.String-int-">SSLEngine</a></span>(<a href="../../../java/lang/String.html" title="class in java.lang">String</a>&nbsp;peerHost, int&nbsp;peerPort)</code> 
          <div class="block" data-fanyi="1">
            一个 
           <code>SSLEngine</code>构造函数。 
          </div> </td> 
        </tr> 
       </tbody> 
      </table> </li> 
    </ul> 
    <!-- ========== METHOD SUMMARY =========== --> 
    <ul class="blockList"> 
     <li class="blockList"><a name="method.summary"> 
       <!--   --> </a> <h3>方法摘要</h3> 
      <table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation"> 
       <caption> 
        <span id="t0" class="activeTableTab"><span>所有方法</span><span class="tabEnd">&nbsp;</span></span> 
        <span id="t2" class="tableTab"><span><a href="javascript:show(2);">接口方法</a></span><span class="tabEnd">&nbsp;</span></span> 
        <span id="t3" class="tableTab"><span><a href="javascript:show(4);">抽象方法</a></span><span class="tabEnd">&nbsp;</span></span> 
        <span id="t4" class="tableTab"><span><a href="javascript:show(8);">具体的方法</a></span><span class="tabEnd">&nbsp;</span></span> 
       </caption> 
       <tbody> 
        <tr> 
         <th class="colFirst" scope="col">Modifier and Type</th> 
         <th class="colLast" scope="col">Method and Description</th> 
        </tr> 
        <tr id="i0" class="altColor"> 
         <td class="colFirst"><code>abstract void</code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/net/ssl/SSLEngine.html#beginHandshake--">beginHandshake</a></span>()</code> 
          <div class="block" data-fanyi="1">
            发起握手（初始或重新谈判，这sslengine）。 
          </div> </td> 
        </tr> 
        <tr id="i1" class="rowColor"> 
         <td class="colFirst"><code>abstract void</code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/net/ssl/SSLEngine.html#closeInbound--">closeInbound</a></span>()</code> 
          <div class="block" data-fanyi="1">
            信号，没有更多的入站网络将数据发送到这个 
           <code>SSLEngine</code>。 
          </div> </td> 
        </tr> 
        <tr id="i2" class="altColor"> 
         <td class="colFirst"><code>abstract void</code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/net/ssl/SSLEngine.html#closeOutbound--">closeOutbound</a></span>()</code> 
          <div class="block" data-fanyi="1">
            信号不再出境申请资料将被送到这 
           <code>SSLEngine</code>。 
          </div> </td> 
        </tr> 
        <tr id="i3" class="rowColor"> 
         <td class="colFirst"><code>abstract <a href="../../../java/lang/Runnable.html" title="interface in java.lang">Runnable</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/net/ssl/SSLEngine.html#getDelegatedTask--">getDelegatedTask</a></span>()</code> 
          <div class="block" data-fanyi="1">
            返回一个授权 
           <code>Runnable</code>任务这 
           <code>SSLEngine</code>。 
          </div> </td> 
        </tr> 
        <tr id="i4" class="altColor"> 
         <td class="colFirst"><code>abstract <a href="../../../java/lang/String.html" title="class in java.lang">String</a>[]</code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/net/ssl/SSLEngine.html#getEnabledCipherSuites--">getEnabledCipherSuites</a></span>()</code> 
          <div class="block" data-fanyi="1">
            返回正在使用的这台发动机启用SSL加密套件名称。 
          </div> </td> 
        </tr> 
        <tr id="i5" class="rowColor"> 
         <td class="colFirst"><code>abstract <a href="../../../java/lang/String.html" title="class in java.lang">String</a>[]</code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/net/ssl/SSLEngine.html#getEnabledProtocols--">getEnabledProtocols</a></span>()</code> 
          <div class="block" data-fanyi="1">
            返回正在使用这 
           <code>SSLEngine</code>协议版本的名字。 
          </div> </td> 
        </tr> 
        <tr id="i6" class="altColor"> 
         <td class="colFirst"><code>abstract boolean</code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/net/ssl/SSLEngine.html#getEnableSessionCreation--">getEnableSessionCreation</a></span>()</code> 
          <div class="block" data-fanyi="1">
            如果新的SSL会话可以通过这个引擎建立返回true。 
          </div> </td> 
        </tr> 
        <tr id="i7" class="rowColor"> 
         <td class="colFirst"><code><a href="../../../javax/net/ssl/SSLSession.html" title="interface in javax.net.ssl">SSLSession</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/net/ssl/SSLEngine.html#getHandshakeSession--">getHandshakeSession</a></span>()</code> 
          <div class="block" data-fanyi="1">
            返回 
           <code>SSLSession</code>是SSL / TLS握手期间建造的。 
          </div> </td> 
        </tr> 
        <tr id="i8" class="altColor"> 
         <td class="colFirst"><code>abstract <a href="../../../javax/net/ssl/SSLEngineResult.HandshakeStatus.html" title="enum in javax.net.ssl">SSLEngineResult.HandshakeStatus</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/net/ssl/SSLEngine.html#getHandshakeStatus--">getHandshakeStatus</a></span>()</code> 
          <div class="block" data-fanyi="1">
            返回当前的这一现状 
           <code>SSLEngine</code>握手。 
          </div> </td> 
        </tr> 
        <tr id="i9" class="rowColor"> 
         <td class="colFirst"><code>abstract boolean</code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/net/ssl/SSLEngine.html#getNeedClientAuth--">getNeedClientAuth</a></span>()</code> 
          <div class="block" data-fanyi="1">
            如果发动机将要求客户端认证返回true。 
          </div> </td> 
        </tr> 
        <tr id="i10" class="altColor"> 
         <td class="colFirst"><code><a href="../../../java/lang/String.html" title="class in java.lang">String</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/net/ssl/SSLEngine.html#getPeerHost--">getPeerHost</a></span>()</code> 
          <div class="block" data-fanyi="1">
            返回对等体的主机名。 
          </div> </td> 
        </tr> 
        <tr id="i11" class="rowColor"> 
         <td class="colFirst"><code>int</code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/net/ssl/SSLEngine.html#getPeerPort--">getPeerPort</a></span>()</code> 
          <div class="block" data-fanyi="1">
            返回对等体的端口号。 
          </div> </td> 
        </tr> 
        <tr id="i12" class="altColor"> 
         <td class="colFirst"><code>abstract <a href="../../../javax/net/ssl/SSLSession.html" title="interface in javax.net.ssl">SSLSession</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/net/ssl/SSLEngine.html#getSession--">getSession</a></span>()</code> 
          <div class="block" data-fanyi="1">
            在这 
           <code>SSLEngine</code>返回使用的 
           <code>SSLSession</code>。 
          </div> </td> 
        </tr> 
        <tr id="i13" class="rowColor"> 
         <td class="colFirst"><code><a href="../../../javax/net/ssl/SSLParameters.html" title="class in javax.net.ssl">SSLParameters</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/net/ssl/SSLEngine.html#getSSLParameters--">getSSLParameters</a></span>()</code> 
          <div class="block" data-fanyi="1">
            返回此sslengine效果sslparameters。 
          </div> </td> 
        </tr> 
        <tr id="i14" class="altColor"> 
         <td class="colFirst"><code>abstract <a href="../../../java/lang/String.html" title="class in java.lang">String</a>[]</code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/net/ssl/SSLEngine.html#getSupportedCipherSuites--">getSupportedCipherSuites</a></span>()</code> 
          <div class="block" data-fanyi="1">
            返回可在该引擎上启用的密码套件的名称。 
          </div> </td> 
        </tr> 
        <tr id="i15" class="rowColor"> 
         <td class="colFirst"><code>abstract <a href="../../../java/lang/String.html" title="class in java.lang">String</a>[]</code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/net/ssl/SSLEngine.html#getSupportedProtocols--">getSupportedProtocols</a></span>()</code> 
          <div class="block" data-fanyi="1">
            返回该协议可以使用这些 
           <code>SSLEngine</code>的名字。 
          </div> </td> 
        </tr> 
        <tr id="i16" class="altColor"> 
         <td class="colFirst"><code>abstract boolean</code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/net/ssl/SSLEngine.html#getUseClientMode--">getUseClientMode</a></span>()</code> 
          <div class="block" data-fanyi="1">
            如果发动机将使用客户端模式握手时返回真。 
          </div> </td> 
        </tr> 
        <tr id="i17" class="rowColor"> 
         <td class="colFirst"><code>abstract boolean</code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/net/ssl/SSLEngine.html#getWantClientAuth--">getWantClientAuth</a></span>()</code> 
          <div class="block" data-fanyi="1">
            如果发动机将请求客户端认证返回true。 
          </div> </td> 
        </tr> 
        <tr id="i18" class="altColor"> 
         <td class="colFirst"><code>abstract boolean</code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/net/ssl/SSLEngine.html#isInboundDone--">isInboundDone</a></span>()</code> 
          <div class="block" data-fanyi="1">
            返回是否 
           <a href="../../../javax/net/ssl/SSLEngine.html#unwrap-java.nio.ByteBuffer-java.nio.ByteBuffer-"><code>unwrap(ByteBuffer, ByteBuffer)</code></a>将接受任何入站数据信息。 
          </div> </td> 
        </tr> 
        <tr id="i19" class="rowColor"> 
         <td class="colFirst"><code>abstract boolean</code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/net/ssl/SSLEngine.html#isOutboundDone--">isOutboundDone</a></span>()</code> 
          <div class="block" data-fanyi="1">
            返回是否会产生更多的 
           <a href="../../../javax/net/ssl/SSLEngine.html#wrap-java.nio.ByteBuffer-java.nio.ByteBuffer-"><code>wrap(ByteBuffer, ByteBuffer)</code></a>出境数据信息。 
          </div> </td> 
        </tr> 
        <tr id="i20" class="altColor"> 
         <td class="colFirst"><code>abstract void</code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/net/ssl/SSLEngine.html#setEnabledCipherSuites-java.lang.String:A-">setEnabledCipherSuites</a></span>(<a href="../../../java/lang/String.html" title="class in java.lang">String</a>[]&nbsp;suites)</code> 
          <div class="block" data-fanyi="1">
            设置启用此引擎上使用的密码套件。 
          </div> </td> 
        </tr> 
        <tr id="i21" class="rowColor"> 
         <td class="colFirst"><code>abstract void</code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/net/ssl/SSLEngine.html#setEnabledProtocols-java.lang.String:A-">setEnabledProtocols</a></span>(<a href="../../../java/lang/String.html" title="class in java.lang">String</a>[]&nbsp;protocols)</code> 
          <div class="block" data-fanyi="1">
            设置启用此引擎上使用的协议版本。 
          </div> </td> 
        </tr> 
        <tr id="i22" class="altColor"> 
         <td class="colFirst"><code>abstract void</code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/net/ssl/SSLEngine.html#setEnableSessionCreation-boolean-">setEnableSessionCreation</a></span>(boolean&nbsp;flag)</code> 
          <div class="block" data-fanyi="1">
            新的SSL会话控制是否可以通过该引擎的建立。 
          </div> </td> 
        </tr> 
        <tr id="i23" class="rowColor"> 
         <td class="colFirst"><code>abstract void</code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/net/ssl/SSLEngine.html#setNeedClientAuth-boolean-">setNeedClientAuth</a></span>(boolean&nbsp;need)</code> 
          <div class="block" data-fanyi="1">
            配置引擎要求客户端认证。 
          </div> </td> 
        </tr> 
        <tr id="i24" class="altColor"> 
         <td class="colFirst"><code>void</code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/net/ssl/SSLEngine.html#setSSLParameters-javax.net.ssl.SSLParameters-">setSSLParameters</a></span>(<a href="../../../javax/net/ssl/SSLParameters.html" title="class in javax.net.ssl">SSLParameters</a>&nbsp;params)</code> 
          <div class="block" data-fanyi="1">
            适用于sslparameters这个引擎。 
          </div> </td> 
        </tr> 
        <tr id="i25" class="rowColor"> 
         <td class="colFirst"><code>abstract void</code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/net/ssl/SSLEngine.html#setUseClientMode-boolean-">setUseClientMode</a></span>(boolean&nbsp;mode)</code> 
          <div class="block" data-fanyi="1">
            配置引擎使用客户端（或服务器）模式时，握手。 
          </div> </td> 
        </tr> 
        <tr id="i26" class="altColor"> 
         <td class="colFirst"><code>abstract void</code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/net/ssl/SSLEngine.html#setWantClientAuth-boolean-">setWantClientAuth</a></span>(boolean&nbsp;want)</code> 
          <div class="block" data-fanyi="1">
            配置引擎请求客户端认证。 
          </div> </td> 
        </tr> 
        <tr id="i27" class="rowColor"> 
         <td class="colFirst"><code><a href="../../../javax/net/ssl/SSLEngineResult.html" title="class in javax.net.ssl">SSLEngineResult</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/net/ssl/SSLEngine.html#unwrap-java.nio.ByteBuffer-java.nio.ByteBuffer-">unwrap</a></span>(<a href="../../../java/nio/ByteBuffer.html" title="class in java.nio">ByteBuffer</a>&nbsp;src, <a href="../../../java/nio/ByteBuffer.html" title="class in java.nio">ByteBuffer</a>&nbsp;dst)</code> 
          <div class="block" data-fanyi="1">
            试图破解SSL / TLS网络数据转换成明文数据的缓冲区的应用。 
          </div> </td> 
        </tr> 
        <tr id="i28" class="altColor"> 
         <td class="colFirst"><code><a href="../../../javax/net/ssl/SSLEngineResult.html" title="class in javax.net.ssl">SSLEngineResult</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/net/ssl/SSLEngine.html#unwrap-java.nio.ByteBuffer-java.nio.ByteBuffer:A-">unwrap</a></span>(<a href="../../../java/nio/ByteBuffer.html" title="class in java.nio">ByteBuffer</a>&nbsp;src, <a href="../../../java/nio/ByteBuffer.html" title="class in java.nio">ByteBuffer</a>[]&nbsp;dsts)</code> 
          <div class="block" data-fanyi="1">
            试图破解SSL / TLS网络数据序列变成一个明文应用数据缓冲区。 
          </div> </td> 
        </tr> 
        <tr id="i29" class="rowColor"> 
         <td class="colFirst"><code>abstract <a href="../../../javax/net/ssl/SSLEngineResult.html" title="class in javax.net.ssl">SSLEngineResult</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/net/ssl/SSLEngine.html#unwrap-java.nio.ByteBuffer-java.nio.ByteBuffer:A-int-int-">unwrap</a></span>(<a href="../../../java/nio/ByteBuffer.html" title="class in java.nio">ByteBuffer</a>&nbsp;src, <a href="../../../java/nio/ByteBuffer.html" title="class in java.nio">ByteBuffer</a>[]&nbsp;dsts, int&nbsp;offset, int&nbsp;length)</code> 
          <div class="block" data-fanyi="1">
            试图破解SSL / TLS网络数据转换成一个序列的明文数据缓冲区中的应用。 
          </div> </td> 
        </tr> 
        <tr id="i30" class="altColor"> 
         <td class="colFirst"><code><a href="../../../javax/net/ssl/SSLEngineResult.html" title="class in javax.net.ssl">SSLEngineResult</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/net/ssl/SSLEngine.html#wrap-java.nio.ByteBuffer:A-java.nio.ByteBuffer-">wrap</a></span>(<a href="../../../java/nio/ByteBuffer.html" title="class in java.nio">ByteBuffer</a>[]&nbsp;srcs, <a href="../../../java/nio/ByteBuffer.html" title="class in java.nio">ByteBuffer</a>&nbsp;dst)</code> 
          <div class="block" data-fanyi="1">
            试图将明文字节序列中数据缓冲区的SSL / TLS网络数据。 
          </div> </td> 
        </tr> 
        <tr id="i31" class="rowColor"> 
         <td class="colFirst"><code>abstract <a href="../../../javax/net/ssl/SSLEngineResult.html" title="class in javax.net.ssl">SSLEngineResult</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/net/ssl/SSLEngine.html#wrap-java.nio.ByteBuffer:A-int-int-java.nio.ByteBuffer-">wrap</a></span>(<a href="../../../java/nio/ByteBuffer.html" title="class in java.nio">ByteBuffer</a>[]&nbsp;srcs, int&nbsp;offset, int&nbsp;length, <a href="../../../java/nio/ByteBuffer.html" title="class in java.nio">ByteBuffer</a>&nbsp;dst)</code> 
          <div class="block" data-fanyi="1">
            试图将明文字节从序列数据缓冲区的SSL / TLS网络数据。 
          </div> </td> 
        </tr> 
        <tr id="i32" class="altColor"> 
         <td class="colFirst"><code><a href="../../../javax/net/ssl/SSLEngineResult.html" title="class in javax.net.ssl">SSLEngineResult</a></code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/net/ssl/SSLEngine.html#wrap-java.nio.ByteBuffer-java.nio.ByteBuffer-">wrap</a></span>(<a href="../../../java/nio/ByteBuffer.html" title="class in java.nio">ByteBuffer</a>&nbsp;src, <a href="../../../java/nio/ByteBuffer.html" title="class in java.nio">ByteBuffer</a>&nbsp;dst)</code> 
          <div class="block" data-fanyi="1">
            试图编码缓冲区应用数据的明文为SSL / TLS网络数据。 
          </div> </td> 
        </tr> 
       </tbody> 
      </table> 
      <ul class="blockList"> 
       <li class="blockList"><a name="methods.inherited.from.class.java.lang.Object"> 
         <!--   --> </a> <h3>Methods inherited from class&nbsp;java.lang.<a href="../../../java/lang/Object.html" title="class in java.lang">Object</a></h3> <code><a href="../../../java/lang/Object.html#clone--">clone</a>, <a href="../../../java/lang/Object.html#equals-java.lang.Object-">equals</a>, <a href="../../../java/lang/Object.html#finalize--">finalize</a>, <a href="../../../java/lang/Object.html#getClass--">getClass</a>, <a href="../../../java/lang/Object.html#hashCode--">hashCode</a>, <a href="../../../java/lang/Object.html#notify--">notify</a>, <a href="../../../java/lang/Object.html#notifyAll--">notifyAll</a>, <a href="../../../java/lang/Object.html#toString--">toString</a>, <a href="../../../java/lang/Object.html#wait--">wait</a>, <a href="../../../java/lang/Object.html#wait-long-">wait</a>, <a href="../../../java/lang/Object.html#wait-long-int-">wait</a></code></li> 
      </ul> </li> 
    </ul> </li> 
  </ul> 
 </div> 
 <div class="details"> 
  <ul class="blockList"> 
   <li class="blockList"> 
    <!-- ========= CONSTRUCTOR DETAIL ======== --> 
    <ul class="blockList"> 
     <li class="blockList"><a name="constructor.detail"> 
       <!--   --> </a> <h3>Constructor Detail</h3> <a name="SSLEngine--"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>SSLEngine</h4> <pre>protected&nbsp;SSLEngine()</pre> 
        <div class="block" data-fanyi="1">
          一个 
         <code>SSLEngine</code>用于内部会话重用策略提供任何暗示的构造函数。 
        </div> 
        <dl> 
         <dt> 
          <span class="seeLabel">另请参见：</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <a href="../../../javax/net/ssl/SSLContext.html#createSSLEngine--"><code>SSLContext.createSSLEngine()</code></a>， 
          <a href="../../../javax/net/ssl/SSLSessionContext.html" title="interface in javax.net.ssl"><code>SSLSessionContext</code></a> 
         </dd> 
        </dl> </li> 
      </ul> <a name="SSLEngine-java.lang.String-int-"> 
       <!--   --> </a> 
      <ul class="blockListLast"> 
       <li class="blockList"> <h4>SSLEngine</h4> <pre>protected&nbsp;SSLEngine(<a href="../../../java/lang/String.html" title="class in java.lang">String</a>&nbsp;peerHost,
                    int&nbsp;peerPort)</pre> 
        <div class="block" data-fanyi="1">
          一个 
         <code>SSLEngine</code> 
         <p data-fanyi="1"><code>SSLEngine</code>实现可以使用<code>peerHost</code>和<code>peerPort</code>参数作为其内部会话重用策略提示。</p> 
         <p data-fanyi="1">一些密码套件（如Kerberos）需要远程主机信息。这个类的实现应该使用此构造函数使用Kerberos。</p> 
         <p data-fanyi="1">参数不是由<code>SSLEngine</code>认证。</p>构造函数。 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>peerHost</code> -对等主机的名称 
         </dd> 
         <dd data-fanyi="1"> 
          <code>peerPort</code> -同行的端口号 
         </dd> 
         <dt> 
          <span class="seeLabel">另请参见：</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <a href="../../../javax/net/ssl/SSLContext.html#createSSLEngine-java.lang.String-int-"><code>SSLContext.createSSLEngine(String, int)</code></a>， 
          <a href="../../../javax/net/ssl/SSLSessionContext.html" title="interface in javax.net.ssl"><code>SSLSessionContext</code></a> 
         </dd> 
        </dl> </li> 
      </ul> </li> 
    </ul> 
    <!-- ============ METHOD DETAIL ========== --> 
    <ul class="blockList"> 
     <li class="blockList"><a name="method.detail"> 
       <!--   --> </a> <h3>方法详细信息</h3> <a name="getPeerHost--"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>getPeerHost</h4> <pre>public&nbsp;<a href="../../../java/lang/String.html" title="class in java.lang">String</a>&nbsp;getPeerHost()</pre> 
        <div class="block" data-fanyi="1">
          返回对等体的主机名。 
         <p data-fanyi="1">请注意，该值没有被验证，不应该依赖。</p> 
        </div> 
        <dl> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           节点的主机名，或空，如果没有可用的。 
         </dd> 
        </dl> </li> 
      </ul> <a name="getPeerPort--"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>getPeerPort</h4> <pre>public&nbsp;int&nbsp;getPeerPort()</pre> 
        <div class="block" data-fanyi="1">
          返回对等体的端口号。 
         <p data-fanyi="1">请注意，该值没有被验证，不应该依赖。</p> 
        </div> 
        <dl> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           如果没有可用的端口号，对等点的端口号或- 1。 
         </dd> 
        </dl> </li> 
      </ul> <a name="wrap-java.nio.ByteBuffer-java.nio.ByteBuffer-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>wrap</h4> <pre>public&nbsp;<a href="../../../javax/net/ssl/SSLEngineResult.html" title="class in javax.net.ssl">SSLEngineResult</a>&nbsp;wrap(<a href="../../../java/nio/ByteBuffer.html" title="class in java.nio">ByteBuffer</a>&nbsp;src,
                            <a href="../../../java/nio/ByteBuffer.html" title="class in java.nio">ByteBuffer</a>&nbsp;dst)
                     throws <a href="../../../javax/net/ssl/SSLException.html" title="class in javax.net.ssl">SSLException</a></pre> 
        <div class="block" data-fanyi="1">
          试图编码缓冲区应用数据的明文为SSL / TLS网络数据。 
         <p data-fanyi="1">此方法的调用与调用的方式完全相同的行为：</p> 
         <blockquote> 
          <pre>
 <a href="../../../javax/net/ssl/SSLEngine.html#wrap-java.nio.ByteBuffer:A-int-int-java.nio.ByteBuffer-"><code>engine.wrap(new ByteBuffer [] { src }, 0, 1, dst);</code></a>
 </pre> 
         </blockquote> 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>src</code> - 
          <code>ByteBuffer</code>含出境申请资料 
         </dd> 
         <dd data-fanyi="1"> 
          <code>dst</code> - 
          <code>ByteBuffer</code>持有境外网络数据 
         </dd> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           一个 
          <code>SSLEngineResult</code>描述此操作的结果。 
         </dd> 
         <dt> 
          <span class="throwsLabel">异常</span> 
         </dt> 
         <dd data-fanyi="1">
           而造成 
          <code>SSLEngine</code>中止数据处理中遇到的一个问题 
          <code><a href="../../../javax/net/ssl/SSLException.html" title="class in javax.net.ssl">SSLException</a></code>。看到关于引擎关闭的更多信息的类描述。 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/nio/ReadOnlyBufferException.html" title="class in java.nio">ReadOnlyBufferException</a></code> -如果 
          <code>dst</code>缓冲区是只读的。 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> -如果 
          <code>src</code>或 
          <code>dst</code>是空的。 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/IllegalStateException.html" title="class in java.lang">IllegalStateException</a></code>如果客户端/服务器模式尚未确定。 
         </dd> 
         <dt> 
          <span class="seeLabel">另请参见：</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <a href="../../../javax/net/ssl/SSLEngine.html#wrap-java.nio.ByteBuffer:A-int-int-java.nio.ByteBuffer-"><code>wrap(ByteBuffer [], int, int, ByteBuffer)</code></a> 
         </dd> 
        </dl> </li> 
      </ul> <a name="wrap-java.nio.ByteBuffer:A-java.nio.ByteBuffer-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>wrap</h4> <pre>public&nbsp;<a href="../../../javax/net/ssl/SSLEngineResult.html" title="class in javax.net.ssl">SSLEngineResult</a>&nbsp;wrap(<a href="../../../java/nio/ByteBuffer.html" title="class in java.nio">ByteBuffer</a>[]&nbsp;srcs,
                            <a href="../../../java/nio/ByteBuffer.html" title="class in java.nio">ByteBuffer</a>&nbsp;dst)
                     throws <a href="../../../javax/net/ssl/SSLException.html" title="class in javax.net.ssl">SSLException</a></pre> 
        <div class="block" data-fanyi="1">
          试图将明文字节序列中数据缓冲区的SSL / TLS网络数据。 
         <p data-fanyi="1">此方法的调用与调用的方式完全相同的行为：</p> 
         <blockquote> 
          <pre>
 <a href="../../../javax/net/ssl/SSLEngine.html#wrap-java.nio.ByteBuffer:A-int-int-java.nio.ByteBuffer-"><code>engine.wrap(srcs, 0, srcs.length, dst);</code></a>
 </pre> 
         </blockquote> 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>srcs</code> -含出境应用数据 
          <code>ByteBuffers</code>数组 
         </dd> 
         <dd data-fanyi="1"> 
          <code>dst</code> - 
          <code>ByteBuffer</code>持有境外网络数据 
         </dd> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           一个 
          <code>SSLEngineResult</code>描述此操作的结果。 
         </dd> 
         <dt> 
          <span class="throwsLabel">异常</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code><a href="../../../javax/net/ssl/SSLException.html" title="class in javax.net.ssl">SSLException</a></code> -一个问题而引起的 
          <code>SSLEngine</code>中止数据处理中遇到的。看到关于引擎关闭的更多信息的类描述。 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/nio/ReadOnlyBufferException.html" title="class in java.nio">ReadOnlyBufferException</a></code> -如果 
          <code>dst</code>缓冲区是只读的。 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> -如果 
          <code>srcs</code>或 
          <code>dst</code>是无效的，或者在 
          <code>srcs</code>任何元素为null。 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/IllegalStateException.html" title="class in java.lang">IllegalStateException</a></code>如果客户端/服务器模式尚未确定。 
         </dd> 
         <dt> 
          <span class="seeLabel">另请参见：</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <a href="../../../javax/net/ssl/SSLEngine.html#wrap-java.nio.ByteBuffer:A-int-int-java.nio.ByteBuffer-"><code>wrap(ByteBuffer [], int, int, ByteBuffer)</code></a> 
         </dd> 
        </dl> </li> 
      </ul> <a name="wrap-java.nio.ByteBuffer:A-int-int-java.nio.ByteBuffer-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>wrap</h4> <pre>public abstract&nbsp;<a href="../../../javax/net/ssl/SSLEngineResult.html" title="class in javax.net.ssl">SSLEngineResult</a>&nbsp;wrap(<a href="../../../java/nio/ByteBuffer.html" title="class in java.nio">ByteBuffer</a>[]&nbsp;srcs,
                                     int&nbsp;offset,
                                     int&nbsp;length,
                                     <a href="../../../java/nio/ByteBuffer.html" title="class in java.nio">ByteBuffer</a>&nbsp;dst)
                              throws <a href="../../../javax/net/ssl/SSLException.html" title="class in javax.net.ssl">SSLException</a></pre> 
        <div class="block" data-fanyi="1">
          试图将明文字节从序列数据缓冲区的SSL / TLS网络数据。这种“收集”操作的编码，在一次调用中，序列的一个或多个指定的缓冲区字节序列。当实现网络协议或文件格式时，收集包通常是有用的，例如，将数据分组到由一个或多个固定长度的头和一个可变长度的身体组成的段中。看到在收集更多信息 
         <a href="../../../java/nio/channels/GatheringByteChannel.html" title="interface in java.nio.channels"><code>GatheringByteChannel</code></a>，以及对后继行为的更多信息 
         <a href="../../../java/nio/channels/GatheringByteChannel.html#write-java.nio.ByteBuffer:A-int-int-"><code>GatheringByteChannel.write(ByteBuffer[], int, int)</code></a>。 
         <p data-fanyi="1">根据SSLEngine的状态，这种方法可能会产生网络数据而不消耗任何应用程序数据（例如，它可能会产生握手数据。）</p> 
         <p data-fanyi="1">应用程序负责可靠地传输网络数据的节点，并确保数据的多个调用创建wrap()运以同样的顺序产生它。应用程序必须正确地同步多个对该方法的调用。</p> 
         <p data-fanyi="1">如果这<code>SSLEngine</code>尚未开始其第一次握手，这个方法会自动开始握手。</p> 
         <p data-fanyi="1">这种方法会产生SSL / TLS的记录，并会消耗尽可能多的源数据的可能，但不会消耗超过其余每个缓冲区字节的总和。每个<code>ByteBuffer</code>的位置被更新以反映数据消耗或产生量。限制保持不变。</p> 
         <p data-fanyi="1">底层的内存的<code>srcs</code>和<code>dst ByteBuffer</code>s必须不一样。</p> 
         <p data-fanyi="1">看到关于引擎关闭的更多信息的类描述。</p> 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>srcs</code> -含出境应用数据 
          <code>ByteBuffers</code>数组 
         </dd> 
         <dd data-fanyi="1"> 
          <code>offset</code> -在第一缓冲区字节进行检索缓冲数组的偏移；它必须是非负的且不大于 
          <code>srcs.length</code> 
         </dd> 
         <dd data-fanyi="1"> 
          <code>length</code> -缓冲区的最大数量被访问；它必须是非负的且不大于 
          <code>srcs.length</code>&nbsp;-&nbsp; 
          <code>offset</code> 
         </dd> 
         <dd data-fanyi="1"> 
          <code>dst</code> - 
          <code>ByteBuffer</code>持有境外网络数据 
         </dd> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           一个 
          <code>SSLEngineResult</code>描述此操作的结果。 
         </dd> 
         <dt> 
          <span class="throwsLabel">异常</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code><a href="../../../javax/net/ssl/SSLException.html" title="class in javax.net.ssl">SSLException</a></code> -一个问题而引起的 
          <code>SSLEngine</code>中止数据处理中遇到的。看到关于引擎关闭的更多信息的类描述。 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/IndexOutOfBoundsException.html" title="class in java.lang">IndexOutOfBoundsException</a></code> -如果在 
          <code>offset</code>和 
          <code>length</code>参数的前提条件不成立。 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/nio/ReadOnlyBufferException.html" title="class in java.nio">ReadOnlyBufferException</a></code> -如果 
          <code>dst</code>缓冲区是只读的。 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> -如果 
          <code>srcs</code>或 
          <code>dst</code>是无效的，或者在规定的 
          <code>srcs</code>序列的任何元素是空的。 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/IllegalStateException.html" title="class in java.lang">IllegalStateException</a></code>如果客户端/服务器模式尚未确定。 
         </dd> 
         <dt> 
          <span class="seeLabel">另请参见：</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <a href="../../../java/nio/channels/GatheringByteChannel.html" title="interface in java.nio.channels"><code>GatheringByteChannel</code></a>， 
          <a href="../../../java/nio/channels/GatheringByteChannel.html#write-java.nio.ByteBuffer:A-int-int-"><code>GatheringByteChannel.write( ByteBuffer[], int, int)</code></a> 
         </dd> 
        </dl> </li> 
      </ul> <a name="unwrap-java.nio.ByteBuffer-java.nio.ByteBuffer-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>unwrap</h4> <pre>public&nbsp;<a href="../../../javax/net/ssl/SSLEngineResult.html" title="class in javax.net.ssl">SSLEngineResult</a>&nbsp;unwrap(<a href="../../../java/nio/ByteBuffer.html" title="class in java.nio">ByteBuffer</a>&nbsp;src,
                              <a href="../../../java/nio/ByteBuffer.html" title="class in java.nio">ByteBuffer</a>&nbsp;dst)
                       throws <a href="../../../javax/net/ssl/SSLException.html" title="class in javax.net.ssl">SSLException</a></pre> 
        <div class="block" data-fanyi="1">
          试图破解SSL / TLS网络数据转换成明文数据的缓冲区的应用。 
         <p data-fanyi="1">此方法的调用与调用的方式完全相同的行为：</p> 
         <blockquote> 
          <pre>
 <a href="../../../javax/net/ssl/SSLEngine.html#unwrap-java.nio.ByteBuffer-java.nio.ByteBuffer:A-int-int-"><code>engine.unwrap(src, new ByteBuffer [] { dst }, 0, 1);</code></a>
 </pre> 
         </blockquote> 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>src</code> - 
          <code>ByteBuffer</code>含入站网络数据。 
         </dd> 
         <dd data-fanyi="1"> 
          <code>dst</code> - 
          <code>ByteBuffer</code>持有入境申请资料。 
         </dd> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           一个 
          <code>SSLEngineResult</code>描述此操作的结果。 
         </dd> 
         <dt> 
          <span class="throwsLabel">异常</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code><a href="../../../javax/net/ssl/SSLException.html" title="class in javax.net.ssl">SSLException</a></code> -一个问题而引起的 
          <code>SSLEngine</code>中止数据处理中遇到的。看到关于引擎关闭的更多信息的类描述。 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/nio/ReadOnlyBufferException.html" title="class in java.nio">ReadOnlyBufferException</a></code> -如果 
          <code>dst</code>缓冲区是只读的。 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> -如果 
          <code>src</code>或 
          <code>dst</code>是空的。 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/IllegalStateException.html" title="class in java.lang">IllegalStateException</a></code>如果客户端/服务器模式尚未确定。 
         </dd> 
         <dt> 
          <span class="seeLabel">另请参见：</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <a href="../../../javax/net/ssl/SSLEngine.html#unwrap-java.nio.ByteBuffer-java.nio.ByteBuffer:A-int-int-"><code>unwrap(ByteBuffer, ByteBuffer [], int, int)</code></a> 
         </dd> 
        </dl> </li> 
      </ul> <a name="unwrap-java.nio.ByteBuffer-java.nio.ByteBuffer:A-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>unwrap</h4> <pre>public&nbsp;<a href="../../../javax/net/ssl/SSLEngineResult.html" title="class in javax.net.ssl">SSLEngineResult</a>&nbsp;unwrap(<a href="../../../java/nio/ByteBuffer.html" title="class in java.nio">ByteBuffer</a>&nbsp;src,
                              <a href="../../../java/nio/ByteBuffer.html" title="class in java.nio">ByteBuffer</a>[]&nbsp;dsts)
                       throws <a href="../../../javax/net/ssl/SSLException.html" title="class in javax.net.ssl">SSLException</a></pre> 
        <div class="block" data-fanyi="1">
          试图破解SSL / TLS网络数据序列变成一个明文应用数据缓冲区。 
         <p data-fanyi="1">此方法的调用与调用的方式完全相同的行为：</p> 
         <blockquote> 
          <pre>
 <a href="../../../javax/net/ssl/SSLEngine.html#unwrap-java.nio.ByteBuffer-java.nio.ByteBuffer:A-int-int-"><code>engine.unwrap(src, dsts, 0, dsts.length);</code></a>
 </pre> 
         </blockquote> 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>src</code> - 
          <code>ByteBuffer</code>含入站网络数据。 
         </dd> 
         <dd data-fanyi="1"> 
          <code>dsts</code> - 
          <code>ByteBuffer</code>s持有入境申请数据数组。 
         </dd> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           一个 
          <code>SSLEngineResult</code>描述此操作的结果。 
         </dd> 
         <dt> 
          <span class="throwsLabel">异常</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code><a href="../../../javax/net/ssl/SSLException.html" title="class in javax.net.ssl">SSLException</a></code> -一个问题而引起的 
          <code>SSLEngine</code>中止数据处理中遇到的。看到关于引擎关闭的更多信息的类描述。 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/nio/ReadOnlyBufferException.html" title="class in java.nio">ReadOnlyBufferException</a></code> -如果有任何的 
          <code>dst</code>缓冲区是只读的。 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> -如果 
          <code>src</code>或 
          <code>dsts</code>是无效的，或者在 
          <code>dsts</code>任何元素为null。 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/IllegalStateException.html" title="class in java.lang">IllegalStateException</a></code>如果客户端/服务器模式尚未确定。 
         </dd> 
         <dt> 
          <span class="seeLabel">另请参见：</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <a href="../../../javax/net/ssl/SSLEngine.html#unwrap-java.nio.ByteBuffer-java.nio.ByteBuffer:A-int-int-"><code>unwrap(ByteBuffer, ByteBuffer [], int, int)</code></a> 
         </dd> 
        </dl> </li> 
      </ul> <a name="unwrap-java.nio.ByteBuffer-java.nio.ByteBuffer:A-int-int-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>unwrap</h4> <pre>public abstract&nbsp;<a href="../../../javax/net/ssl/SSLEngineResult.html" title="class in javax.net.ssl">SSLEngineResult</a>&nbsp;unwrap(<a href="../../../java/nio/ByteBuffer.html" title="class in java.nio">ByteBuffer</a>&nbsp;src,
                                       <a href="../../../java/nio/ByteBuffer.html" title="class in java.nio">ByteBuffer</a>[]&nbsp;dsts,
                                       int&nbsp;offset,
                                       int&nbsp;length)
                                throws <a href="../../../javax/net/ssl/SSLException.html" title="class in javax.net.ssl">SSLException</a></pre> 
        <div class="block" data-fanyi="1">
          试图破解SSL / TLS网络数据转换成一个序列的明文数据缓冲区中的应用。这种“散射”操作解码，在一次调用中，一个字节序列转换成一个或多个给定序列的缓冲区。散射展开往往是有用的当实现的网络协议或文件格式，例如，组数据组成的一个或多个固定长度的头跟着一个可变长度的身体部分。看到 
         <a href="../../../java/nio/channels/ScatteringByteChannel.html" title="interface in java.nio.channels"><code>ScatteringByteChannel</code></a>对散射的更多信息，并为后续行为的更多信息 
         <a href="../../../java/nio/channels/ScatteringByteChannel.html#read-java.nio.ByteBuffer:A-int-int-"><code>ScatteringByteChannel.read(ByteBuffer[], int, int)</code></a>。 
         <p data-fanyi="1">根据SSLEngine的状态，这种方法可能没有产生任何应用数据网络消费数据（例如，它可能会消耗握手数据。）</p> 
         <p data-fanyi="1">应用程序负责可靠地获取网络数据从节点，并调用unwrap()对订单数据被接收。应用程序必须正确地同步多个对该方法的调用。</p> 
         <p data-fanyi="1">如果这<code>SSLEngine</code>尚未开始其第一次握手，这个方法会自动开始握手。</p> 
         <p data-fanyi="1">该方法将尝试使用一个完整的SSL / TLS的网络数据包，但不会消耗超过字节中剩余的缓冲区的数目。每个<code>ByteBuffer</code>的位置被更新以反映数据消耗或产生量。限制保持不变。</p> 
         <p data-fanyi="1">底层的内存的<code>src</code>和<code>dsts ByteBuffer</code>s必须不一样。</p> 
         <p data-fanyi="1">入站网络缓冲器可以被修改为这个调用的结果：因此，如果网络数据包需要一些次要的目的，在调用该方法之前，数据应该被复制。注：网络数据不被第二sslengine有用，因为每个sslengine含有独特的随机状态影响SSL / TLS消息。</p> 
         <p data-fanyi="1">看到关于引擎关闭的更多信息的类描述。</p> 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>src</code> - 
          <code>ByteBuffer</code>含入站网络数据。 
         </dd> 
         <dd data-fanyi="1"> 
          <code>dsts</code> - 
          <code>ByteBuffer</code>s持有入境申请数据数组。 
         </dd> 
         <dd data-fanyi="1"> 
          <code>offset</code> -在第一缓冲区字节将缓冲数组的偏移；它必须是非负的且不大于 
          <code>dsts.length</code>。 
         </dd> 
         <dd data-fanyi="1"> 
          <code>length</code> -缓冲区的最大数量被访问；它必须是非负的且不大于 
          <code>dsts.length</code>&nbsp;-&nbsp; 
          <code>offset</code>。 
         </dd> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           一个 
          <code>SSLEngineResult</code>描述此操作的结果。 
         </dd> 
         <dt> 
          <span class="throwsLabel">异常</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code><a href="../../../javax/net/ssl/SSLException.html" title="class in javax.net.ssl">SSLException</a></code> -一个问题而引起的 
          <code>SSLEngine</code>中止数据处理中遇到的。看到关于引擎关闭的更多信息的类描述。 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/IndexOutOfBoundsException.html" title="class in java.lang">IndexOutOfBoundsException</a></code> -如果在 
          <code>offset</code>和 
          <code>length</code>参数的前提条件不成立。 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/nio/ReadOnlyBufferException.html" title="class in java.nio">ReadOnlyBufferException</a></code> -如果有任何的 
          <code>dst</code>缓冲区是只读的。 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> -如果 
          <code>src</code>或 
          <code>dsts</code>是无效的，或者在规定的 
          <code>dsts</code>序列的任何元素是空的。 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/IllegalStateException.html" title="class in java.lang">IllegalStateException</a></code>如果客户端/服务器模式尚未确定。 
         </dd> 
         <dt> 
          <span class="seeLabel">另请参见：</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <a href="../../../java/nio/channels/ScatteringByteChannel.html" title="interface in java.nio.channels"><code>ScatteringByteChannel</code></a>， 
          <a href="../../../java/nio/channels/ScatteringByteChannel.html#read-java.nio.ByteBuffer:A-int-int-"><code>ScatteringByteChannel.read( ByteBuffer[], int, int)</code></a> 
         </dd> 
        </dl> </li> 
      </ul> <a name="getDelegatedTask--"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>getDelegatedTask</h4> <pre>public abstract&nbsp;<a href="../../../java/lang/Runnable.html" title="interface in java.lang">Runnable</a>&nbsp;getDelegatedTask()</pre> 
        <div class="block" data-fanyi="1">
          返回一个授权 
         <code>Runnable</code>任务这 
         <code>SSLEngine</code>。 
         <p data-fanyi="1"><code>SSLEngine</code>操作可能需要操作块的结果，也可能完全采取长时间。这种方法被用来获得一个优秀的<a href="../../../java/lang/Runnable.html" title="interface in java.lang"><code>Runnable</code></a>作业（任务）。每个任务必须被分配一个线程（或电流）进行<a href="../../../java/lang/Runnable.html#run--"><code>run</code></a>操作。一旦<code>run</code>方法返回的<code>Runnable</code>对象不再需要和可能被丢弃。</p> 
         <p data-fanyi="1">委派任务运行到位时，这个对象被创建<code>AccessControlContext</code>。</p> 
         <p data-fanyi="1">调用此方法将完全返回每一个优秀的任务一次。</p> 
         <p data-fanyi="1">多个委派任务可以并行运行。</p> 
        </div> 
        <dl> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>Runnable</code>委派任务，或null，如果没有可用的。 
         </dd> 
        </dl> </li> 
      </ul> <a name="closeInbound--"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>closeInbound</h4> <pre>public abstract&nbsp;void&nbsp;closeInbound()
                           throws <a href="../../../javax/net/ssl/SSLException.html" title="class in javax.net.ssl">SSLException</a></pre> 
        <div class="block" data-fanyi="1">
          信号，没有更多的入站网络将数据发送到这个 
         <code>SSLEngine</code>。 
         <p data-fanyi="1">如果应用程序启动关闭过程调用<a href="../../../javax/net/ssl/SSLEngine.html#closeOutbound--"><code>closeOutbound()</code></a>，在某些情况下，它是不需要为同行的相应消息引发剂等。（见规范第7.2.1 TLS（<a href="http://www.ietf.org/rfc/rfc2246.txt">RFC 2246</a>）的更多信息，等待关闭警报。）在这种情况下，该方法不需要被称为。</p> 
         <p data-fanyi="1">但是，如果应用程序没有启动关闭进程，如果上述情况不适用，这种方法被称为每当端的SSL / TLS数据流达到。这保证了入境的侧封，并检查点之后的SSL / TLS的关闭程序，以检测可能的截断攻击。</p> 
         <p data-fanyi="1">这种方法是幂等：如果入境已关闭，此方法不做任何事。</p> 
         <p data-fanyi="1"><a href="../../../javax/net/ssl/SSLEngine.html#wrap-java.nio.ByteBuffer-java.nio.ByteBuffer-"><code>wrap()</code></a>应该叫冲任何剩余的握手数据。</p> 
        </div> 
        <dl> 
         <dt> 
          <span class="throwsLabel">异常</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code><a href="../../../javax/net/ssl/SSLException.html" title="class in javax.net.ssl">SSLException</a></code> -如果发动机没有得到适当的SSL / TLS关闭通知消息来自同伴。 
         </dd> 
         <dt> 
          <span class="seeLabel">另请参见：</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <a href="../../../javax/net/ssl/SSLEngine.html#isInboundDone--"><code>isInboundDone()</code></a>， 
          <a href="../../../javax/net/ssl/SSLEngine.html#isOutboundDone--"><code>isOutboundDone()</code></a> 
         </dd> 
        </dl> </li> 
      </ul> <a name="isInboundDone--"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>isInboundDone</h4> <pre>public abstract&nbsp;boolean&nbsp;isInboundDone()</pre> 
        <div class="block" data-fanyi="1">
          返回是否 
         <a href="../../../javax/net/ssl/SSLEngine.html#unwrap-java.nio.ByteBuffer-java.nio.ByteBuffer-"><code>unwrap(ByteBuffer, ByteBuffer)</code></a>将接受任何入站数据信息。 
        </div> 
        <dl> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           如果 
          <code>SSLEngine</code>不会消耗了网络数据（通过暗示，不会产生任何更多的应用程序数据。） 
         </dd> 
         <dt> 
          <span class="seeLabel">另请参见：</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <a href="../../../javax/net/ssl/SSLEngine.html#closeInbound--"><code>closeInbound()</code></a> 
         </dd> 
        </dl> </li> 
      </ul> <a name="closeOutbound--"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>closeOutbound</h4> <pre>public abstract&nbsp;void&nbsp;closeOutbound()</pre> 
        <div class="block" data-fanyi="1">
          信号不再出境申请资料将被送到这 
         <code>SSLEngine</code>。 
         <p data-fanyi="1">这种方法是幂等：如果外侧已被关闭，此方法不做任何事。</p> 
         <p data-fanyi="1"><a href="../../../javax/net/ssl/SSLEngine.html#wrap-java.nio.ByteBuffer-java.nio.ByteBuffer-"><code>wrap(ByteBuffer, ByteBuffer)</code></a>应该叫冲任何剩余的握手数据。</p> 
        </div> 
        <dl> 
         <dt> 
          <span class="seeLabel">另请参见：</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <a href="../../../javax/net/ssl/SSLEngine.html#isOutboundDone--"><code>isOutboundDone()</code></a> 
         </dd> 
        </dl> </li> 
      </ul> <a name="isOutboundDone--"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>isOutboundDone</h4> <pre>public abstract&nbsp;boolean&nbsp;isOutboundDone()</pre> 
        <div class="block" data-fanyi="1">
          返回是否会产生更多的 
         <a href="../../../javax/net/ssl/SSLEngine.html#wrap-java.nio.ByteBuffer-java.nio.ByteBuffer-"><code>wrap(ByteBuffer, ByteBuffer)</code></a>出境数据信息。 
         <p data-fanyi="1">关闭期间，注意，一个<code>SSLEngine</code>可能产生握手关闭数据必须发送到同伴。<code>wrap()</code>必须生成这些数据。当此方法返回真实，没有更多的出站数据将被创建。</p> 
        </div> 
        <dl> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           如果 
          <code>SSLEngine</code>不会产生任何更多的网络数据 
         </dd> 
         <dt> 
          <span class="seeLabel">另请参见：</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <a href="../../../javax/net/ssl/SSLEngine.html#closeOutbound--"><code>closeOutbound()</code></a>， 
          <a href="../../../javax/net/ssl/SSLEngine.html#closeInbound--"><code>closeInbound()</code></a> 
         </dd> 
        </dl> </li> 
      </ul> <a name="getSupportedCipherSuites--"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>getSupportedCipherSuites</h4> <pre>public abstract&nbsp;<a href="../../../java/lang/String.html" title="class in java.lang">String</a>[]&nbsp;getSupportedCipherSuites()</pre> 
        <div class="block" data-fanyi="1">
          返回可在该引擎上启用的密码套件的名称。通常情况下，只有一个子集，这些将实际启用默认情况下，因为这个列表可能包括密码套件，不符合质量的服务要求，这些默认。这样的密码套件可能在专门的应用程序中是有用的。 
        </div> 
        <dl> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           一个数组的密码套件名称 
         </dd> 
         <dt> 
          <span class="seeLabel">另请参见：</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <a href="../../../javax/net/ssl/SSLEngine.html#getEnabledCipherSuites--"><code>getEnabledCipherSuites()</code></a>， 
          <a href="../../../javax/net/ssl/SSLEngine.html#setEnabledCipherSuites-java.lang.String:A-"><code>setEnabledCipherSuites(String [])</code></a> 
         </dd> 
        </dl> </li> 
      </ul> <a name="getEnabledCipherSuites--"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>getEnabledCipherSuites</h4> <pre>public abstract&nbsp;<a href="../../../java/lang/String.html" title="class in java.lang">String</a>[]&nbsp;getEnabledCipherSuites()</pre> 
        <div class="block" data-fanyi="1">
          返回正在使用的这台发动机启用SSL加密套件名称。当一个sslengine首次创建，所有启用的密码套件支持最低的服务质量。因此，在某些环境中，这个值可能是空的。 
         <p data-fanyi="1">即使一个套件已启用，它可能永远不会被使用。（例如，对等体不支持它，所需的证书/私钥的套件是不可用的，或一个匿名的套件，但需要身份验证。）</p> 
        </div> 
        <dl> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           一个数组的密码套件名称 
         </dd> 
         <dt> 
          <span class="seeLabel">另请参见：</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <a href="../../../javax/net/ssl/SSLEngine.html#getSupportedCipherSuites--"><code>getSupportedCipherSuites()</code></a>， 
          <a href="../../../javax/net/ssl/SSLEngine.html#setEnabledCipherSuites-java.lang.String:A-"><code>setEnabledCipherSuites(String [])</code></a> 
         </dd> 
        </dl> </li> 
      </ul> <a name="setEnabledCipherSuites-java.lang.String:A-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>setEnabledCipherSuites</h4> <pre>public abstract&nbsp;void&nbsp;setEnabledCipherSuites(<a href="../../../java/lang/String.html" title="class in java.lang">String</a>[]&nbsp;suites)</pre> 
        <div class="block" data-fanyi="1">
          设置启用此引擎上使用的密码套件。 
         <p data-fanyi="1">在<code>suites</code>参数每个密码套件必须已上市getsupportedciphersuites()，或方法会失败。继成功调用这个方法，只有在<code>suites</code>参数上市套房都能使用。</p> 
         <p data-fanyi="1">看到<a href="../../../javax/net/ssl/SSLEngine.html#getEnabledCipherSuites--"><code>getEnabledCipherSuites()</code></a>更多信息，为什么一个特定的密码套件可能永远不会被用在发动机。</p> 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>suites</code>名称的所有密码套件使 
         </dd> 
         <dt> 
          <span class="throwsLabel">异常</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> -当一个或更多的密码由参数指定不支持，或者当参数为空。 
         </dd> 
         <dt> 
          <span class="seeLabel">另请参见：</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <a href="../../../javax/net/ssl/SSLEngine.html#getSupportedCipherSuites--"><code>getSupportedCipherSuites()</code></a>， 
          <a href="../../../javax/net/ssl/SSLEngine.html#getEnabledCipherSuites--"><code>getEnabledCipherSuites()</code></a> 
         </dd> 
        </dl> </li> 
      </ul> <a name="getSupportedProtocols--"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>getSupportedProtocols</h4> <pre>public abstract&nbsp;<a href="../../../java/lang/String.html" title="class in java.lang">String</a>[]&nbsp;getSupportedProtocols()</pre> 
        <div class="block" data-fanyi="1">
          返回该协议可以使用这些 
         <code>SSLEngine</code>的名字。 
        </div> 
        <dl> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           支持的协议数组 
         </dd> 
        </dl> </li> 
      </ul> <a name="getEnabledProtocols--"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>getEnabledProtocols</h4> <pre>public abstract&nbsp;<a href="../../../java/lang/String.html" title="class in java.lang">String</a>[]&nbsp;getEnabledProtocols()</pre> 
        <div class="block" data-fanyi="1">
          返回正在使用这 
         <code>SSLEngine</code>协议版本的名字。 
        </div> 
        <dl> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           协议数组 
         </dd> 
         <dt> 
          <span class="seeLabel">另请参见：</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <a href="../../../javax/net/ssl/SSLEngine.html#setEnabledProtocols-java.lang.String:A-"><code>setEnabledProtocols(String [])</code></a> 
         </dd> 
        </dl> </li> 
      </ul> <a name="setEnabledProtocols-java.lang.String:A-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>setEnabledProtocols</h4> <pre>public abstract&nbsp;void&nbsp;setEnabledProtocols(<a href="../../../java/lang/String.html" title="class in java.lang">String</a>[]&nbsp;protocols)</pre> 
        <div class="block" data-fanyi="1">
          设置启用此引擎上使用的协议版本。 
         <p data-fanyi="1">该协议必须被列为支持getsupportedprotocols()。继成功调用这个方法，只有在<code>protocols</code>参数上市协议能使用。</p> 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>protocols</code>名称的所有协议，使。 
         </dd> 
         <dt> 
          <span class="throwsLabel">异常</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> -当一个或更多的协议参数的命名是不支持或当协议参数为空。 
         </dd> 
         <dt> 
          <span class="seeLabel">另请参见：</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <a href="../../../javax/net/ssl/SSLEngine.html#getEnabledProtocols--"><code>getEnabledProtocols()</code></a> 
         </dd> 
        </dl> </li> 
      </ul> <a name="getSession--"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>getSession</h4> <pre>public abstract&nbsp;<a href="../../../javax/net/ssl/SSLSession.html" title="interface in javax.net.ssl">SSLSession</a>&nbsp;getSession()</pre> 
        <div class="block" data-fanyi="1">
          在这 
         <code>SSLEngine</code>返回使用的 
         <code>SSLSession</code>。 
         <p data-fanyi="1">这些可以是长寿命的，并且经常对应于某个用户的整个登录会话。会话指定了在该会话中的所有连接正在使用的一个特定的密码组，以及会话的客户端和服务器的身份。</p> 
         <p data-fanyi="1">不像<a href="../../../javax/net/ssl/SSLSocket.html#getSession--"><code>SSLSocket.getSession()</code></a>此方法不会阻止直到握手完成。</p> 
         <p data-fanyi="1">直到第一次握手完成，此方法返回一个会话对象报告无效的密码套件“ssl_null_with_null_null”。</p> 
        </div> 
        <dl> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           这 
          <code>SSLEngine</code>的 
          <code>SSLSession</code> 
         </dd> 
         <dt> 
          <span class="seeLabel">另请参见：</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <a href="../../../javax/net/ssl/SSLSession.html" title="interface in javax.net.ssl"><code>SSLSession</code></a> 
         </dd> 
        </dl> </li> 
      </ul> <a name="getHandshakeSession--"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>getHandshakeSession</h4> <pre>public&nbsp;<a href="../../../javax/net/ssl/SSLSession.html" title="interface in javax.net.ssl">SSLSession</a>&nbsp;getHandshakeSession()</pre> 
        <div class="block" data-fanyi="1">
          返回 
         <code>SSLSession</code>是SSL / TLS握手期间建造的。 
         <p data-fanyi="1">TLS协议可协商的参数，使用这个类的实例时所需要的，但在<code>SSLSession</code>已经完全初始化，可以通过<code>getSession</code>。例如，有效的签名算法的列表可能限制在trustmanager决定使用证书，类型，或最大TLS片段数据包大小可以调整到更好的支持网络环境。</p> 
         <p data-fanyi="1">这种方法提供了早期进入<code>SSLSession</code>构造。根据握手取得的进展，一些数据可能还没有被使用。例如，如果一个远程服务器将发送一个证书链，但链尚未被处理，对<code>SSLSession</code>的<code>getPeerCertificates</code>方法将抛出一个sslpeerunverifiedexception。一旦链已被处理，<code>getPeerCertificates</code>将返回正确的值。</p> 
        </div> 
        <dl> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           如果这种情况目前不握手为空，或如果当前握手没有进展到足以创建一个基本的sslsession。否则，该方法返回 
          <code>SSLSession</code>目前正在协商。 
         </dd> 
         <dt> 
          <span class="throwsLabel">异常</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> -如果基础提供程序不执行操作。 
         </dd> 
         <dt> 
          <span class="simpleTagLabel">从以下版本开始：</span> 
         </dt> 
         <dd data-fanyi="1">
           一点七 
         </dd> 
         <dt> 
          <span class="seeLabel">另请参见：</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <a href="../../../javax/net/ssl/SSLSocket.html" title="class in javax.net.ssl"><code>SSLSocket</code></a>， 
          <a href="../../../javax/net/ssl/SSLSession.html" title="interface in javax.net.ssl"><code>SSLSession</code></a>， 
          <a href="../../../javax/net/ssl/ExtendedSSLSession.html" title="class in javax.net.ssl"><code>ExtendedSSLSession</code></a>， 
          <a href="../../../javax/net/ssl/X509ExtendedKeyManager.html" title="class in javax.net.ssl"><code>X509ExtendedKeyManager</code></a>， 
          <a href="../../../javax/net/ssl/X509ExtendedTrustManager.html" title="class in javax.net.ssl"><code>X509ExtendedTrustManager</code></a> 
         </dd> 
        </dl> </li> 
      </ul> <a name="beginHandshake--"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>beginHandshake</h4> <pre>public abstract&nbsp;void&nbsp;beginHandshake()
                             throws <a href="../../../javax/net/ssl/SSLException.html" title="class in javax.net.ssl">SSLException</a></pre> 
        <div class="block" data-fanyi="1">
          发起握手（初始或重新谈判，这sslengine）。 
         <p data-fanyi="1">此方法不需要初始握手，为<code>wrap()</code>和<code>unwrap()</code>方法将隐式调用此方法如果握手还没有开始。</p> 
         <p data-fanyi="1">请注意，同伴也可以要求重新谈判这<code>SSLEngine</code>会议通过发送适当的会话协商握手消息。</p> 
         <p data-fanyi="1">不像<a href="../../../javax/net/ssl/SSLSocket.html#startHandshake--"><code>SSLSocket#startHandshake()</code></a>方法，此方法不会阻止直到握手完成。</p> 
         <p data-fanyi="1">强迫一个完整的SSL / TLS会话协商当前会话应无效调用此方法之前。</p> 
         <p data-fanyi="1">有些协议不支持多个握手对现有引擎，并可能引发<code>SSLException</code>。</p> 
        </div> 
        <dl> 
         <dt> 
          <span class="throwsLabel">异常</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code><a href="../../../javax/net/ssl/SSLException.html" title="class in javax.net.ssl">SSLException</a></code> -如果在信号的 
          <code>SSLEngine</code>开始一个新的握手中遇到的一个问题。看到关于引擎关闭的更多信息的类描述。 
         </dd> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/IllegalStateException.html" title="class in java.lang">IllegalStateException</a></code>如果客户端/服务器模式尚未确定。 
         </dd> 
         <dt> 
          <span class="seeLabel">另请参见：</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <a href="../../../javax/net/ssl/SSLSession.html#invalidate--"><code>SSLSession.invalidate()</code></a> 
         </dd> 
        </dl> </li> 
      </ul> <a name="getHandshakeStatus--"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>getHandshakeStatus</h4> <pre>public abstract&nbsp;<a href="../../../javax/net/ssl/SSLEngineResult.HandshakeStatus.html" title="enum in javax.net.ssl">SSLEngineResult.HandshakeStatus</a>&nbsp;getHandshakeStatus()</pre> 
        <div class="block" data-fanyi="1">
          返回当前的这一现状 
         <code>SSLEngine</code>握手。 
        </div> 
        <dl> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           目前 
          <code>SSLEngineResult.HandshakeStatus</code>。 
         </dd> 
        </dl> </li> 
      </ul> <a name="setUseClientMode-boolean-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>setUseClientMode</h4> <pre>public abstract&nbsp;void&nbsp;setUseClientMode(boolean&nbsp;mode)</pre> 
        <div class="block" data-fanyi="1">
          配置引擎使用客户端（或服务器）模式时，握手。 
         <p data-fanyi="1">这种方法必须在任何握手时称为。一次握手开始，模式不能对这台发动机的寿命复位。</p> 
         <p data-fanyi="1">服务器通常对自己进行身份验证，而客户端不需要这样做。</p> 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>mode</code> -如果发动机要握手“客户端”模式 
         </dd> 
         <dt> 
          <span class="throwsLabel">异常</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> -如果一个模式的变化是试图在最初的握手开始。 
         </dd> 
         <dt> 
          <span class="seeLabel">另请参见：</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <a href="../../../javax/net/ssl/SSLEngine.html#getUseClientMode--"><code>getUseClientMode()</code></a> 
         </dd> 
        </dl> </li> 
      </ul> <a name="getUseClientMode--"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>getUseClientMode</h4> <pre>public abstract&nbsp;boolean&nbsp;getUseClientMode()</pre> 
        <div class="block" data-fanyi="1">
          如果发动机将使用客户端模式握手时返回真。 
        </div> 
        <dl> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           如果发动机应该握手“客户端”模式 
         </dd> 
         <dt> 
          <span class="seeLabel">另请参见：</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <a href="../../../javax/net/ssl/SSLEngine.html#setUseClientMode-boolean-"><code>setUseClientMode(boolean)</code></a> 
         </dd> 
        </dl> </li> 
      </ul> <a name="setNeedClientAuth-boolean-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>setNeedClientAuth</h4> <pre>public abstract&nbsp;void&nbsp;setNeedClientAuth(boolean&nbsp;need)</pre> 
        <div class="block" data-fanyi="1">
          配置引擎要求客户端认证。此选项只对服务器模式中的引擎有用。 
         <p data-fanyi="1">一个引擎的客户端身份验证设置是下列之一：</p> 
         <ul data-fanyi="1"> 
          <li data-fanyi="1">客户端认证要求</li> 
          <li data-fanyi="1">客户端身份验证请求</li> 
          <li data-fanyi="1">没有客户端身份验证</li> 
         </ul> 
         <p data-fanyi="1">不像<a href="../../../javax/net/ssl/SSLEngine.html#setWantClientAuth-boolean-"><code>setWantClientAuth(boolean)</code></a>，如果设置了此选项，客户端不提供关于本身，认证信息谈判将停止，发动机将开始关闭程序。</p> 
         <p data-fanyi="1">调用此方法重写这个方法或<a href="../../../javax/net/ssl/SSLEngine.html#setWantClientAuth-boolean-"><code>setWantClientAuth(boolean)</code></a>做出任何以前的设置。</p> 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>need</code> -设置为true，如果客户需要身份验证，或假如果没有客户端认证要求。 
         </dd> 
         <dt> 
          <span class="seeLabel">另请参见：</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <a href="../../../javax/net/ssl/SSLEngine.html#getNeedClientAuth--"><code>getNeedClientAuth()</code></a>， 
          <a href="../../../javax/net/ssl/SSLEngine.html#setWantClientAuth-boolean-"><code>setWantClientAuth(boolean)</code></a>， 
          <a href="../../../javax/net/ssl/SSLEngine.html#getWantClientAuth--"><code>getWantClientAuth()</code></a>， 
          <a href="../../../javax/net/ssl/SSLEngine.html#setUseClientMode-boolean-"><code>setUseClientMode(boolean)</code></a> 
         </dd> 
        </dl> </li> 
      </ul> <a name="getNeedClientAuth--"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>getNeedClientAuth</h4> <pre>public abstract&nbsp;boolean&nbsp;getNeedClientAuth()</pre> 
        <div class="block" data-fanyi="1">
          如果发动机将要求客户端认证返回true。此选项只对服务器模式中的引擎有用。 
        </div> 
        <dl> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           如果需要客户端身份验证，或不需要客户端验证的情况下，则为假。 
         </dd> 
         <dt> 
          <span class="seeLabel">另请参见：</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <a href="../../../javax/net/ssl/SSLEngine.html#setNeedClientAuth-boolean-"><code>setNeedClientAuth(boolean)</code></a>， 
          <a href="../../../javax/net/ssl/SSLEngine.html#setWantClientAuth-boolean-"><code>setWantClientAuth(boolean)</code></a>， 
          <a href="../../../javax/net/ssl/SSLEngine.html#getWantClientAuth--"><code>getWantClientAuth()</code></a>， 
          <a href="../../../javax/net/ssl/SSLEngine.html#setUseClientMode-boolean-"><code>setUseClientMode(boolean)</code></a> 
         </dd> 
        </dl> </li> 
      </ul> <a name="setWantClientAuth-boolean-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>setWantClientAuth</h4> <pre>public abstract&nbsp;void&nbsp;setWantClientAuth(boolean&nbsp;want)</pre> 
        <div class="block" data-fanyi="1">
          配置引擎请求客户端认证。此选项只对服务器模式中的引擎有用。 
         <p data-fanyi="1">一个引擎的客户端身份验证设置是下列之一：</p> 
         <ul data-fanyi="1"> 
          <li data-fanyi="1">客户端认证要求</li> 
          <li data-fanyi="1">客户端身份验证请求</li> 
          <li data-fanyi="1">没有客户端身份验证</li> 
         </ul> 
         <p data-fanyi="1">不像<a href="../../../javax/net/ssl/SSLEngine.html#setNeedClientAuth-boolean-"><code>setNeedClientAuth(boolean)</code></a>，如果设置了此选项，客户端不提供自己的认证信息，谈判将继续。</p> 
         <p data-fanyi="1">调用此方法重写这个方法或<a href="../../../javax/net/ssl/SSLEngine.html#setNeedClientAuth-boolean-"><code>setNeedClientAuth(boolean)</code></a>做出任何以前的设置。</p> 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>want</code> -设置为true，如果要求客户端身份验证，或假如果没有客户端认证要求。 
         </dd> 
         <dt> 
          <span class="seeLabel">另请参见：</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <a href="../../../javax/net/ssl/SSLEngine.html#getWantClientAuth--"><code>getWantClientAuth()</code></a>， 
          <a href="../../../javax/net/ssl/SSLEngine.html#setNeedClientAuth-boolean-"><code>setNeedClientAuth(boolean)</code></a>， 
          <a href="../../../javax/net/ssl/SSLEngine.html#getNeedClientAuth--"><code>getNeedClientAuth()</code></a>， 
          <a href="../../../javax/net/ssl/SSLEngine.html#setUseClientMode-boolean-"><code>setUseClientMode(boolean)</code></a> 
         </dd> 
        </dl> </li> 
      </ul> <a name="getWantClientAuth--"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>getWantClientAuth</h4> <pre>public abstract&nbsp;boolean&nbsp;getWantClientAuth()</pre> 
        <div class="block" data-fanyi="1">
          如果发动机将请求客户端认证返回true。此选项只对服务器模式中的引擎有用。 
        </div> 
        <dl> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           如果要请求客户端身份验证，或如果没有希望客户端身份验证的话，则为。 
         </dd> 
         <dt> 
          <span class="seeLabel">另请参见：</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <a href="../../../javax/net/ssl/SSLEngine.html#setNeedClientAuth-boolean-"><code>setNeedClientAuth(boolean)</code></a>， 
          <a href="../../../javax/net/ssl/SSLEngine.html#getNeedClientAuth--"><code>getNeedClientAuth()</code></a>， 
          <a href="../../../javax/net/ssl/SSLEngine.html#setWantClientAuth-boolean-"><code>setWantClientAuth(boolean)</code></a>， 
          <a href="../../../javax/net/ssl/SSLEngine.html#setUseClientMode-boolean-"><code>setUseClientMode(boolean)</code></a> 
         </dd> 
        </dl> </li> 
      </ul> <a name="setEnableSessionCreation-boolean-"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>setEnableSessionCreation</h4> <pre>public abstract&nbsp;void&nbsp;setEnableSessionCreation(boolean&nbsp;flag)</pre> 
        <div class="block" data-fanyi="1">
          新的SSL会话控制是否可以通过该引擎的建立。如果会话创作是不允许的，而且没有现有会话恢复，就没有成功的握手。 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>flag</code>真表明会话可能被创造；这是默认的。错误表示必须恢复现有会话 
         </dd> 
         <dt> 
          <span class="seeLabel">另请参见：</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <a href="../../../javax/net/ssl/SSLEngine.html#getEnableSessionCreation--"><code>getEnableSessionCreation()</code></a> 
         </dd> 
        </dl> </li> 
      </ul> <a name="getEnableSessionCreation--"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>getEnableSessionCreation</h4> <pre>public abstract&nbsp;boolean&nbsp;getEnableSessionCreation()</pre> 
        <div class="block" data-fanyi="1">
          如果新的SSL会话可以通过这个引擎建立返回true。 
        </div> 
        <dl> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           真的表明会话可能被创建，这是默认的。错误表示必须恢复现有会话 
         </dd> 
         <dt> 
          <span class="seeLabel">另请参见：</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <a href="../../../javax/net/ssl/SSLEngine.html#setEnableSessionCreation-boolean-"><code>setEnableSessionCreation(boolean)</code></a> 
         </dd> 
        </dl> </li> 
      </ul> <a name="getSSLParameters--"> 
       <!--   --> </a> 
      <ul class="blockList"> 
       <li class="blockList"> <h4>getSSLParameters</h4> <pre>public&nbsp;<a href="../../../javax/net/ssl/SSLParameters.html" title="class in javax.net.ssl">SSLParameters</a>&nbsp;getSSLParameters()</pre> 
        <div class="block" data-fanyi="1">
          返回此sslengine效果sslparameters。密码组和返回的sslparameters协议总是非空。 
        </div> 
        <dl> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           这sslengine效果sslparameters。 
         </dd> 
         <dt> 
          <span class="simpleTagLabel">从以下版本开始：</span> 
         </dt> 
         <dd data-fanyi="1">
           一点六 
         </dd> 
        </dl> </li> 
      </ul> <a name="setSSLParameters-javax.net.ssl.SSLParameters-"> 
       <!--   --> </a> 
      <ul class="blockListLast"> 
       <li class="blockList"> <h4>setSSLParameters</h4> <pre>public&nbsp;void&nbsp;setSSLParameters(<a href="../../../javax/net/ssl/SSLParameters.html" title="class in javax.net.ssl">SSLParameters</a>&nbsp;params)</pre> 
        <div class="block" data-fanyi="1">
          适用于sslparameters这个引擎。 
         <p data-fanyi="1">这意味着：</p> 
         <ul data-fanyi="1"> 
          <li data-fanyi="1">如果<code>params.getCipherSuites()</code>非空，<code>setEnabledCipherSuites()</code>叫做价值。</li> 
          <li data-fanyi="1">如果<code>params.getProtocols()</code>非空，<code>setEnabledProtocols()</code>叫做价值。</li> 
          <li data-fanyi="1">如果<code>params.getNeedClientAuth()</code>或<code>params.getWantClientAuth()</code>返回<code>true</code>，<code>setNeedClientAuth(true)</code>和<code>setWantClientAuth(true)</code>称，分别称为；否则<code>setWantClientAuth(false)</code>。</li> 
          <li data-fanyi="1">如果<code>params.getServerNames()</code>非空，发动机将与价值配置的服务器名称。</li> 
          <li data-fanyi="1">如果<code>params.getSNIMatchers()</code>非空，发动机将与价值配置SNI的匹配。</li> 
         </ul> 
        </div> 
        <dl> 
         <dt> 
          <span class="paramLabel">参数</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code>params</code> -参数 
         </dd> 
         <dt> 
          <span class="throwsLabel">异常</span> 
         </dt> 
         <dd data-fanyi="1"> 
          <code><a href="../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> -如果setenabledciphersuites()或setenabledprotocols()调用失败 
         </dd> 
         <dt> 
          <span class="simpleTagLabel">从以下版本开始：</span> 
         </dt> 
         <dd data-fanyi="1">
           一点六 
         </dd> 
        </dl> </li> 
      </ul> </li> 
    </ul> </li> 
  </ul> 
 </div> 
</div> 
<!-- ========= END OF CLASS DATA ========= --> 
<!-- ======= START OF BOTTOM NAVBAR ====== --> 
<div class="bottomNav"> 
 <a name="navbar.bottom"> 
  <!--   --> </a> 
 <div class="skipNav"> 
  <a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a> 
 </div> 
 <a name="navbar.bottom.firstrow"> 
  <!--   --> </a> 
 <ul class="navList" title="Navigation"> 
  <li><a href="../../../overview-summary.html">概述</a></li> 
  <li><a href="package-summary.html">软件包</a></li> 
  <li class="navBarCell1Rev">类</li> 
  <li><a href="class-use/SSLEngine.html">使用</a></li> 
  <li><a href="package-tree.html">树</a></li> 
  <li><a href="../../../deprecated-list.html">已过时的</a></li> 
  <li><a href="../../../index-files/index-1.html">索引</a></li> 
  <li><a href="../../../help-doc.html">帮助</a></li> 
 </ul> 
 <div class="aboutLanguage"> 
  <strong>Java™&nbsp;Platform<br>Standard&nbsp;Ed.&nbsp;8</strong> 
 </div> 
</div> 
<div class="subNav"> 
 <ul class="navList"> 
  <li><a href="../../../javax/net/ssl/SSLContextSpi.html" title="class in javax.net.ssl"><span class="typeNameLink">上一个</span></a></li> 
  <li><a href="../../../javax/net/ssl/SSLEngineResult.html" title="class in javax.net.ssl"><span class="typeNameLink">下一个</span></a></li> 
 </ul> 
 <ul class="navList"> 
  <li><a href="../../../index.html?javax/net/ssl/SSLEngine.html" target="_top">框架</a></li> 
  <li><a href="SSLEngine.html" target="_top">无框架</a></li> 
 </ul> 
 <ul class="navList" id="allclasses_navbar_bottom"> 
  <li><a href="../../../allclasses-noframe.html">所有类</a></li> 
 </ul> 
 <div> 
  <script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script> 
 </div> 
 <div> 
  <ul class="subNavList"> 
   <li>概要：</li> 
   <li>嵌套</li> 
   <li>字段</li> 
   <li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li> 
   <li><a href="#method.summary">方法</a></li> 
  </ul> 
  <ul class="subNavList"> 
   <li>详细信息：</li> 
   <li>字段</li> 
   <li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li> 
   <li><a href="#method.detail">方法</a></li> 
  </ul> 
 </div> 
 <a name="skip.navbar.bottom"> 
  <!--   --> </a> 
</div> 
<!-- ======== END OF BOTTOM NAVBAR ======= --> 
<p class="legalCopy"><small><font size="-1"> <a href="http://bugreport.sun.com/bugreport/">Submit a bug or feature</a> <br>For further API reference and developer documentation, see <a href="http://download.oracle.com/javase/8/docs/index.html" target="_blank">Java SE Documentation</a>. That documentation contains more detailed, developer-targeted descriptions, with conceptual overviews, definitions of terms, workarounds, and working code examples.<br> Copyright © 1993, 2014, Oracle and/or its affiliates. All rights reserved. </font></small> </p> 
<div id="adDiv"> 


 <div></div> 
</div> 
<p></p>