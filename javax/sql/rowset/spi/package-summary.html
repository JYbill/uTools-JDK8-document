<!-- NewPage -->   
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<!-- Generated by javadoc (1.8.0) on Tue Mar 04 03:13:27 PST 2014 --> 
<title>javax.sql.rowset.spi (Java Platform SE 8 )</title> 
<meta name="date" content="2014-03-04"> 
<meta name="keywords" content="javax.sql.rowset.spi package"> 
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style"> 
<script type="text/javascript" src="../../../../script.js"></script> 
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="javax.sql.rowset.spi (Java Platform SE 8 )";
        }
    }
    catch(err) {
    }
//-->
</script> 
<noscript>
  &lt;div&gt; JavaScript is disabled on your browser. 
</noscript> 
<!-- ========= START OF TOP NAVBAR ======= -->   
<div class="topNav"> 
 <a name="navbar.top"> 
  <!--   --> </a> 
 <div class="skipNav"> 
  <a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a> 
 </div> 
 <a name="navbar.top.firstrow"> 
  <!--   --> </a> 
 <ul class="navList" title="Navigation"> 
  <li><a href="../../../../overview-summary.html">概述</a></li> 
  <li class="navBarCell1Rev">软件包</li> 
  <li>类</li> 
  <li><a href="package-use.html">使用</a></li> 
  <li><a href="package-tree.html">树</a></li> 
  <li><a href="../../../../deprecated-list.html">已过时的</a></li> 
  <li><a href="../../../../index-files/index-1.html">索引</a></li> 
  <li><a href="../../../../help-doc.html">帮助</a></li> 
 </ul> 
 <div class="aboutLanguage"> 
  <strong>Java™&nbsp;Platform<br>Standard&nbsp;Ed.&nbsp;8</strong> 
 </div> 
</div> 
<div class="subNav"> 
 <ul class="navList"> 
  <li><a href="../../../../javax/sql/rowset/serial/package-summary.html">Prev&nbsp;Package</a></li> 
  <li><a href="../../../../javax/swing/package-summary.html">Next&nbsp;Package</a></li> 
 </ul> 
 <ul class="navList"> 
  <li><a href="../../../../index.html?javax/sql/rowset/spi/package-summary.html" target="_top">框架</a></li> 
  <li><a href="package-summary.html" target="_top">无框架</a></li> 
 </ul> 
 <ul class="navList" id="allclasses_navbar_top"> 
  <li><a href="../../../../allclasses-noframe.html">所有类</a></li> 
 </ul> 
 <div> 
  <script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script> 
 </div> 
 <a name="skip.navbar.top"> 
  <!--   --> </a> 
</div> 
<!-- ========= END OF TOP NAVBAR ========= --> 
<div class="header"> 
 <h1 title="Package" class="title">Package&nbsp;javax.sql.rowset.spi</h1> 
 <div class="docSummary"> 
  <div class="block" data-fanyi="1">
    三分之一方供应商在其执行同步提供程序中使用的标准类和接口。 
  </div> 
 </div> 
 <p>See:&nbsp;<a href="#package.description">描述</a></p> 
</div> 
<div class="contentContainer"> 
 <ul class="blockList"> 
  <li class="blockList"> 
   <table class="typeSummary" border="0" cellpadding="3" cellspacing="0" summary="Interface Summary table, listing interfaces, and an explanation"> 
    <caption> 
     <span>接口摘要</span> 
     <span class="tabEnd">&nbsp;</span> 
    </caption> 
    <tbody> 
     <tr> 
      <th class="colFirst" scope="col">接口</th> 
      <th class="colLast" scope="col">描述</th> 
     </tr> 
    </tbody> 
    <tbody> 
     <tr class="altColor"> 
      <td class="colFirst"><a href="../../../../javax/sql/rowset/spi/SyncResolver.html" title="interface in javax.sql.rowset.spi">SyncResolver</a></td> 
      <td class="colLast"> 
       <div class="block" data-fanyi="1">
         定义一个框架，允许应用程序使用一个手动决策树来决定在发生同步冲突时应该做什么。 
       </div> </td> 
     </tr> 
     <tr class="rowColor"> 
      <td class="colFirst"><a href="../../../../javax/sql/rowset/spi/TransactionalWriter.html" title="interface in javax.sql.rowset.spi">TransactionalWriter</a></td> 
      <td class="colLast"> 
       <div class="block" data-fanyi="1">
         一个专门的接口，便于标准 
        <code>SyncProvider</code>抽象类的扩展使其具有更细粒度的事务控制。 
       </div> </td> 
     </tr> 
     <tr class="altColor"> 
      <td class="colFirst"><a href="../../../../javax/sql/rowset/spi/XmlReader.html" title="interface in javax.sql.rowset.spi">XmlReader</a></td> 
      <td class="colLast"> 
       <div class="block" data-fanyi="1">
         一个专门的接口，方便了XML的 
        <code>SyncProvider</code>抽象类的扩展型同步提供者。 
       </div> </td> 
     </tr> 
     <tr class="rowColor"> 
      <td class="colFirst"><a href="../../../../javax/sql/rowset/spi/XmlWriter.html" title="interface in javax.sql.rowset.spi">XmlWriter</a></td> 
      <td class="colLast"> 
       <div class="block" data-fanyi="1">
         一个专门的接口，方便了XML的 
        <code>SyncProvider</code>抽象类的扩展型同步提供者。 
       </div> </td> 
     </tr> 
    </tbody> 
   </table> </li> 
  <li class="blockList"> 
   <table class="typeSummary" border="0" cellpadding="3" cellspacing="0" summary="Class Summary table, listing classes, and an explanation"> 
    <caption> 
     <span>类摘要</span> 
     <span class="tabEnd">&nbsp;</span> 
    </caption> 
    <tbody> 
     <tr> 
      <th class="colFirst" scope="col">类</th> 
      <th class="colLast" scope="col">描述</th> 
     </tr> 
    </tbody> 
    <tbody> 
     <tr class="altColor"> 
      <td class="colFirst"><a href="../../../../javax/sql/rowset/spi/SyncFactory.html" title="class in javax.sql.rowset.spi">SyncFactory</a></td> 
      <td class="colLast"> 
       <div class="block" data-fanyi="1">
         服务提供者接口（SPI）机制产生 
        <code>SyncProvider</code>实例被断开 
        <code>RowSet</code>对象使用。 
       </div> </td> 
     </tr> 
     <tr class="rowColor"> 
      <td class="colFirst"><a href="../../../../javax/sql/rowset/spi/SyncProvider.html" title="class in javax.sql.rowset.spi">SyncProvider</a></td> 
      <td class="colLast"> 
       <div class="block" data-fanyi="1">
         同步机制，断开 
        <code>RowSet</code>对象提供读/写能力。 
       </div> </td> 
     </tr> 
    </tbody> 
   </table> </li> 
  <li class="blockList"> 
   <table class="typeSummary" border="0" cellpadding="3" cellspacing="0" summary="Exception Summary table, listing exceptions, and an explanation"> 
    <caption> 
     <span>异常摘要</span> 
     <span class="tabEnd">&nbsp;</span> 
    </caption> 
    <tbody> 
     <tr> 
      <th class="colFirst" scope="col">异常</th> 
      <th class="colLast" scope="col">描述</th> 
     </tr> 
    </tbody> 
    <tbody> 
     <tr class="altColor"> 
      <td class="colFirst"><a href="../../../../javax/sql/rowset/spi/SyncFactoryException.html" title="class in javax.sql.rowset.spi">SyncFactoryException</a></td> 
      <td class="colLast"> 
       <div class="block" data-fanyi="1">
         表示错误与 
        <code>SyncFactory</code>机制。 
       </div> </td> 
     </tr> 
     <tr class="rowColor"> 
      <td class="colFirst"><a href="../../../../javax/sql/rowset/spi/SyncProviderException.html" title="class in javax.sql.rowset.spi">SyncProviderException</a></td> 
      <td class="colLast"> 
       <div class="block" data-fanyi="1">
         表明一个错误的 
        <code>SyncProvider</code>机制。 
       </div> </td> 
     </tr> 
    </tbody> 
   </table> </li> 
 </ul> 
 <a name="package.description"> 
  <!--   --> </a> 
 <h2 title="Package javax.sql.rowset.spi Description">Package javax.sql.rowset.spi Description</h2> 
 <div class="block" data-fanyi="1">
   三分之一方供应商在其执行同步提供程序中使用的标准类和接口。这些类和接口被称为服务提供者接口（SPI）。一个供应商可能实施包括JDBC的网页，列出可用的 
  <code>SyncProvider</code>实现发送电子邮件 
  <code>jdbc@sun.com</code>。这样做有助于使开发商意识到实施。使一个 
  <code>RowSet</code>对象使用的一个实现，供应商必须与 
  <code>SyncFactory</code>独生子女登记。（看到一个完整的解释的注册过程和命名约定来使用。 
  <code>SyncProvider</code>类评论） 
  <p data-fanyi="1"></p> 
  <h2 data-fanyi="1">表的内容</h2> 
  <ul data-fanyi="1"> 
   <li data-fanyi="1"><a href="#pkgspec">1.0 Package Specification</a></li> 
   <li data-fanyi="1"><a href="#arch">2.0 Service Provider Architecture</a></li> 
   <li data-fanyi="1"><a href="#impl">3.0 Implementer's Guide</a></li> 
   <li data-fanyi="1"><a href="#resolving">4.0 Resolving Synchronization Conflicts</a></li> 
   <li data-fanyi="1"><a href="#relspec">5.0 Related Specifications</a></li> 
   <li data-fanyi="1"><a href="#reldocs">6.0 Related Documentation</a></li> 
  </ul> 
  <h3 data-fanyi="1"><a name="pkgspec">1.0 Package Specification</a></h3> 
  <a name="pkgspec"> <p> The following classes and interfaces make up the <code>javax.sql.rowset.spi</code> package: </p> 
   <ul> 
    <li><code>SyncFactory</code> </li> 
    <li><code>SyncProvider</code> </li> 
    <li><code>SyncFactoryException</code> </li> 
    <li><code>SyncProviderException</code> </li> 
    <li><code>SyncResolver</code> </li> 
    <li><code>XmlReader</code> </li> 
    <li><code>XmlWriter</code> </li> 
    <li><code>TransactionalWriter</code> </li> 
   </ul> The following interfaces, in the <code>javax.sql</code> package, are also part of the SPI: 
   <ul> 
    <li><code>RowSetReader</code> </li> 
    <li><code>RowSetWriter</code> </li> 
   </ul> <p> A <code>SyncProvider</code> implementation provides a disconnected <code>RowSet</code> object with the mechanisms for reading data into it and for writing data that has been modified in it back to the underlying data source. A <i>reader</i>, a <code>RowSetReader</code> or <code>XMLReader</code> object, reads data into a <code>RowSet</code> object when the <code>CachedRowSet</code> methods <code>execute</code> or <code>populate</code> are called. A <i>writer</i>, a <code>RowSetWriter</code> or <code>XMLWriter</code> object, writes changes back to the underlying data source when the <code>CachedRowSet</code> method <code>acceptChanges</code> is called. </p><p> The process of writing changes in a <code>RowSet</code> object to its data source is known as <i>synchronization</i>. The <code>SyncProvider</code> implementation that a <code>RowSet</code> object is using determines the level of synchronization that the <code>RowSet</code> object's writer uses. The various levels of synchronization are referred to as <i>grades</i>. </p><p> The lower grades of synchronization are known as <i>optimistic</i> concurrency levels because they optimistically assume that there will be no conflicts or very few conflicts. A conflict exists when the same data modified in the <code>RowSet</code> object has also been modified in the data source. Using the optimistic concurrency model means that if there is a conflict, modifications to either the data source or the <code>RowSet</code> object will be lost. </p><p> Higher grades of synchronization are called <i>pessimistic</i> because they assume that others will be accessing the data source and making modifications. These grades set varying levels of locks to increase the chances that no conflicts occur. </p><p> The lowest level of synchronization is simply writing any changes made to the <code>RowSet</code> object to its underlying data source. The writer does nothing to check for conflicts. If there is a conflict and the data source values are overwritten, the changes other parties have made by to the data source are lost. </p><p> The <code>RIXMLProvider</code> implementation uses the lowest level of synchronization and just writes <code>RowSet</code> changes to the data source. This is true because typically XML data sources do not enable transaction techniques for maintaining the integrity of data. However, specific standards groups have considered offering XML-based synchronization. For details, see </p></a> 
  <pre data-fanyi="1"><a name="pkgspec">
     </a><a href="http://www.syncml.org">http://www.syncml.org</a></pre> 
  <p data-fanyi="1">对于下一个层次，作家检查，看看是否有任何冲突，如果有，它不写任何东西给数据源。这种并发的问题是，如果另一方已经修改了相应的数据源中的数据由于<code>RowSet</code>对象获得的数据，对<code>RowSet</code>对象的更改都将丢失。的<code>RIOptimisticProvider</code>实现使用这一级别的同步。</p> 
  <p data-fanyi="1">在更高级别的同步，被称为悲观的并发性，笔者采取步骤，以避免冲突，通过设置锁。设置锁可以在单行上设置一个锁定，以设置一个表或整个数据源的锁。同步的水平，因此是一个折衷的用户同时访问数据源的能力和作家的能力来保持数据的<code>RowSet</code>对象和数据源同步。</p> 
  <p data-fanyi="1">这是一个要求所有断开的<code>RowSet</code>对象（<code>CachedRowSet</code>，<code>FilteredRowSet</code>，<code>JoinRowSet</code>，和<code>WebRowSet</code>对象）从<code>SyncFactory</code>机制获得<code>SyncProvider</code>对象。</p> 
  <p data-fanyi="1">参考实现（RI）提供了两个同步提供者。</p> 
  <ul data-fanyi="1"> 
   <li data-fanyi="1"><b data-fanyi="1"><tt>RIOptimisticProvider</tt></b> <br data-fanyi="1">默认提供程序，<code>SyncFactory</code>实例将电源断开<code>RowSet</code>对象时没有提供实现specified.<br data-fanyi="1">同步提供者使用乐观并发模型，假设会有谁是在数据库中访问相同的数据用户之间的一些冲突。它避免了使用锁；相反，它检查是否有在试图同步<code>RowSet</code>对象和数据源的冲突。如果有一个冲突，这没意义，对<code>RowSet</code>对象的更改不会保存到数据源。</li> 
   <li data-fanyi="1"><b data-fanyi="1"><tt>RIXMLProvider</tt></b> <br data-fanyi="1">同步提供程序，可以用一个<code>WebRowSet</code>对象，这是一个数据集，可以用XML格式或XML格式读取。实施的<code>RIXMLProvider</code>不检查在所有的冲突，只是写了任何更新的数据在<code>WebRowSet</code>对象基础数据源。<code>WebRowSet</code>对象使用此提供程序在处理XML数据。</li> 
  </ul>这些 
  <code>SyncProvider</code>实现捆绑的参考实现，这使得他们总是可以 
  <code>RowSet</code>实现。 
  <code>SyncProvider</code>实现使自己可以通过和 
  <code>SyncFactory</code>单独注册。当一个 
  <code>RowSet</code>对象请求的供应商，通过指定它在构造函数或作为参数的方法的 
  <code>CachedRowSet</code> 
  <code>setSyncProvider</code>， 
  <code>SyncFactory</code>单检查是否要求供应商已注册了。如果有，那 
  <code>SyncFactory</code>创建它的实例并将其传递给请求 
  <code>RowSet</code>对象。如果 
  <code>SyncProvider</code>实现指定尚未注册， 
  <code>SyncFactory</code>独生子女的原因 
  <code>SyncFactoryException</code>对象被。如果没有指定的供应商， 
  <code>SyncFactory</code>单将创建默认的提供程序实现， 
  <code>RIOptimisticProvider</code>实例，并把它传递给请求 
  <code>RowSet</code>对象。 
  <p data-fanyi="1">如果不指定<code>WebRowSet</code>对象的构造函数中的供应商，<code>SyncFactory</code>会给<code>RIOptimisticProvider</code>实例。然而，对于<code>WebRowSet</code>构造函数来设置供应商的<code>RIXMLProvider</code>，读和写在XML格式的<code>RowSet</code>对象。</p> 
  <p data-fanyi="1">详情见<a href="SyncProvider.html">SyncProvider</a>类规范。</p> 
  <p data-fanyi="1">供应商可能发展同步的水平可能有<tt>SyncProvider</tt>实施，从而<code>RowSet</code>对象选择的同步机制。供应商可以通过与甲骨文公司在<code>jdbc@sun.com</code>注册完全限定名称使其实现有效。这个过程将在下面进一步详细讨论。</p> 
  <p data-fanyi="1"><a name="arch"></a></p> 
  <h3 data-fanyi="1"><a name="arch">2.0 Service Provider Interface Architecture</a></h3> 
  <a name="arch"> </a> 
  <ul data-fanyi="1"> 
   <a name="arch"> <b>2.1 Overview</b> <p> The Service Provider Interface provides a pluggable mechanism by which <code>SyncProvider</code> implementations can be registered and then generated when required. The lazy reference mechanism employed by the <code>SyncFactory</code> limits unnecessary resource consumption by not creating an instance until it is required by a disconnected <code>RowSet</code> object. The <code>SyncFactory</code> class also provides a standard API to configure logging options and streams that <b>may</b> be provided by a particular <code>SyncProvider</code> implementation. </p><p> <b>2.2 Registering with the <code>SyncFactory</code></b> </p><p> A third party <code>SyncProvider</code> implementation must be registered with the <code>SyncFactory</code> in order for a disconnected <code>RowSet</code> object to obtain it and thereby use its <code>javax.sql.RowSetReader</code> and <code>javax.sql.RowSetWriter</code> implementations. The following registration mechanisms are available to all <code>SyncProvider</code> implementations: </p> </a> 
   <ul data-fanyi="1"> 
    <a name="arch"> </a> 
    <li><a name="arch"><b>System properties</b> - Properties set at the command line. These properties are set at run time and apply system-wide per invocation of the Java application. See the section </a><a href="#reldocs">"Related Documentation"</a> further related information. <p> </p></li> 
    <li data-fanyi="1"><b data-fanyi="1">属性文件</b> -在一个标准的属性文件中指定的属性。这可以使用一个系统属性或修改一个位于平台运行时的标准属性文件来指定。这一技术的参考实现，包括一个标准的属性文件可以编辑添加额外的<code>SyncProvider</code>对象。<p data-fanyi="1"></p></li> 
    <li data-fanyi="1"><b data-fanyi="1">JNDI环境</b>可用的供应商可以在JNDI上下文注册。的<tt>SyncFactory</tt>将尝试加载<tt>SyncProvider</tt>对象绑定到上下文和登记他们的工厂。这种情况下必须提供给<code>SyncFactory</code>为正确的工作机制。</li> 
   </ul> 
   <p data-fanyi="1">有关如何指定一个属性文件系统属性或属性以及如何配置JNDI上下文在<a href="SyncFactory.html"><code>SyncFactory</code></a>类描述详细解释。</p> 
   <p data-fanyi="1"><b data-fanyi="1">2.3 syncfactory提供者实例生成策略</b></p> 
   <p data-fanyi="1">的<code>SyncFactory</code>生成一个请求<code>SyncProvider</code>对象如果提供者已正确注册。以下政策时坚持一个断开的<code>RowSet</code>对象实例化时使用指定的<code>SyncProvider</code>实施或重新配置在一个<code>SyncProvider</code>对象运行。</p> 
   <ul data-fanyi="1"> 
    <li data-fanyi="1">如果一个<code>SyncProvider</code>对象是指定和<code>SyncFactory</code>包含供应商不参考，一<code>SyncFactoryException</code>抛出。<p data-fanyi="1"></p></li> 
    <li data-fanyi="1">如果一个<code>SyncProvider</code>对象是指定和<code>SyncFactory</code>包含引用的供应商，要求供应商提供。<p data-fanyi="1"></p></li> 
    <li data-fanyi="1">如果没有<code>SyncProvider</code>对象指定，提供参考实现供应商<code>RIOptimisticProvider</code>。</li> 
   </ul> 
   <p data-fanyi="1">这些政策进行了更详细的<a href="SyncFactory.html"> <code>SyncFactory</code></a>类。</p> 
  </ul> 
  <li data-fanyi="1"><a name="impl"><h3>3.0 SyncProvider Implementer's Guide</h3> </a> 
   <ul data-fanyi="1"> 
    <a name="impl"> <b>3.1 Requirements</b> </a> 
    <p data-fanyi="1"><a name="impl"> A compliant <code>SyncProvider</code> implementation that is fully pluggable into the <code>SyncFactory</code> <b>must</b> extend and implement all abstract methods in the </a><a href="SyncProvider.html"><code>SyncProvider</code></a>类。此外，实施<b data-fanyi="1">必须</b>确定等级，在类定义中定义<code>SyncProvider</code>锁定和可更新视图的能力。一个或一个以上的<code>SyncProvider</code>描述标准<b data-fanyi="1">必须</b>支持。预计供应商实现将提供一系列的等级，锁定，并可更新视图的能力。</p> 
    <p data-fanyi="1">此外，该<code>SyncProvider</code>命名约定<b data-fanyi="1">必须</b>随后在<a href="SyncProvider.html"><code>SyncProvider</code></a>类描述详细。</p> 
    <p data-fanyi="1"><b data-fanyi="1">3.2个等级</b></p> 
    <p data-fanyi="1">JSR 114中定义的同步<code>SyncProvider</code>对象可以提供一个断开的<code>RowSet</code>物体质量的等级设置。这些成绩都列出从最低的服务质量到最高。</p> 
    <ul data-fanyi="1"> 
     <li data-fanyi="1"><b data-fanyi="1">grade_none</b>与原始数据源没有同步设置。一个<code>SyncProvider</code>实现返回这个等级会尝试写任何数据，在<code>RowSet</code>对象改为基础数据源，无论是在覆盖。没有尝试将原始值与当前值进行比较，以查看是否存在冲突。是的<code>RIXMLProvider</code>这个年级实施。<p data-fanyi="1"></p></li> 
     <li data-fanyi="1"><b data-fanyi="1">grade_check_modified_at_commit</b> -一个低年级的乐观同步。一个<code>SyncProvider</code>实现返回这个档次的检查，最后的同步方式下电流同步更改的行的冲突。在原始数据源已被修改的任何更改将不会反映在断开<code>RowSet</code>对象。如果没有冲突，在<code>RowSet</code>对象的更改将被写入到数据源。如果有冲突，没有任何变化是书面的。的<code>RIOptimisticProvider</code>实现使用这种等级。<p data-fanyi="1"></p></li> 
     <li data-fanyi="1"><b data-fanyi="1">grade_check_all_at_commit</b> -一个高品位的乐观同步。一个<code>SyncProvider</code>实现返回这个年级将检查所有的行，包括未在断开<code>RowSet</code>对象更改的行。这样，在基础数据源行的任何变更将反映在断开<code>RowSet</code>对象当同步成功完成。<p data-fanyi="1"></p></li> 
     <li data-fanyi="1"><b data-fanyi="1">grade_lock_when_modified</b> -悲观级同步。<code>SyncProvider</code>实现返回这个等级将锁定排在原始数据源对应的排在<code>RowSet</code>对象改变的可能性减少其他进程的数据源中的修改相同的数据。<p data-fanyi="1"></p></li> 
     <li data-fanyi="1"><b data-fanyi="1">grade_lock_when_loaded</b>更悲观的同步年级。一个<code>SyncProvider</code>实现返回这个级别将锁定整个表的查看和/或用来填充<code>RowSet</code>对象原始查询的影响。</li> 
    </ul> 
    <p data-fanyi="1"><b data-fanyi="1">3.3把锁</b></p> 
    <p data-fanyi="1">JSR 114定义了一组常量指定的任何锁是否已被放置在一个<code>RowSet</code>对象的基础数据源，如果是这样，在构建锁放置。这些锁将保持数据源而<code>RowSet</code>对象从数据源断开。</p> 
    <p data-fanyi="1">这些常数<b data-fanyi="1">应该</b>被认为等级常数互补。对于大多数等级设置的默认设置，不需要数据源时保持一个<code>RowSet</code>锁对象从数据源断开。成绩<code>GRADE_LOCK_WHEN_MODIFIED</code>和<code>GRADE_LOCK_WHEN_LOADED</code>允许断开连接的<code>RowSet</code>对象来锁定程度的细粒度的控制。</p> 
    <ul data-fanyi="1"> 
     <li data-fanyi="1"><b data-fanyi="1">datasource_no_lock</b>没有锁保持原始数据源。这是默认的锁定所有<code>SyncProvider</code>实现设置，除非有<code>RowSet</code>对象。<p data-fanyi="1"></p></li> 
     <li data-fanyi="1"><b data-fanyi="1">datasource_row_lock</b> -锁放置在被用来填充<code>RowSet</code>对象原始SQL查询摸排。<p data-fanyi="1"></p></li> 
     <li data-fanyi="1"><b data-fanyi="1">datasource_table_lock</b> -锁放置在所有表的查询，用于填充<code>RowSet</code>对象感动。<p data-fanyi="1"></p></li> 
     <li data-fanyi="1"><b data-fanyi="1">datasource_db_lock</b>锁上放置的<code>RowSet</code>对象使用整个数据源。</li> 
    </ul> 
    <p data-fanyi="1"><b data-fanyi="1">3.4可更新的视图</b></p> 
    <p data-fanyi="1">一个<code>RowSet</code>对象可能从一个SQL <code>VIEW</code>数据。以下常量指示<code>SyncProvider</code>对象可以更新表中的数据或图表，进而得到了<code>VIEW</code>。</p> 
    <ul data-fanyi="1"> 
     <li data-fanyi="1"><b data-fanyi="1">updatable_view_sync</b>表明<code>SyncProvider</code>实现支持同步表或表的SQL <code>VIEW</code>用来填充一一<code>RowSet</code>对象派生。<p data-fanyi="1"></p></li> 
     <li data-fanyi="1"><b data-fanyi="1">nonupdatable_view_sync</b>表明<code>SyncProvider</code>不实现<b data-fanyi="1">不</b>支持同步的表，用来填充<code>RowSet</code>对象派生的SQL <code>VIEW</code>。</li> 
    </ul> 
    <p data-fanyi="1"><b data-fanyi="1">3.5使用<code>SyncProvider</code>分级和锁定</b></p> 
    <p data-fanyi="1">在下面的例子中，参考<tt>CachedRowSetImpl</tt>实现将其目前的<tt>SyncProvider</tt>对象通过调用<tt>setSyncProvider</tt> method.<br data-fanyi="1"></p> 
    <pre data-fanyi="1">CachedRowSetImpl CRS =新cachedrowsetimpl()；CRS。setsyncprovider（“com. foo。酒吧。HASyncProvider）；</pre>应用目前可以使用断开连接的z-025d5186-1a检索 
    <tt>SyncProvider</tt>对象6d-4850-8f2c-4aded90dcbc4对象。它还可以检索提供程序实现的同步级别和当前使用的锁定程度。此外，一个应用程序具有的灵活性，以设置锁定的程度被使用，这可以增加成功的同步的可能性。这些操作显示在下面的代码片段中。 
    <pre data-fanyi="1">syncprovider同步= getsyncprovider() CRS；开关（同步。getprovidergrade()）{案例：syncprovider.grade_check_all_at_commit高等级的乐观同步打破；案例：syncprovider.grade_check_modified_at_commit低级别的乐观同步打破；案例：syncprovider.grade_lock_when_loaded一个悲观的同步级打破；案例：syncprovider.grade_lock_when_modified一个悲观的同步级打破；案例：syncprovider.grade_none与提供的原始数据源不同步打破；}开关（同步。getdatasourclock() {案例：syncprovider.datasource_db_lock/ /锁放置在整个数据源所使用的/ / <code>RowSet</code>对象打破；案例：syncprovider.datasource_no_lock没有锁保持在原始数据源上。打破；案例：syncprovider.datasource_row_lock将锁放在被原始的行上的行上/ / SQL语句用来填充/ /那是用syncprovider行集对象打破；案例：datasource_table_lock一把锁放在被触动的所有的桌子上/ / SQL语句用来填充/ /那是用syncprovider行集对象打破；</pre>也可以使用静态的实用方法在 
    <code>SyncFactory</code>类确定 
    <code>SyncProvider</code>实现目前注册的 
    <code>SyncFactory</code>列表。 
    <pre data-fanyi="1">E = syncfactory getregisteredproviders()枚举；</pre> 
   </ul> <h3 data-fanyi="1"><a name="resolving">4.0 Resolving Synchronization Conflicts</a></h3><a name="resolving"> The interface <code>SyncResolver</code> provides a way for an application to decide manually what to do when a conflict occurs. When the <code>CachedRowSet</code> method <code>acceptChanges</code> finishes and has detected one or more conflicts, it throws a <code>SyncProviderException</code> object. An application can catch the exception and have it retrieve a <code>SyncResolver</code> object by calling the method <code>SyncProviderException.getSyncResolver()</code>. <p> A <code>SyncResolver</code> object, which is a special kind of <code>CachedRowSet</code> object or a <code>JdbcRowSet</code> object that has implemented the <code>SyncResolver</code> interface, examines the conflicts row by row. It is a duplicate of the <code>RowSet</code> object being synchronized except that it contains only the data from the data source this is causing a conflict. All of the other column values are set to <code>null</code>. To navigate from one conflict value to another, a <code>SyncResolver</code> object provides the methods <code>nextConflict</code> and <code>previousConflict</code>. </p><p> The <code>SyncResolver</code> interface also provides methods for doing the following: </p> 
    <ul> 
     <li>finding out whether the conflict involved an update, a delete, or an insert </li> 
     <li>getting the value in the data source that caused the conflict </li> 
     <li>setting the value that should be in the data source if it needs to be changed or setting the value that should be in the <code>RowSet</code> object if it needs to be changed </li> 
    </ul> <p> When the <code>CachedRowSet</code> method <code>acceptChanges</code> is called, it delegates to the <code>RowSet</code> object's <code>SyncProvider</code> object. How the writer provided by that <code>SyncProvider</code> object is implemented determines what level (grade) of checking for conflicts will be done. After all checking for conflicts is completed and one or more conflicts has been found, the method <code>acceptChanges</code> throws a <code>SyncProviderException</code> object. The application can catch the exception and use it to obtain a <code>SyncResolver</code> object. </p><p> The application can then use <code>SyncResolver</code> methods to get information about each conflict and decide what to do. If the application logic or the user decides that a value in the <code>RowSet</code> object should be the one to persist, the application or user can overwrite the data source value with it. </p></a><p data-fanyi="1"><a name="resolving"> The comment for the <code>SyncResolver</code> interface has more detail. </a><a name="relspec"></a></p><h3 data-fanyi="1"><a name="relspec">5.0 Related Specifications</a></h3><a name="relspec"> </a> 
   <ul data-fanyi="1"> 
    <a name="relspec"> </a> 
    <li data-fanyi="1"><a name="relspec"></a><a href="http://java.sun.com/products/jndi">JNDI 1.3</a></li> 
    <li data-fanyi="1"><a href="../../../../../technotes/guides/logging/index.html">Java Logging APIs</a></li> 
   </ul> <a name="reldocs"><h3>6.0 Related Documentation</h3> </a> 
   <ul data-fanyi="1"> 
    <a name="reldocs"> </a> 
    <li data-fanyi="1"><a name="reldocs"></a><a href="../../../../../technotes/tools/index.html#basic">System properties</a></li> 
    <li data-fanyi="1">资源文件</li> 
    <li data-fanyi="1"><a href="http://java.sun.com/tutorial/jdbc">DataSource for JDBC Connections</a></li> 
   </ul></li> 
 </div> 
</div> 
<!-- ======= START OF BOTTOM NAVBAR ====== --> 
<div class="bottomNav"> 
 <a name="navbar.bottom"> 
  <!--   --> </a> 
 <div class="skipNav"> 
  <a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a> 
 </div> 
 <a name="navbar.bottom.firstrow"> 
  <!--   --> </a> 
 <ul class="navList" title="Navigation"> 
  <li><a href="../../../../overview-summary.html">概述</a></li> 
  <li class="navBarCell1Rev">软件包</li> 
  <li>类</li> 
  <li><a href="package-use.html">使用</a></li> 
  <li><a href="package-tree.html">树</a></li> 
  <li><a href="../../../../deprecated-list.html">已过时的</a></li> 
  <li><a href="../../../../index-files/index-1.html">索引</a></li> 
  <li><a href="../../../../help-doc.html">帮助</a></li> 
 </ul> 
 <div class="aboutLanguage"> 
  <strong>Java™&nbsp;Platform<br>Standard&nbsp;Ed.&nbsp;8</strong> 
 </div> 
</div> 
<div class="subNav"> 
 <ul class="navList"> 
  <li><a href="../../../../javax/sql/rowset/serial/package-summary.html">Prev&nbsp;Package</a></li> 
  <li><a href="../../../../javax/swing/package-summary.html">Next&nbsp;Package</a></li> 
 </ul> 
 <ul class="navList"> 
  <li><a href="../../../../index.html?javax/sql/rowset/spi/package-summary.html" target="_top">框架</a></li> 
  <li><a href="package-summary.html" target="_top">无框架</a></li> 
 </ul> 
 <ul class="navList" id="allclasses_navbar_bottom"> 
  <li><a href="../../../../allclasses-noframe.html">所有类</a></li> 
 </ul> 
 <div> 
  <script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script> 
 </div> 
 <a name="skip.navbar.bottom"> 
  <!--   --> </a> 
</div> 
<!-- ======== END OF BOTTOM NAVBAR ======= --> 
<p class="legalCopy"><small><font size="-1"> <a href="http://bugreport.sun.com/bugreport/">Submit a bug or feature</a> <br>For further API reference and developer documentation, see <a href="http://download.oracle.com/javase/8/docs/index.html" target="_blank">Java SE Documentation</a>. That documentation contains more detailed, developer-targeted descriptions, with conceptual overviews, definitions of terms, workarounds, and working code examples.<br> Copyright © 1993, 2014, Oracle and/or its affiliates. All rights reserved. </font></small> </p> 
<div id="adDiv"> 


 <div></div> 
</div> 
<p></p>