<!-- NewPage -->   
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<!-- Generated by javadoc (1.8.0) on Tue Mar 04 03:12:53 PST 2014 --> 
<title>MXBean (Java Platform SE 8 )</title> 
<meta name="date" content="2014-03-04"> 
<meta name="keywords" content="javax.management.MXBean class"> 
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style"> 
<script type="text/javascript" src="../../script.js"></script> 
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="MXBean (Java Platform SE 8 )";
        }
    }
    catch(err) {
    }
//-->
</script> 
<noscript>
  &lt;div&gt; JavaScript is disabled on your browser. 
</noscript> 
<!-- ========= START OF TOP NAVBAR ======= -->   
<div class="topNav"> 
 <a name="navbar.top"> 
  <!--   --> </a> 
 <div class="skipNav"> 
  <a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a> 
 </div> 
 <a name="navbar.top.firstrow"> 
  <!--   --> </a> 
 <ul class="navList" title="Navigation"> 
  <li><a href="../../overview-summary.html">概述</a></li> 
  <li><a href="package-summary.html">软件包</a></li> 
  <li class="navBarCell1Rev">类</li> 
  <li><a href="class-use/MXBean.html">使用</a></li> 
  <li><a href="package-tree.html">树</a></li> 
  <li><a href="../../deprecated-list.html">已过时的</a></li> 
  <li><a href="../../index-files/index-1.html">索引</a></li> 
  <li><a href="../../help-doc.html">帮助</a></li> 
 </ul> 
 <div class="aboutLanguage"> 
  <strong>Java™&nbsp;Platform<br>Standard&nbsp;Ed.&nbsp;8</strong> 
 </div> 
</div> 
<div class="subNav"> 
 <ul class="navList"> 
  <li><a href="../../javax/management/MBeanTrustPermission.html" title="class in javax.management"><span class="typeNameLink">上一个</span></a></li> 
  <li><a href="../../javax/management/NotCompliantMBeanException.html" title="class in javax.management"><span class="typeNameLink">下一个</span></a></li> 
 </ul> 
 <ul class="navList"> 
  <li><a href="../../index.html?javax/management/MXBean.html" target="_top">框架</a></li> 
  <li><a href="MXBean.html" target="_top">无框架</a></li> 
 </ul> 
 <ul class="navList" id="allclasses_navbar_top"> 
  <li><a href="../../allclasses-noframe.html">所有类</a></li> 
 </ul> 
 <div> 
  <script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script> 
 </div> 
 <div> 
  <ul class="subNavList"> 
   <li>概要：</li> 
   <li>字段</li> 
   <li>Required&nbsp;|&nbsp;</li> 
   <li><a href="#annotation.type.optional.element.summary">Optional</a></li> 
  </ul> 
  <ul class="subNavList"> 
   <li>详细信息：</li> 
   <li>字段</li> 
   <li><a href="#annotation.type.element.detail">Element</a></li> 
  </ul> 
 </div> 
 <a name="skip.navbar.top"> 
  <!--   --> </a> 
</div> 
<!-- ========= END OF TOP NAVBAR ========= --> 
<!-- ======== START OF CLASS DATA ======== --> 
<div class="header"> 
 <div class="subTitle">
   javax.management 
 </div> 
 <h2 title="Annotation Type MXBean" class="title">Annotation Type MXBean</h2> 
</div> 
<div class="contentContainer"> 
 <div class="description"> 
  <ul class="blockList"> 
   <li class="blockList"> 
    <hr> <br> <pre><a href="../../java/lang/annotation/Documented.html" title="annotation in java.lang.annotation">@Documented</a>
 <a href="../../java/lang/annotation/Retention.html" title="annotation in java.lang.annotation">@Retention</a>(<a href="../../java/lang/annotation/Retention.html#value--">value</a>=<a href="../../java/lang/annotation/RetentionPolicy.html#RUNTIME">RUNTIME</a>)
 <a href="../../java/lang/annotation/Target.html" title="annotation in java.lang.annotation">@Target</a>(<a href="../../java/lang/annotation/Target.html#value--">value</a>=<a href="../../java/lang/annotation/ElementType.html#TYPE">TYPE</a>)
public @interface <span class="memberNameLabel">MXBean</span></pre> 
    <div class="block" data-fanyi="1"> 
     <p data-fanyi="1">注释标记接口明确作为一个MXBean接口，或不是一个MXBean接口。默认情况下，接口是一个MXBean接口如果是公的和它的名字<code>MXBean</code>结束，在<code>SomethingMXBean</code>。下列接口MXBean接口：</p> 
     <pre data-fanyi="1">公共接口whatsitmxbean { }@ MXBean公共接口whatsit1interface { }@ MXBean（真的）公共接口whatsit2interface { }</pre> 
     <p data-fanyi="1">下面的接口不MXBean接口：</p> 
     <pre data-fanyi="1">接口nonpublicinterfacenotmxbean { }公共接口whatsit3interface { }@ MXBean（假）公共接口misleadingmxbean { }</pre> 
     <h3 id="MXBean-spec" data-fanyi="1">MXBean规范</h3> 
     <p data-fanyi="1">的MXBean的概念提供了一个简单的方法来编码的MBean仅引用一组预定义的类型，定义的<a href="../../javax/management/openmbean/package-summary.html"><code>javax.management.openmbean</code></a>的。这样，你可以确信你的MBean将任何客户端可以使用，包括远程客户，不要求客户端访问模型类的代表你的MBeans类型。</p> 
     <p data-fanyi="1">的概念更容易理解与标准MBean概念的比较。这是怎样的一个管理对象可以被表示为一个标准MBean，作为MXBean：</p> 
     <table border="1" cellpadding="5" summary="Standard Bean vs. MXBean"> 
      <tbody> 
       <tr> 
        <th>Standard MBean</th> 
        <th>MXBean</th> 
       </tr> 
       <tr> 
        <td><pre>
public interface MemoryPool<b>MBean</b> {
    String getName();
    MemoryUsage getUsage();
    // ...
}
          </pre></td> 
        <td><pre>
public interface MemoryPool<b>MXBean</b> {
    String getName();
    MemoryUsage getUsage();
    // ...
}
          </pre></td> 
       </tr> 
      </tbody> 
     </table> 
     <p data-fanyi="1">正如你所看到的，定义是非常相似的。唯一不同的是，命名的接口约定是使用<code><em>Something</em>MXBean</code>为mxbeans，而不是标准MBean <code><em>Something</em>MBean</code>。</p> 
     <p data-fanyi="1">在这个管理对象，有一个属性叫做型<a href="../../java/lang/management/MemoryUsage.html" title="class in java.lang.management"><code>MemoryUsage</code></a> <code>Usage</code>。像这样的一个属性的点是它给出了一个数据项集的一致的快照。例如，它可能包括内存池中使用的内存量，以及内存池的当前最大值。如果这些都是单独的项目，单独<a href="../../javax/management/MBeanServer.html#getAttribute-javax.management.ObjectName-java.lang.String-"><code>getAttribute</code></a>电话获得的，那么我们可以看到在不同的时间是不一致的价值观。我们可能会<code>used</code>值大于<code>max</code>价值。</p> 
     <p data-fanyi="1">所以，我们可以这样定义<code>MemoryUsage</code>：</p> 
     <table border="1" cellpadding="5" summary="Standard Bean vs. MXBean"> 
      <tbody> 
       <tr> 
        <th>Standard MBean</th> 
        <th>MXBean</th> 
       </tr> 
       <tr> 
        <td><pre>
public class MemoryUsage <b>implements Serializable</b> {
    // standard JavaBean conventions with getters

    public MemoryUsage(long init, long used,
                       long committed, long max) {...}
    long getInit() {...}
    long getUsed() {...}
    long getCommitted() {...}
    long getMax() {...}
}
          </pre></td> 
        <td><pre>
public class MemoryUsage {
    // standard JavaBean conventions with getters
    <b>@ConstructorProperties({"init", "used", "committed", "max"})</b>
    public MemoryUsage(long init, long used,
                       long committed, long max) {...}
    long getInit() {...}
    long getUsed() {...}
    long getCommitted() {...}
    long getMax() {...}
}
          </pre></td> 
       </tr> 
      </tbody> 
     </table> 
     <p data-fanyi="1">定义在两种情况下是相同的，除了与MXBean，<code>MemoryUsage</code>不再需要标明<code>Serializable</code>（尽管它可以）。另一方面，我们增加了一个<code>@ConstructorProperties</code>标注参数的构造函数链接到相应的干将。我们会看到更多关于下面的。</p> 
     <p data-fanyi="1"><code>MemoryUsage</code>是一个模型类。与标准MBean，客户端的MBean服务器无法访问<code>Usage</code>属性如果不了解班级<code>MemoryUsage</code>。假设客户端是一个基于JMX技术通用控制台。然后，控制台将必须配置与模型特定类别的每一个应用程序，它可能连接到。问题更糟糕的是，不是用java语言编写的客户。然后可能没有办法告诉客户什么<code>MemoryUsage</code>看起来像。</p> 
     <p data-fanyi="1">这是mxbeans不同于标准MBean。虽然我们定义管理界面几乎完全相同的方式，将特定的MXBean框架模型类标准类的java平台。使用数组和从标准<a href="../../javax/management/openmbean/package-summary.html"><code>javax.management.openmbean</code></a>包<a href="../../javax/management/openmbean/CompositeData.html" title="interface in javax.management.openmbean"><code>CompositeData</code></a>和<a href="../../javax/management/openmbean/TabularData.html" title="interface in javax.management.openmbean"><code>TabularData</code></a>类，可以建立任意复杂的数据结构只使用标准的类。</p> 
     <p data-fanyi="1">这变得更清晰，如果我们比较这两个模型的客户可能看起来像：</p> 
     <table border="1" cellpadding="5" summary="Standard Bean vs. MXBean"> 
      <tbody> 
       <tr> 
        <th>Standard MBean</th> 
        <th>MXBean</th> 
       </tr> 
       <tr> 
        <td><pre>
String name = (String)
    mbeanServer.<a href="../../javax/management/MBeanServer.html#getAttribute-javax.management.ObjectName-java.lang.String-"><code>getAttribute</code></a>(objectName, "Name");
<b>MemoryUsage</b> usage = (<b>MemoryUsage</b>)
    mbeanServer.getAttribute(objectName, "Usage");
<b>long used = usage.getUsed();</b>
          </pre></td> 
        <td><pre>
String name = (String)
    mbeanServer.<a href="../../javax/management/MBeanServer.html#getAttribute-javax.management.ObjectName-java.lang.String-"><code>getAttribute</code></a>(objectName, "Name");
<b><a href="../../javax/management/openmbean/CompositeData.html" title="interface in javax.management.openmbean"><code>CompositeData</code></a></b> usage = (<b>CompositeData</b>)
    mbeanServer.getAttribute(objectName, "Usage");
<b>long used = (Long) usage.<a href="../../javax/management/openmbean/CompositeData.html#get-java.lang.String-"><code>get</code></a>("used");</b>
          </pre></td> 
       </tr> 
      </tbody> 
     </table> 
     <p data-fanyi="1">对于这样的简单类型<code>String</code>属性，代码是相同的。但对于复杂类型的属性，标准MBean的代码需要知道客户端模型的具体类<code>MemoryUsage</code>，而不需要非标类MXBean代码。</p> 
     <p data-fanyi="1">这里显示的客户端代码的MXBean客户稍微复杂。但是，如果客户确实知道的模型，这里的接口和类<code>MemoryUsage</code> <code>MemoryPoolMXBean</code>，那么它可以构造一个代理。这是推荐的方式与管理对象当你知道模型之前，无论你使用的是标准MBean或mxbeans：</p> 
     <table border="1" cellpadding="5" summary="Standard Bean vs. MXBean"> 
      <tbody> 
       <tr> 
        <th>Standard MBean</th> 
        <th>MXBean</th> 
       </tr> 
       <tr> 
        <td><pre>
MemoryPool<b>MBean</b> proxy =
    JMX.<b><a href="../../javax/management/JMX.html#newMBeanProxy-javax.management.MBeanServerConnection-javax.management.ObjectName-java.lang.Class-"><code>newMBeanProxy</code></a></b>(
        mbeanServer,
        objectName,
        MemoryPool<b>MBean</b>.class);
String name = proxy.getName();
MemoryUsage usage = proxy.getUsage();
long used = usage.getUsed();
          </pre></td> 
        <td><pre>
MemoryPool<b>MXBean</b> proxy =
    JMX.<b><a href="../../javax/management/JMX.html#newMXBeanProxy-javax.management.MBeanServerConnection-javax.management.ObjectName-java.lang.Class-"><code>newMXBeanProxy</code></a></b>(
        mbeanServer,
        objectName,
        MemoryPool<b>MXBean</b>.class);
String name = proxy.getName();
MemoryUsage usage = proxy.getUsage();
long used = usage.getUsed();
          </pre></td> 
       </tr> 
      </tbody> 
     </table> 
     <p data-fanyi="1">实现内存池对象的作品同样为标准MBean和mxbeans。</p> 
     <table border="1" cellpadding="5" summary="Standard Bean vs. MXBean"> 
      <tbody> 
       <tr> 
        <th>Standard MBean</th> 
        <th>MXBean</th> 
       </tr> 
       <tr> 
        <td><pre>
public class MemoryPool
        implements MemoryPool<b>MBean</b> {
    public String getName() {...}
    public MemoryUsage getUsage() {...}
    // ...
}
          </pre></td> 
        <td><pre>
public class MemoryPool
        implements MemoryPool<b>MXBean</b> {
    public String getName() {...}
    public MemoryUsage getUsage() {...}
    // ...
}
          </pre></td> 
       </tr> 
      </tbody> 
     </table> 
     <p data-fanyi="1">在MBean服务器注册mbean的作品以同样的方式在这两种情况下：</p> 
     <table border="1" cellpadding="5" summary="Standard Bean vs. MXBean"> 
      <tbody> 
       <tr> 
        <th>Standard MBean</th> 
        <th>MXBean</th> 
       </tr> 
       <tr> 
        <td><pre>
{
    MemoryPool<b>MBean</b> pool = new MemoryPool();
    mbeanServer.<a href="../../javax/management/MBeanServer.html#registerMBean-java.lang.Object-javax.management.ObjectName-"><code>registerMBean</code></a>(pool, objectName);
}
          </pre></td> 
        <td><pre>
{
    MemoryPool<b>MXBean</b> pool = new MemoryPool();
    mbeanServer.<a href="../../javax/management/MBeanServer.html#registerMBean-java.lang.Object-javax.management.ObjectName-"><code>registerMBean</code></a>(pool, objectName);
}
          </pre></td> 
       </tr> 
      </tbody> 
     </table> 
     <h2 id="mxbean-def" data-fanyi="1">一个MXBean的定义</h2> 
     <p data-fanyi="1">一个MXBean是一种MBean。一个MXBean对象可以在MBean服务器直接注册，也可以作为<a href="../../javax/management/StandardMBean.html" title="class in javax.management"><code>StandardMBean</code></a>争论在MBean服务器注册所得的MBean。</p> 
     <p data-fanyi="1">当一个物体在MBean服务器使用的<a href="../../javax/management/MBeanServer.html" title="interface in javax.management"><code>MBeanServer</code></a>接口<code>registerMBean</code>或<code>createMBean</code>方法注册，对象的类进行检测以确定什么类型的MBean是：</p> 
     <ul data-fanyi="1"> 
      <li data-fanyi="1">如果该类实现的接口<a href="../../javax/management/DynamicMBean.html" title="interface in javax.management"><code>DynamicMBean</code></a>然后MBean是动态MBean。注意这类<code>StandardMBean</code>实现这个接口，那么这种情况适用于标准MBean或MXBean使用类<code>StandardMBean</code>创建。</li> 
      <li data-fanyi="1">否则，如果类配标准MBean的命名约定，那么MBean是标准MBean。</li> 
      <li data-fanyi="1">否则，它可能是一个MXBean。由对象实现的接口集检查接口： 
       <ul data-fanyi="1"> 
        <li data-fanyi="1">有一类的名字<code><em>S</em>MXBean</code>哪里<code><em>S</em></code>是任何非空的字符串，并没有标注<code>@MXBean(false)</code>；和/或</li> 
        <li data-fanyi="1">有一个注释<code>@MXBean(true)</code>或只是<code>@MXBean</code>。</li> 
       </ul>如果恰好有一个这样的接口，或如果有一个这样的接口，一个接口的所有其他人，那么对象是一个MXBean。这个接口是MXBean接口。在上面的例子中，这是<code>MemoryPoolMXBean</code> MXBean接口。</li> 
      <li data-fanyi="1">如果这些条件没有被满足，MBean是无效的和试图登记会产生<a href="../../javax/management/NotCompliantMBeanException.html" title="class in javax.management"><code>NotCompliantMBeanException</code></a>。</li> 
     </ul> 
     <p data-fanyi="1">每一个java类型出现的参数或一个MXBean接口的方法的返回类型必须是可使用下面的规则。此外，参数必须是可重构的定义如下。</p> 
     <p data-fanyi="1">试图构建一个不符合上述规则MXBean会产生异常。</p> 
     <h2 id="naming-conv" data-fanyi="1">命名约定</h2> 
     <p data-fanyi="1">相同的命名规则应用于一个MXBean的方法作为标准MBean：</p> 
     <ol data-fanyi="1"> 
      <li data-fanyi="1">方法<code><em>T</em> get<em>N</em>()</code>，哪里<code><em>T</em></code>是java类（不<code>void</code>）和<code><em>N</em></code>是一个非空的字符串，指定有一个可读的属性称为<code><em>N</em></code>。java类型和属性的开放型是由下面的映射规则确定。方法<code>final Class getClass()</code>继承<code>Object</code>时忽视了寻找干将。</li> 
      <li data-fanyi="1">方法<code>boolean is<em>N</em>()</code>指定有可读属性调用java类型<code>boolean</code>和开放式<code>SimpleType.Boolean</code> <code><em>N</em></code>。</li> 
      <li data-fanyi="1">方法<code>void set<em>N</em>(<em>T</em> x)</code>指定有一个可写的属性称为<code><em>N</em></code>。java类型和属性的开放型是由下面的映射规则确定。（当然，该参数的名称<code>x</code>无关。）</li> 
      <li data-fanyi="1">每一其他方法指定有一个与该方法同名的操作。java型和开放型的返回值及各参数由下面的映射规则确定。</li> 
     </ol> 
     <p data-fanyi="1">规则和<code>is<em>N</em></code> <code>get<em>N</em></code>统称定义getter的概念。对于<code>set<em>N</em></code>规则定义了一个二传手的概念。</p> 
     <p data-fanyi="1">这是一个错误，有两人具有相同的名称，或二者具有相同的名称。如果有一个getter和同一名二传手，然后在<code><em>T</em></code>类型必须相同。在这种情况下，属性是读/写。如果只有一个getter或setter，属性为只读或只写的分别。</p> 
     <h2 id="mapping-rules" data-fanyi="1">类型映射规则</h2> 
     <p data-fanyi="1">一个MXBean是一种Open MBean，由<a href="../../javax/management/openmbean/package-summary.html"><code>javax.management.openmbean</code></a>包定义。这意味着属性、操作参数和返回值的类型、操作都必须可以使用开放的类型，这是<a href="../../javax/management/openmbean/OpenType.html" title="class in javax.management.openmbean"><code>OpenType</code></a>四标准的子类。mxbeans实现这个java类型映射为开放型。</p> 
     <p data-fanyi="1">对于每一个java J型，的MXBean映射由以下信息描述：</p> z-6ad5625e-6a57—4cf5-926f-7f6dca9cdd35 
     <p data-fanyi="1">例如，对于java类型<code>List&lt;String&gt;</code>：</p> 
     <ul data-fanyi="1"> 
      <li data-fanyi="1">开放式，OpenType（<code>List&lt;String&gt;</code>），是<a href="../../javax/management/openmbean/ArrayType.html" title="class in javax.management.openmbean"><code>ArrayType</code></a><code>(1, </code><a href="../../javax/management/openmbean/SimpleType.html#STRING"><code>SimpleType.STRING</code></a><code>)</code>，表示一个一维数组<code>String</code>s。</li> 
      <li data-fanyi="1">映射到java类型，开放数据（<code>List&lt;String&gt;</code>），是<code>String[]</code>。</li> 
      <li data-fanyi="1">一个<code>List&lt;String&gt;</code>可以转换为一个<code>String[]</code>使用<a href="../../java/util/List.html#toArray-T:A-"><code>List.toArray(new String[0])</code></a>。</li> 
      <li data-fanyi="1">一个<code>String[]</code>可以转换为一个<code>List&lt;String&gt;</code>使用<a href="../../java/util/Arrays.html#asList-T...-"><code>Arrays.asList</code></a>。</li> 
     </ul> 
     <p data-fanyi="1">如果没有映射规则存在派生OpenType（J）J，J不能一个方法参数或返回值在一个MXBean接口的类型。</p> 
     <p id="reconstructible-def" data-fanyi="1">如果有一种方法将开放数据（J）回来然后我们说J是可重构。在一个MXBean接口所有的方法参数必须是可重构的，因为当MXBean框架调用一个方法需要将这些参数从开放数据（J）在一个由<a href="../../javax/management/JMX.html#newMXBeanProxy-javax.management.MBeanServerConnection-javax.management.ObjectName-java.lang.Class-"><code>JMX.newMXBeanProxy</code></a>代理到J.，它是在MXBean接口必须重构方法的返回值。</p> 
     <p data-fanyi="1">空值是允许所有java类型和开放型，除了原始java类型，他们是不可能的。当转换型J型开放数据（J）或从型开放数据（J）到J型，空值映射为一个空值。</p> 
     <p data-fanyi="1">下表总结了类型映射规则。</p> 
     <table border="1" cellpadding="5" summary="Type Mapping Rules"> 
      <tbody> 
       <tr> 
        <th>Java type <em>J</em></th> 
        <th><em>opentype(J)</em></th> 
        <th><em>opendata(J)</em></th> 
       </tr> 
      </tbody> 
      <tbody valign="top"> 
       <tr> 
        <td><code>int</code>, <code>boolean</code>, etc<br> (the 8 primitive Java types)</td> 
        <td><code>SimpleType.INTEGER</code>,<br> <code>SimpleType.BOOLEAN</code>, etc</td> 
        <td><code>Integer</code>, <code>Boolean</code>, etc<br> (the corresponding boxed types)</td> 
       </tr> 
       <tr> 
        <td><code>Integer</code>, <code>ObjectName</code>, etc<br> (the types covered by <a href="../../javax/management/openmbean/SimpleType.html" title="class in javax.management.openmbean"><code>SimpleType</code></a>)</td> 
        <td>the corresponding <code>SimpleType</code></td> 
        <td><em>J</em>, the same type</td> 
       </tr> 
       <tr> 
        <td><code>int[]</code> etc<br> (a one-dimensional array with<br> primitive element type)</td> 
        <td><code>ArrayType.getPrimitiveArrayType(int[].class)</code> etc</td> 
        <td><em>J</em>, the same type</td> 
       </tr> 
       <tr> 
        <td><em>E</em><code>[]</code><br> (an array with non-primitive element type <em>E</em>; this includes <code>int[][]</code>, where <em>E</em> is <code>int[]</code>)</td> 
        <td><code>ArrayType.getArrayType(</code><em>opentype(E)</em><code>)</code></td> 
        <td><em>opendata(E)</em><code>[]</code></td> 
       </tr> 
       <tr> 
        <td><code>List&lt;</code><em>E</em><code>&gt;</code><br> <code>Set&lt;</code><em>E</em><code>&gt;</code><br> <code>SortedSet&lt;</code><em>E</em><code>&gt;</code> (see below)</td> 
        <td>same as for <em>E</em><code>[]</code></td> 
        <td>same as for <em>E</em><code>[]</code></td> 
       </tr> 
       <tr> 
        <td>An enumeration <em>E</em><br> (declared in Java as <code>枚举</code><em>E</em> <code>{...}</code>)</td> 
        <td><code>SimpleType.STRING</code></td> 
        <td><code>String</code></td> 
       </tr> 
       <tr> 
        <td><code>Map&lt;</code><em>K</em>,<em>V</em><code>&gt;</code><br> <code>SortedMap&lt;</code><em>K</em>,<em>V</em><code>&gt;</code></td> 
        <td><a href="../../javax/management/openmbean/TabularType.html" title="class in javax.management.openmbean"><code>TabularType</code></a><br> (see below)</td> 
        <td><a href="../../javax/management/openmbean/TabularData.html" title="interface in javax.management.openmbean"><code>TabularData</code></a><br> (see below)</td> 
       </tr> 
       <tr> 
        <td>An MXBean interface</td> 
        <td><code>SimpleType.OBJECTNAME</code><br> (see below)</td> 
        <td><a href="../../javax/management/ObjectName.html" title="class in javax.management"><code>ObjectName</code></a><br> (see below)</td> 
       </tr> 
       <tr> 
        <td>Any other type</td> 
        <td><a href="../../javax/management/openmbean/CompositeType.html" title="class in javax.management.openmbean"><code>CompositeType</code></a>, if possible<br> (see below)</td> 
        <td><a href="../../javax/management/openmbean/CompositeData.html" title="interface in javax.management.openmbean"><code>CompositeData</code></a></td> 
       </tr> 
      </tbody> 
     </table> 
     <p data-fanyi="1">下面的章节给出了这些规则的进一步细节。</p> 
     <h3 data-fanyi="1">原始类型的映射</h3> 
     <p data-fanyi="1">8原始java类型（<code>boolean</code>，<code>byte</code>，<code>short</code>，<code>int</code>，<code>long</code>，<code>float</code>，<code>double</code>，<code>char</code>）映射到相应的<code>java.lang</code>盒装类型，即<code>Boolean</code>，<code>Byte</code>，等开放型的是相应的<code>SimpleType</code>。因此，OpenType（<code>long</code>）是<code>SimpleType.LONG</code>，和开放数据（<code>long</code>）是<code>java.lang.Long</code>。</p> 
     <p data-fanyi="1">原始类型如<code>long[]</code>数组可以直接表示为开放式。因此，OpenType（<code>long[]</code>）是<code>ArrayType.getPrimitiveArrayType(long[].class)</code>，和开放数据（<code>long[]</code>）是<code>long[]</code>。</p> 
     <p data-fanyi="1">在实践中，一个普通的<code>int</code>和<code>Integer</code>，等之间的差异，并没有出现因为在JMX API操作总是java对象，不是原语。然而，不同的是显示数组。</p> 
     <h3 data-fanyi="1">映射的集合（<code>List&lt;</code>e<code>&gt;</code>等）</h3> 
     <p data-fanyi="1">一个<code>List&lt;</code>e<code>&gt;</code>或<code>Set&lt;</code>e<code>&gt;</code>，如<code>List&lt;String&gt;</code>或<code>Set&lt;ObjectName&gt;</code>，映射在相同的方式，相同的元素类型的数组，如<code>String[]</code>或<code>ObjectName[]</code>。</p> 
     <p data-fanyi="1">一个<code>SortedSet&lt;</code>e<code>&gt;</code>也映射在相同的方式作为一个e<code>[]</code>，但只有活如果E是一个类或接口实现<a href="../../java/lang/Comparable.html" title="interface in java.lang"><code>Comparable</code></a>。因此，一个<code>SortedSet&lt;String&gt;</code>或<code>SortedSet&lt;Integer&gt;</code>兑换，但<code>SortedSet&lt;int[]&gt;</code>或<code>SortedSet&lt;List&lt;String&gt;&gt;</code>不。一个<code>SortedSet</code>实例转换将失败与<code>IllegalArgumentException</code>如果它有一个非空的<a href="../../java/util/SortedSet.html#comparator--"><code>comparator()</code></a>。</p> 
     <p data-fanyi="1">一个<code>List&lt;</code>e<code>&gt;</code>重建作为一个<code>java.util.ArrayList&lt;</code>e<code>&gt;</code>；一<code>Set&lt;</code>e<code>&gt;</code>作为<code>java.util.HashSet&lt;</code>e<code>&gt;</code>；一<code>SortedSet&lt;</code>e<code>&gt;</code>作为<code>java.util.TreeSet&lt;</code>e<code>&gt;</code>。</p> 
     <h3 data-fanyi="1">映射图（<code>Map&lt;</code>k，v<code>&gt;</code>等）</h3> 
     <p data-fanyi="1">一个<code>Map&lt;</code>k，v<code>&gt;</code>或<code>SortedMap&lt;</code>k，v<code>&gt;</code>，例如<code>Map&lt;String,ObjectName&gt;</code>，具有开放式<a href="../../javax/management/openmbean/TabularType.html" title="class in javax.management.openmbean"><code>TabularType</code></a>和映射到一个<a href="../../javax/management/openmbean/TabularData.html" title="interface in javax.management.openmbean"><code>TabularData</code></a>。的<code>TabularType</code>有两项称为<code>key</code>和<code>value</code>。开放式的<code>key</code>是OpenType（K），和<code>value</code>开放式OpenType（V）。该<code>TabularType</code>指标单项<code>key</code>。</p> 
     <p data-fanyi="1">例如，一个<code>Map&lt;String,ObjectName&gt;</code>的<code>TabularType</code>可能与这样的代码构造：</p> 
     <pre data-fanyi="1">字符串类型=“java使用java.Map&lt; java.lang.string，javax.管理对象&gt;”；字符串函数= []新字符串[ ] {“键”，“值”}；OpenType [ ] opentypes =新的OpenType [ ] { simpletype.string对象}，简单类型；compositetype式=新的compositetype（typename，typename，键值，键值，opentypes）；tabulartype tabulartype =新的tabulartype（typename，typename，棱型，新的字符串[ ] {“关键”}）；</pre> 
     <p data-fanyi="1">这里的<code>typeName</code>由<a href="#type-names"> type name rules</a>以下决定。</p> 
     <p data-fanyi="1">一个<code>SortedMap&lt;</code>k，v<code>&gt;</code>是以同样的方式映射，但它只是转换如果K是一个类或接口实现<a href="../../java/lang/Comparable.html" title="interface in java.lang"><code>Comparable</code></a>。因此，一个<code>SortedMap&lt;String,int[]&gt;</code>兑换，但<code>SortedMap&lt;int[],String&gt;</code>不。一个<code>SortedMap</code>实例转换将失败与<code>IllegalArgumentException</code>如果它有一个非空的<a href="../../java/util/SortedMap.html#comparator--"><code>comparator()</code></a>。</p> 
     <p data-fanyi="1">一个<code>Map&lt;</code>k，v<code>&gt;</code>重建作为一个<code>java.util.HashMap&lt;</code>k，v<code>&gt;</code>；一<code>SortedMap&lt;</code>k，v<code>&gt;</code>作为<code>java.util.TreeMap&lt;</code>k，v<code>&gt;</code>。</p> 
     <p data-fanyi="1"><code>TabularData</code>是接口。这是用来表示一个<code>Map&lt;</code>k具体类，v<code>&gt;</code>开放数据<a href="../../javax/management/openmbean/TabularDataSupport.html" title="class in javax.management.openmbean"><code>TabularDataSupport</code></a>，或另一个班级实施<code>TabularData</code>序列化为<code>TabularDataSupport</code>。</p> 
     <h3 id="mxbean-map" data-fanyi="1">MXBean接口映射</h3> 
     <p data-fanyi="1">一个MXBean接口或类型的引用，在一个MXBean接口可以参考另一个MXBean接口，，J. Then opentype（J）是<code>SimpleType.OBJECTNAME</code>和开放数据（J）是<code>ObjectName</code>。</p> 
     <p data-fanyi="1">例如，假设你有两个MXBean接口这样：</p> 
     <pre data-fanyi="1">productmxbean公共接口{公共modulemxbean [ ] getmodules()；}ModuleMXBean的公共接口{公共productmxbean getproduct()；}</pre> 
     <p data-fanyi="1">实现<code>ModuleMXBean</code>接口返回的<code>getProduct</code>方法实施<code>ProductMXBean</code>接口的对象。的<code>ModuleMXBean</code>对象和返回的<code>ProductMXBean</code>对象都必须注册在同一mxbeans MBean服务器。</p> 
     <p data-fanyi="1">方法<code>ModuleMXBean.getProduct()</code>定义一个属性叫做<code>Product</code>。这个属性的开放式<code>SimpleType.OBJECTNAME</code>，和相应的<code>ObjectName</code>值会根据这个名字引用的<code>ProductMXBean</code>在MBean服务器注册。</p> 
     <p data-fanyi="1">如果你让一个<code>ModuleMXBean</code> MXBean代理和调用它的<code>getProduct()</code>方法，代理将Map<code>ObjectName</code>回<code>ProductMXBean</code>通过另一个MXBean代理。更正式地说，当一个代理用<a href="../../javax/management/JMX.html#newMXBeanProxy-javax.management.MBeanServerConnection-javax.management.ObjectName-java.lang.Class-"><code>JMX.newMXBeanProxy(mbeanServerConnection, objectNameX, interfaceX)</code></a>需要Map<code>objectNameY</code>回<code>interfaceY</code> MXBean接口，另一个，那么，<code>JMX.newMXBeanProxy(mbeanServerConnection, objectNameY, interfaceY)</code>。实施可能会返回一个代理以前创建的电话使用相同的参数<code>JMX.newMXBeanProxy</code>，或者创建一个新的代理。</p> 
     <p data-fanyi="1">反向映射是通过以下改变的<code>ModuleMXBean</code>接口：</p> 
     <pre data-fanyi="1">ModuleMXBean的公共接口{公共productmxbean getproduct()；公共无效盘装产品（productmxbean C）；}</pre> 
     <p data-fanyi="1">该<code>setProduct</code>方法的存在意味着<code>Product</code>属性是读/写。之前，这个属性的值是一个<code>ObjectName</code>。当属性设置，该<code>ObjectName</code>必须转换成<code>ProductMXBean</code>对象，<code>setProduct</code>方法预计。这个对象将为给定的<code>ObjectName</code>在相同的MBean服务器MXBean代理。</p> 
     <p data-fanyi="1">如果你让一个<code>ModuleMXBean</code> MXBean代理和调用它的<code>setProduct</code>方法，代理将Map的<code>ProductMXBean</code>争论回<code>ObjectName</code>。这只会如果参数实际上是另一个代理的工作，在同一<code>ProductMXBean</code> <code>MBeanServerConnection</code>。代理可以从另一个代理返回（如<code>ModuleMXBean.getProduct()</code>返回一个<code>ProductMXBean</code>代理）；或者它可以有<a href="../../javax/management/JMX.html#newMXBeanProxy-javax.management.MBeanServerConnection-javax.management.ObjectName-java.lang.Class-"><code>JMX.newMXBeanProxy</code></a>；或者它可以一直使用<a href="../../java/lang/reflect/Proxy.html" title="class in java.lang.reflect"><code>Proxy</code></a>与调用句柄是<a href="../../javax/management/MBeanServerInvocationHandler.html" title="class in javax.management"><code>MBeanServerInvocationHandler</code></a>或子类的创建。</p> 
     <p data-fanyi="1">如果同样的MXBean的是两个不同的<code>ObjectName</code>s下注册，参考，从另一个MXBean MXBean会暧昧。因此，如果一个MXBean对象已在MBean服务器并尝试登记在同一个MBean服务器下注册的名字，结果是一个<a href="../../javax/management/InstanceAlreadyExistsException.html" title="class in javax.management"><code>InstanceAlreadyExistsException</code></a>。注册相同的MBean对象不只一个名字不一般，特别是因为它没有工作，<a href="../../javax/management/NotificationBroadcaster.html" title="interface in javax.management"><code>NotificationBroadcaster</code></a>s MBeans。</p> 
     <h3 id="composite-map" data-fanyi="1">其他类型的映射</h3> 
     <p data-fanyi="1">给定一个java类或接口，不符合上表中的其他规则的MXBean框架将它映射到一个<a href="../../javax/management/openmbean/CompositeType.html" title="class in javax.management.openmbean"><code>CompositeType</code></a>如下。这<code>CompositeType</code>类型名称是由下面的<a href="#type-names"> type name rules</a>确定。</p> 
     <p data-fanyi="1">这类研究使用公约<a href="#naming-conv">above</a>干将。（干将必须公共实例方法。）如果没有吸气剂，吸气剂或如果任何具有类型的不可自由兑换，然后是不可改变的。</p> 
     <p data-fanyi="1">如果至少有一个getter和每个吸气剂有可转换的类型，然后OpenType（J）是一项<code>CompositeType</code>每个吸气剂。如果吸气剂</p> 
     <blockquote> 
      <code><em>T</em> get<em>Name</em>()</code> 
     </blockquote>然后在 
     <code>CompositeType</code>项目称为 
     <code>name</code>具有型OpenType（T）。例如，如果该项目是 
     <blockquote> 
      <code>String getOwner()</code> 
     </blockquote>然后项目称为 
     <code>owner</code>并具有开放式 
     <code>SimpleType.STRING</code>。如果吸气剂 
     <blockquote> 
      <code>boolean is<em>Name</em>()</code> 
     </blockquote>然后在 
     <code>CompositeType</code>项目称为 
     <code>name</code>和类型 
     <code>SimpleType.BOOLEAN</code>。 
     <p data-fanyi="1">注意，第一个字符（或代码点）被转换为小写的情况下。这是java bean的惯例，而由于历史的原因，不同于标准MBean公约。在一个标准MBean或MXBean接口，方法<code>getOwner</code>定义一个属性叫做<code>Owner</code>，而在java bean或映射<code>CompositeType</code>，方法<code>getOwner</code>定义属性或项目称为<code>owner</code>。</p> 
     <p data-fanyi="1">如果两种方法产生相同的名称（例如，<code>getOwner</code>和<code>isOwner</code>，或<code>getOwner</code>和<code>getowner</code>）的类型是不可改变的。</p> 
     <p data-fanyi="1">当开启式<code>CompositeType</code>，相应的映射到java类型（开放数据（j））是<a href="../../javax/management/openmbean/CompositeData.html" title="interface in javax.management.openmbean"><code>CompositeData</code></a>。映射到<code>CompositeData</code> J实例对应的<code>CompositeType</code>只是描述如下。首先，如果该实现的接口<a href="../../javax/management/openmbean/CompositeDataView.html" title="interface in javax.management.openmbean"><code>CompositeDataView</code></a>，那么接口的<a href="../../javax/management/openmbean/CompositeDataView.html#toCompositeData-javax.management.openmbean.CompositeType-"><code>toCompositeData</code></a>方法来做转换。否则，该<code>CompositeData</code>是通过调用getter每个项目并将其转化为相应的数据类型构造。因此，吸气如</p> 
     <blockquote> 
      <code>List&lt;String&gt; getNames()</code> 
     </blockquote> 
     <p data-fanyi="1">将被映射到一个项目叫“<code>names</code>”和开放式<code>ArrayType(1, SimpleType.STRING)</code>。转换<code>CompositeData</code>称<code>getNames()</code>和转换生成的<code>List&lt;String&gt;</code>成<code>String[]</code>为项目“<code>names</code>”。</p> 
     <p data-fanyi="1"><code>CompositeData</code>是接口。这是用来表示一个类型为开放数据是<a href="../../javax/management/openmbean/CompositeDataSupport.html" title="class in javax.management.openmbean"><code>CompositeDataSupport</code></a>具体类，或另一个班级实施<code>CompositeData</code>序列化为<code>CompositeDataSupport</code>。</p> 
     <h4 data-fanyi="1">重构java J型从<code>CompositeData</code>实例</h4> 
     <p data-fanyi="1">如果开放数据（J）是一个java J型<code>CompositeData</code>，然后实例J可以从<code>CompositeData</code>重建，或不可重构[J].。如果在<code>CompositeData</code>任何项目不可重构，然后是无法重建或。</p> 
     <p data-fanyi="1">对于任何给定的J，以下规则咨询以确定如何从<code>CompositeData</code>重建实例[J].。列表中的第一个适用规则是将要使用的规则。</p> 
     <ol data-fanyi="1"> 
      <li data-fanyi="1"><p data-fanyi="1">如果J有method<br data-fanyi="1"> <code>public static </code>j <code>from(CompositeData cd)</code><br data-fanyi="1">那方法来重构J.实例</p></li> 
      <li data-fanyi="1"><p data-fanyi="1">否则，如果至少有一个与<a href="../../java/beans/ConstructorProperties.html" title="annotation in java.beans"><code>ConstructorProperties</code></a>诠释公共构造函数，然后其中一个构造函数（不一定总是同一个人）来重构J.每个这样的标注实例必须列出许多字符串的构造函数参数；每个字符串必须叫吸气J对应的属性；和这个吸气的类型必须为相应的构造函数参数相同。有人说，是不是在<code>ConstructorProperties</code>注释提到它是不是一个错误（这可能对应于不需要重建对象的信息）。</p> <p data-fanyi="1">J的一个实例是通过适当的改造项目从<code>CompositeData</code>调用构造函数的重建。构造函数被称为将在基于项目实际上在<code>CompositeData</code>目前运行的决定，因为这<code>CompositeData</code>可能来自早期版本的J，不是所有的项目都存在。如果所有的特性在其<code>ConstructorProperties</code>注释命名是目前在<code>CompositeData</code>项目构造函数是适用的。如果没有构造函数是适用的，那么尝试重建J失败。</p> <p data-fanyi="1">任何可能的性能组合，它必须是：（一）有没有适用的构造函数，或（b）恰好有一个适用的构造函数，或（c）一个适用的构造函数的名字的一个超集的性质相互适用的构造函数为。（换句话说，不能有歧义，构造函数来选择。）如果这种情况是不是真的，那么不可重构[J].。</p></li> 
      <li data-fanyi="1"><p data-fanyi="1">否则，如果J有一个公共的无参数构造函数，和J每个吸气型和名字有N个具有相同的名称和类型对应的二传手，然后J的实例是无参数构造函数和制定者构建被称为重建项目从<code>CompositeData</code>恢复值。例如，如果有一个method<br data-fanyi="1"> <code>public List&lt;String&gt; getNames()</code><br data-fanyi="1">然后还必须有此规则应用method<br data-fanyi="1"> <code>public void setNames(List&lt;String&gt; names)</code><br data-fanyi="1">。</p> <p data-fanyi="1">如果<code>CompositeData</code>来自早期版本的J，有些项目可能不存在。在这种情况下，相应的制定者就不叫。</p></li> 
      <li data-fanyi="1"><p data-fanyi="1">否则，如果J是一个接口，没有任何方法比其他的干将，J的一个实例是使用<a href="../../java/lang/reflect/Proxy.html" title="class in java.lang.reflect"><code>Proxy</code></a>用<code>CompositeData</code>转换支持<a href="../../javax/management/openmbean/CompositeDataInvocationHandler.html" title="class in javax.management.openmbean"><code>CompositeDataInvocationHandler</code></a>构造。</p></li> 
      <li data-fanyi="1"><p data-fanyi="1">否则，不可重构[J].。</p></li> 
     </ol> 
     <p data-fanyi="1">规则2不适用于java SE，不包括<code>java.beans</code>包集简介。当目标运行时，不包括<code>java.beans</code>包，哪里有一个不匹配，编译时和运行时环境，J是一个公共构造函数和<code>ConstructorProperties</code>注释编译，然后J不可重构的除非另一个应用规则。</p> 
     <p data-fanyi="1">这里是一个例子显示不同的方式编码类型<code>NamedNumber</code>，由<code>int</code>和<code>String</code>。在每一种情况下，该<code>CompositeType</code>看起来像这样：</p> 
     <blockquote> 
      <pre>
<a href="../../javax/management/openmbean/CompositeType.html" title="class in javax.management.openmbean"><code>CompositeType</code></a>(
    "NamedNumber",                      // typeName
    "NamedNumber",                      // description
    new String[] {"number", "name"},    // itemNames
    new String[] {"number", "name"},    // itemDescriptions
    new OpenType[] {SimpleType.INTEGER,
                    SimpleType.STRING}  // itemTypes
);
      </pre> 
     </blockquote> 
     <ol data-fanyi="1"> 
      <li data-fanyi="1">方法： 
       <blockquote> 
        <pre>
public class NamedNumber {
    public int getNumber() {return number;}
    public String getName() {return name;}
    private NamedNumber(int number, String name) {
        this.number = number;
        this.name = name;
    }
    <b>public static NamedNumber from(CompositeData cd)</b> {
        return new NamedNumber((Integer) cd.get("number"),
                               (String) cd.get("name"));
    }
    private final int number;
    private final String name;
}
          </pre> 
       </blockquote>静态<code>from</code></li> 
      <li data-fanyi="1">公共构造函数<code>@ConstructorProperties</code>注释： 
       <blockquote> 
        <pre>
public class NamedNumber {
    public int getNumber() {return number;}
    public String getName() {return name;}
    <b>@ConstructorProperties({"number", "name"})
    public NamedNumber(int number, String name)</b> {
        this.number = number;
        this.name = name;
    }
    private final int number;
    private final String name;
}
          </pre> 
       </blockquote></li> 
      <li data-fanyi="1">对于每一个getter setter： 
       <blockquote> 
        <pre>
public class NamedNumber {
    public int getNumber() {return number;}
    public void <b>setNumber</b>(int number) {this.number = number;}
    public String getName() {return name;}
    public void <b>setName</b>(String name) {this.name = name;}
    <b>public NamedNumber()</b> {}
    private int number;
    private String name;
}
          </pre> 
       </blockquote></li> 
      <li data-fanyi="1">只有干将接口： 
       <blockquote> 
        <pre>
public interface NamedNumber {
    public int getNumber();
    public String getName();
}
          </pre> 
       </blockquote></li> 
     </ol> 
     <p data-fanyi="1">它通常是更好的类，只代表一个集合的数据是不可变的。已构造了一个不可更改的类的实例。注意，<code>CompositeData</code>本身是不变的。不变性的优点很多，特别是关于线程安全。因此利用者的方法一般应尽量避免。</p> 
     <h3 data-fanyi="1">递归类型</h3> 
     <p data-fanyi="1">递归（自我指涉）类型不能在MXBean使用的接口。这是一个对<a href="../../javax/management/openmbean/CompositeType.html" title="class in javax.management.openmbean"><code>CompositeType</code></a>不变性的结果。例如，以下类型不可能是一个属性的类型，因为它指的是自己：</p> 
     <pre data-fanyi="1"><b data-fanyi="1">结</b>公共接口{getname()字符串；public int getpriority()；公共<b data-fanyi="1">结</b> getnext()；}</pre> 
     <p data-fanyi="1">它总是可能重写像这样的递归类型，所以他们不再是递归的。这样做可能需要引入新的类型。例如:</p> 
     <pre data-fanyi="1"><b data-fanyi="1">节点列表</b>公共接口{
 
        
        
        
      
        
      <结>
       
         
       
         
         
         
   getnodes()公示名单；}公共接口节点getname()字符串；public int getpriority()；}
 
        
        
        
      
        
      </结></pre> 
     <h3 data-fanyi="1">mbeaninfo内容为MXBean</h3> 
     <p data-fanyi="1">一个MXBean是一种开放的MBean。然而，由于兼容性的原因，它不是一个<a href="../../javax/management/openmbean/OpenMBeanInfo.html" title="interface in javax.management.openmbean"><code>OpenMBeanInfo</code></a> <a href="../../javax/management/MBeanInfo.html" title="class in javax.management"><code>MBeanInfo</code></a>。特别是，当类的一个属性，参数，或操作返回值是一个原始类型如<code>int</code>，或是<code>void</code>（用于返回类型），然后将属性，操作参数，或将代表各自的<a href="../../javax/management/MBeanAttributeInfo.html" title="class in javax.management"><code>MBeanAttributeInfo</code></a>，<a href="../../javax/management/MBeanParameterInfo.html" title="class in javax.management"><code>MBeanParameterInfo</code></a>，或<a href="../../javax/management/MBeanOperationInfo.html" title="class in javax.management"><code>MBeanOperationInfo</code></a>的<code>getType()</code>或<code>getReturnType()</code>返回原始的名字（“<code>int</code>”等）。虽然上面的映射规则指定的开放数据映射为包裹型（<code>Integer</code>等）。</p> 
     <p data-fanyi="1">公共构造函数返回的数组<a href="../../javax/management/MBeanInfo.html#getConstructors--"><code>MBeanInfo.getConstructors()</code></a>的MXBean是MBean服务器直接注册将包含所有的MXBean的公共构造函数。如果类没有公共的MXBean的构造函数不考虑公众。返回一个列表，使用的是<a href="../../javax/management/StandardMBean.html" title="class in javax.management"><code>StandardMBean</code></a> MXBean类构造源以同样的方式作为标准MBean。不管如何构建它的构造函数参数MXBean，不受MXBean的映射规则和没有相应的<code>OpenType</code>。</p> 
     <p data-fanyi="1">通知类型返回的数组<a href="../../javax/management/MBeanInfo.html#getNotifications--"><code>MBeanInfo.getNotifications()</code></a>的MXBean是MBean服务器直接注册将空如果不实施<a href="../../javax/management/NotificationBroadcaster.html" title="interface in javax.management"><code>NotificationBroadcaster</code></a> MXBean接口。否则，它会在时间的MXBean注册调用<a href="../../javax/management/NotificationBroadcaster.html#getNotificationInfo--"><code>NotificationBroadcaster.getNotificationInfo()</code></a>结果。即使这种方法发生变化的结果，对<code>MBeanInfo.getNotifications()</code>结果不。列表中返回一个MXBean，采用<a href="../../javax/management/StandardMBean.html" title="class in javax.management"><code>StandardMBean</code></a>或<a href="../../javax/management/StandardEmitterMBean.html" title="class in javax.management"><code>StandardEmitterMBean</code></a>类派生以同样的方式作为标准MBean。</p> 
     <p data-fanyi="1">所有的<code>MBeanAttributeInfo</code>，<code>MBeanParameterInfo</code>的<a href="../../javax/management/Descriptor.html" title="interface in javax.management"><code>Descriptor</code></a>，和<code>MBeanOperationInfo</code>对象包含在<code>MBeanInfo</code>将有一场<code>openType</code>其价值是由上面的映射规则规定的<a href="../../javax/management/openmbean/OpenType.html" title="class in javax.management.openmbean"><code>OpenType</code></a>。所以即使<code>getType()</code>是“<code>int</code>”，<code>getDescriptor().getField("openType")</code>将<a href="../../javax/management/openmbean/SimpleType.html#INTEGER"><code>SimpleType.INTEGER</code></a>。</p> 
     <p data-fanyi="1">每个对象的<code>Descriptor</code>还将有一场<code>originalType</code>是一个字符串类型的java的MXBean接口出现。此字符串的格式在下面的部分<a href="#type-names">Type Names</a>描述。</p> 
     <p data-fanyi="1">为<code>MBeanInfo</code>的<code>Descriptor</code>将有一场<code>mxbean</code>其值为字符串“<code>true</code>”。</p> 
     <h3 id="type-names" data-fanyi="1">类型名称</h3> 
     <p data-fanyi="1">有时一个方法参数或返回值在一个MXBean未映射的类型T必须表示为一个字符串。如果T是一个非泛型类型，此字符串返回值<a href="../../java/lang/Class.html#getName--"><code>Class.getName()</code></a>。否则，它是genericstring值（T），定义如下：</p> 
     <ul data-fanyi="1"> 
      <li data-fanyi="1">如果T是一个非一般的非数组类型，genericstring（t）是<a href="../../java/lang/Class.html#getName--"><code>Class.getName()</code></a>返回的值，例如<code>"int"</code>或<code>"java.lang.String"</code>。</li> 
      <li data-fanyi="1">如果T是一个数组E [ ]，genericstring（t）是genericstring（E）其次是<code>"[]"</code>。例如，genericstring（int []）是<code>"int[]"</code>，和genericstring（表 
       <字符串>
         [ ] [ ]）是 
        <code>"java.util.List&lt;java.lang.String&gt;[][]"</code>。 
       </字符串></li> 
      <li data-fanyi="1">否则，T是一个参数化的类型，如<code>List&lt;String&gt;</code>和genericstring（T）包括：参数化类型的返回的<code>Class.getName()</code>完全合格的名称；左尖括号（<code>"&lt;"</code>）；genericstring（一），是第一个类型参数；如果有二类型参数B则<code>", "</code>（逗号和空格）其次是genericstring（B）；右尖括号（<code>"&gt;"</code>）。</li> 
     </ul> 
     <p data-fanyi="1">注意，如果一个方法返回<code>int[]</code>，这将<code>Class.getName()</code>返回的字符串<code>"[I"</code>表示，但如果一个方法返回<code>List&lt;int[]&gt;</code>，这将由字符串<code>"java.util.List&lt;int[]&gt;"</code>代表。</p> 
     <h3 data-fanyi="1">例外</h3> 
     <p data-fanyi="1">一个问题从java类型映射到开放型信号与<a href="../../javax/management/openmbean/OpenDataException.html" title="class in javax.management.openmbean"><code>OpenDataException</code></a>。这可能发生在一个MXBean接口进行了分析，例如如果它引用一个类型的<a href="../../java/util/Random.html" title="class in java.util"><code>java.util.Random</code></a>没有吸气剂。或者它可能发生在一个实例被转换（从一个MXBean或参数在一个MXBean代理方法的返回值），从<code>SortedSet&lt;String&gt;</code>转换为<code>String[]</code>如果<code>SortedSet</code>有一个非空的<code>Comparator</code>当例子。</p> 
     <p data-fanyi="1">从开放的类型映射到java类型的一个问题是一个<a href="../../java/io/InvalidObjectException.html" title="class in java.io"><code>InvalidObjectException</code></a>示意。这可能发生在一个MXBean接口进行了分析，例如如果它引用一个类型，无法重建根据上述规则，在上下文中，一个可重构的类型是必需的。或者它可能发生在一个实例被转换（一个参数或返回值的MXBean在MXBean代理的方法），例如从一个字符串枚举没有枚举同名的常数。</p> 
     <p data-fanyi="1">根据上下文，这<code>OpenDataException</code>或<code>InvalidObjectException</code>可以包裹在一个例外如<a href="../../javax/management/RuntimeMBeanException.html" title="class in javax.management"><code>RuntimeMBeanException</code></a>或<a href="../../java/lang/reflect/UndeclaredThrowableException.html" title="class in java.lang.reflect"><code>UndeclaredThrowableException</code></a>。每一个抛出的例外，条件C将是真实的：“E <code>InvalidObjectException</code> <code>OpenDataException</code>或（如适用），或是e.<a href="../../java/lang/Throwable.html#getCause--"><code>getCause()</code></a>”真的。</p> 
    </div> 
    <dl> 
     <dt> 
      <span class="simpleTagLabel">从以下版本开始：</span> 
     </dt> 
     <dd data-fanyi="1">
       一点六 
     </dd> 
    </dl> </li> 
  </ul> 
 </div> 
 <div class="summary"> 
  <ul class="blockList"> 
   <li class="blockList"> 
    <!-- =========== ANNOTATION TYPE OPTIONAL MEMBER SUMMARY =========== --> 
    <ul class="blockList"> 
     <li class="blockList"><a name="annotation.type.optional.element.summary"> 
       <!--   --> </a> <h3>Optional Element Summary</h3> 
      <table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Optional Element Summary table, listing optional elements, and an explanation"> 
       <caption> 
        <span>Optional Elements</span> 
        <span class="tabEnd">&nbsp;</span> 
       </caption> 
       <tbody> 
        <tr> 
         <th class="colFirst" scope="col">Modifier and Type</th> 
         <th class="colLast" scope="col">Optional Element and Description</th> 
        </tr> 
        <tr class="altColor"> 
         <td class="colFirst"><code>boolean</code></td> 
         <td class="colLast"><code><span class="memberNameLink"><a href="../../javax/management/MXBean.html#value--">value</a></span></code> 
          <div class="block" data-fanyi="1">
            如果注释的界面是一个MXBean接口。 
          </div> </td> 
        </tr> 
       </tbody> 
      </table> </li> 
    </ul> </li> 
  </ul> 
 </div> 
 <div class="details"> 
  <ul class="blockList"> 
   <li class="blockList"> 
    <!-- ============ ANNOTATION TYPE MEMBER DETAIL =========== --> 
    <ul class="blockList"> 
     <li class="blockList"><a name="annotation.type.element.detail"> 
       <!--   --> </a> <h3>Element Detail</h3> <a name="value--"> 
       <!--   --> </a> 
      <ul class="blockListLast"> 
       <li class="blockList"> <h4>value</h4> <pre>public abstract&nbsp;boolean&nbsp;value</pre> 
        <div class="block" data-fanyi="1">
          如果注释的界面是一个MXBean接口。 
        </div> 
        <dl> 
         <dt> 
          <span class="returnLabel">结果</span> 
         </dt> 
         <dd data-fanyi="1">
           如果注释的界面是一个MXBean接口。 
         </dd> 
        </dl> 
        <dl> 
         <dt>
           Default: 
         </dt> 
         <dd data-fanyi="1">
           真正的 
         </dd> 
        </dl> </li> 
      </ul> </li> 
    </ul> </li> 
  </ul> 
 </div> 
</div> 
<!-- ========= END OF CLASS DATA ========= --> 
<!-- ======= START OF BOTTOM NAVBAR ====== --> 
<div class="bottomNav"> 
 <a name="navbar.bottom"> 
  <!--   --> </a> 
 <div class="skipNav"> 
  <a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a> 
 </div> 
 <a name="navbar.bottom.firstrow"> 
  <!--   --> </a> 
 <ul class="navList" title="Navigation"> 
  <li><a href="../../overview-summary.html">概述</a></li> 
  <li><a href="package-summary.html">软件包</a></li> 
  <li class="navBarCell1Rev">类</li> 
  <li><a href="class-use/MXBean.html">使用</a></li> 
  <li><a href="package-tree.html">树</a></li> 
  <li><a href="../../deprecated-list.html">已过时的</a></li> 
  <li><a href="../../index-files/index-1.html">索引</a></li> 
  <li><a href="../../help-doc.html">帮助</a></li> 
 </ul> 
 <div class="aboutLanguage"> 
  <strong>Java™&nbsp;Platform<br>Standard&nbsp;Ed.&nbsp;8</strong> 
 </div> 
</div> 
<div class="subNav"> 
 <ul class="navList"> 
  <li><a href="../../javax/management/MBeanTrustPermission.html" title="class in javax.management"><span class="typeNameLink">上一个</span></a></li> 
  <li><a href="../../javax/management/NotCompliantMBeanException.html" title="class in javax.management"><span class="typeNameLink">下一个</span></a></li> 
 </ul> 
 <ul class="navList"> 
  <li><a href="../../index.html?javax/management/MXBean.html" target="_top">框架</a></li> 
  <li><a href="MXBean.html" target="_top">无框架</a></li> 
 </ul> 
 <ul class="navList" id="allclasses_navbar_bottom"> 
  <li><a href="../../allclasses-noframe.html">所有类</a></li> 
 </ul> 
 <div> 
  <script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script> 
 </div> 
 <div> 
  <ul class="subNavList"> 
   <li>概要：</li> 
   <li>字段</li> 
   <li>Required&nbsp;|&nbsp;</li> 
   <li><a href="#annotation.type.optional.element.summary">Optional</a></li> 
  </ul> 
  <ul class="subNavList"> 
   <li>详细信息：</li> 
   <li>字段</li> 
   <li><a href="#annotation.type.element.detail">Element</a></li> 
  </ul> 
 </div> 
 <a name="skip.navbar.bottom"> 
  <!--   --> </a> 
</div> 
<!-- ======== END OF BOTTOM NAVBAR ======= --> 
<p class="legalCopy"><small><font size="-1"> <a href="http://bugreport.sun.com/bugreport/">Submit a bug or feature</a> <br>For further API reference and developer documentation, see <a href="http://download.oracle.com/javase/8/docs/index.html" target="_blank">Java SE Documentation</a>. That documentation contains more detailed, developer-targeted descriptions, with conceptual overviews, definitions of terms, workarounds, and working code examples.<br> Copyright © 1993, 2014, Oracle and/or its affiliates. All rights reserved. </font></small> </p> 
<div id="adDiv"> 


 <div></div> 
</div> 
<p></p>